<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>在水异方 on 在水异方</title>
    <link>/</link>
    <description>Recent content in 在水异方 on 在水异方</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Sun, 11 Aug 2019 00:04:48 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Manjaro 踩坑记录</title>
      <link>/post/manjaro_go/</link>
      <pubDate>Sun, 11 Aug 2019 00:04:48 +0800</pubDate>
      
      <guid>/post/manjaro_go/</guid>
      <description>

&lt;p&gt;先说说背景，为什么MacBook还在吃灰，又开始折腾Linux Desktop了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;家里组了台PC，只打游戏太浪费，且实在搞不定windows写代码。&lt;/li&gt;
&lt;li&gt;传闻 manjaro 优化的不错&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是同时把pc和数莓派都改了。&lt;/p&gt;

&lt;h3 id=&#34;烧u盘偶尔失败&#34;&gt;烧U盘偶尔失败&lt;/h3&gt;

&lt;p&gt;表现为：烧录校验失败、无法启动&lt;/p&gt;

&lt;p&gt;按理以前从不会遇到，重新烧几次就好了，可能是u盘年久失修了。&lt;/p&gt;

&lt;h3 id=&#34;加速源&#34;&gt;加速源&lt;/h3&gt;

&lt;p&gt;这个地方坑了半天，一直以为manjaro就是arch的源，后来经 &lt;a href=&#34;https://github.com/zsrkmyn&#34; target=&#34;_blank&#34;&gt;zsrkmyn大佬&lt;/a&gt; 鄙视，才知道是不一样的。。&lt;/p&gt;

&lt;p&gt;所以 manjaro要做两件事，一是加速manjaro源，二是引进archlinux源，后者用来加一部分arch社区的软件。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 换中国源
$ cat /etc/pacman.d/mirrorlist

### Country : China
Server = https://mirrors.ustc.edu.cn/manjaro/stable/$repo/$arch
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# 加 archlinux
$ tail /etc/pacman.conf

[archlinuxcn]
SigLevel = Optional TrustedOnly
Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有个深坑，数莓派用的源的地址不能只把 manjaro 改成 manjaro-arm，后面的 $repo 和 $arch  顺序也不一样。
而且很多镜像源只提供 manjaro 不提供 marjaro-arm。&lt;/p&gt;

&lt;p&gt;最开始没仔细看，坑了好久。。&lt;/p&gt;

&lt;h3 id=&#34;无线网卡驱动&#34;&gt;无线网卡驱动&lt;/h3&gt;

&lt;p&gt;刚装机的时候没有网络，我用的老旧android手机连wifi，插到电脑上，允许usb上网。电脑会识别成以太网（win/mac也支持），网速还是挺快的，除了累赘，体验比无线网卡还好。&lt;/p&gt;

&lt;p&gt;我用的华硕USB-AC57，官网有驱动，下下来不能用。看下文件名，一般是 rtlXXX-linux-driver，这个rtlxxx就是型号，直接去网上搜关键词。arch aur 里就有社区版本，按步骤编译安装就好使了。&lt;/p&gt;

&lt;p&gt;TODO 开机联网慢，还没处理&lt;/p&gt;

&lt;p&gt;TODO 最近网络不稳，猜测也是这个驱动问题&lt;/p&gt;

&lt;p&gt;尽量还是走有线吧。&lt;/p&gt;

&lt;h3 id=&#34;输入法&#34;&gt;输入法&lt;/h3&gt;

&lt;p&gt;默认安装好 fcitx 后，状态栏也有了，但是不能切换。原因是并没有在x环境下启用，我的处理办法是在 xinitrc 里加了几行配置。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tail ~/.xinitrc

export XMODIFIERS=&amp;quot;@im=fcitx&amp;quot;
export GTK_IM_MODULE=xim
export QT_IM_MODULE=xim

exec $(get_session)  # 这行原来就有，不要动。在上面加三个export就行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，fcitx-qt4 会和 fcitx-gtk* 冲突，我用的后者。前者貌似才能支持搜狗。&lt;/p&gt;

&lt;h3 id=&#34;网络&#34;&gt;网络&lt;/h3&gt;

&lt;p&gt;装机需要配个pac，不然很多东西下不动。&lt;/p&gt;

&lt;p&gt;最好是在路由器里支持。&lt;/p&gt;

&lt;p&gt;manjaro里的话，好像只能针对每个网络单独配置。&lt;/p&gt;

&lt;p&gt;数莓派同时安装了酸酸乳和奶牛作为统一的入口，macbook顺利通过，但manjaro走奶牛PAC一直走不通，后来莫名其妙好了。。&lt;/p&gt;

&lt;h3 id=&#34;用户目录改英文&#34;&gt;用户目录改英文&lt;/h3&gt;

&lt;p&gt;网上搜了一堆教程都需要 &lt;code&gt;xdg-user-dirs-gtk-update&lt;/code&gt;，但默认只有 &lt;code&gt;xdg-user-dirs-update&lt;/code&gt;，擅自用了后者发现不好使，要装一下前者：&lt;code&gt;sudo pacman -S xdg-user-dirs-gtk&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Coding After 100&#43; Bugs</title>
      <link>/post/code_after_100_bugs/</link>
      <pubDate>Mon, 29 Jul 2019 14:19:31 +0800</pubDate>
      
      <guid>/post/code_after_100_bugs/</guid>
      <description>

&lt;p&gt;今年接手了一个新项目，不算vendor包，大概6W行代码，接的时候信心满满准备大干一场。结果半年内线上出了100多个bug。&lt;/p&gt;

&lt;p&gt;粗糙统计下，80%的代码是原来直接留下的，剩下的基本都是一脸懵逼地踩坑。其中也有不少是之前都知道，但是没处理掉，甚至还有查不到原因最后不了了之的。&lt;/p&gt;

&lt;h3 id=&#34;流程与业务规则隔离&#34;&gt;流程与业务规则隔离&lt;/h3&gt;

&lt;p&gt;其实在上一家公司工作时就已经意识到这个问题的严重性，尤其是业务流程和业务规则经常来回改。&lt;/p&gt;

&lt;p&gt;业务流程通常是一段简单的过程，甚至都不包含太多的分支流程。&lt;/p&gt;

&lt;p&gt;业务规则是指针对不同的数据，在各个环节里需要不同的处理。&lt;/p&gt;

&lt;p&gt;最常见的处理方式就是无处不在的 ifelse，这种方式的问题在于，每次改规则都要从头改一大堆代码，改完了还可能会影响其它 case，要整体回归才可以。效率和稳定性都很差。&lt;/p&gt;

&lt;p&gt;更好的办法是，在主流程上使用 interface 把业务流串下来，每种 case 各自实现接口，各自测试。&lt;/p&gt;

&lt;p&gt;有个小地方要注意，在设计这个 interface 时，要注意接口隔离原则，否则可能会出现为了增加一个特殊的 case，导致其它实现也跟着改一通。&lt;/p&gt;

&lt;h3 id=&#34;日志那么多-有多少能帮助你还原现场&#34;&gt;日志那么多，有多少能帮助你还原现场&lt;/h3&gt;

&lt;p&gt;每打一行日志，都想想什么时候用，怎么用。&lt;/p&gt;

&lt;h3 id=&#34;横向耦合-纵向耦合如果同时出现-代码就废了&#34;&gt;横向耦合、纵向耦合如果同时出现，代码就废了&lt;/h3&gt;

&lt;p&gt;一脚一个雷。&lt;/p&gt;

&lt;h3 id=&#34;该收的口子一定要收口&#34;&gt;该收的口子一定要收口&lt;/h3&gt;

&lt;p&gt;一段代码同时copy在多个流程里，维护起来丢三落四。&lt;/p&gt;

&lt;p&gt;丑陋的封装优于复制粘贴。&lt;/p&gt;

&lt;h3 id=&#34;聚合服务-千万不要关心别人的细节&#34;&gt;聚合服务，千万不要关心别人的细节&lt;/h3&gt;

&lt;p&gt;尤其是多个依赖的细节还不一样，真是灾难&lt;/p&gt;

&lt;h3 id=&#34;双写幂等性-可修复性&#34;&gt;双写幂等性，可修复性&lt;/h3&gt;

&lt;p&gt;不要第一次双写失败，导致后面数据都对不上。&lt;/p&gt;

&lt;p&gt;出现不一致，一定要第一时间报警&lt;/p&gt;

&lt;h3 id=&#34;避免阻塞性依赖&#34;&gt;避免阻塞性依赖&lt;/h3&gt;

&lt;p&gt;阻塞性依赖在流程管理中挺常见的，通常表现为在一系列操作中有几个操作依赖于不稳定的第三方。当中间一个环节出现不可控的故障时，会导致你的整个流程走不下去，然而因为是第三方出了问题，你只能干等着。&lt;/p&gt;

&lt;p&gt;如果同时你的接口不具有全局的幂等性，这个问题还会造成非常恶心的数据不一致，处理起来也非常麻烦。&lt;/p&gt;

&lt;p&gt;一个设计上的优化是把依赖第三方的环节后置。举个例子：&lt;/p&gt;

&lt;p&gt;BBS 里用户发的消息要经过敏感词检查才能放出来，但如果你的敏感词接口挂了，可能导致全站不能发帖。一个可行的办法是，先发帖成功，再异步调用敏感词接口。有个问题是，在敏感词接口返回结果或恢复正常前的这段时间，贴子展示出来是否有风险？这个可以依据业务场景来处理，平时可以默认先放出来，敏感时期，那就让这个帖子只有自己可见，其它人等审核完成后才能看到。&lt;/p&gt;

&lt;p&gt;成本会稍微高一些，但是系统健壮性会好很多。&lt;/p&gt;

&lt;h3 id=&#34;字段命名一致性&#34;&gt;字段命名一致性&lt;/h3&gt;

&lt;h3 id=&#34;数据结构上-不建议一个字段在不同场景下表示不同含义&#34;&gt;数据结构上，不建议一个字段在不同场景下表示不同含义&lt;/h3&gt;

&lt;p&gt;大概出于省空间的目的，一个字段在不同 case 下表示了完全不一样的含义，时间长了。大家都懵逼了。&lt;/p&gt;

&lt;h3 id=&#34;依赖服务的返回值-日志一定要清晰&#34;&gt;依赖服务的返回值，日志一定要清晰&lt;/h3&gt;

&lt;p&gt;善意的质疑，降低撕逼风险，这大概叫职业。&lt;/p&gt;

&lt;h3 id=&#34;处理err时-一定要想想-如果这个error出来了-如何主动让我发现&#34;&gt;处理err时，一定要想想：如果这个error出来了，如何主动让我发现&lt;/h3&gt;

&lt;p&gt;api 错误后，如何快速定位哪一层抛的错&lt;/p&gt;

&lt;h3 id=&#34;任何有业务含义的字段不能用来做pk&#34;&gt;任何有业务含义的字段不能用来做pk&lt;/h3&gt;

&lt;p&gt;一改就疯&lt;/p&gt;

&lt;h3 id=&#34;数据修改记录的重要性&#34;&gt;数据修改记录的重要性&lt;/h3&gt;

&lt;p&gt;最严重的有一张表没有创建和修改的时间戳，查数据问题时，都不知道从哪里开始查。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go项目在组织启动代码上的一次尝试</title>
      <link>/post/boot_test_in_go/</link>
      <pubDate>Tue, 02 Jul 2019 11:11:16 +0800</pubDate>
      
      <guid>/post/boot_test_in_go/</guid>
      <description>&lt;p&gt;最开始的项目目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tree
.
├── ./api/
├── ./service/
├── ./dao/
├── ./model/
├── main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main(){
	flag.Parse()
	artemis := NewArtemis(flag.String(`config`))	// artemis 是我们的框架，类似beego
	log.init()
	service.init()
	dao.init()
	worker.init()
	api.Route(artemis.Router)
	artemis.Run()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写个测试吧&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;packege dao

func TestGetNote(t *testing.T){
	db := NewNoteDB()	// panic: app not init
	db.Get(1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;copy启动代码&lt;/li&gt;
&lt;li&gt;把config路径改一下&lt;/li&gt;

&lt;li&gt;&lt;p&gt;去除不需要的部分，比如在 dao 里去掉 service.init()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestGetNote(t *testing.T){
	artemis := NewArtemis(`../../config`)
	log.init()
	ddns.init()
	service.init()
	dao.init()
	// test code 
}

// 也可以放在 TestMain 里统一处理
func TestMain(m *testing.M){
// init()
m.Run()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;简单粗暴的解决办法，调试也够用了。&lt;/p&gt;

&lt;p&gt;如果 package 比较少，也没那么多脚本要用，已经能满足需要了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但当时我觉得还是不完美，我的项目又比较复杂，然后继续尝试优化：&lt;/p&gt;

&lt;p&gt;先抽出个函数放重复代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package boot
func Boot(){
	// init()
}
func BootTest(){
	SetRootPath()		// 在子目录跑ut时，要把 wd 对齐到项目目录
	Boot()
}

package main
func main(){
	boot.Boot()
	artemis.Run()
}

package dao
func test(){
	boot.BootTest()
	// test code
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ go build
import cycle not allowed
# dao 和 boot 互相依赖
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改成外部测试&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package dao_test

import &amp;quot;dao&amp;quot;

func test(){
	db := dao.NewDB()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ugly&lt;/li&gt;
&lt;li&gt;不能测私有函数&lt;/li&gt;
&lt;li&gt;每次改动几乎重新编译整个项目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后一点很重要，测试代码时会频繁修改，而每次修改几乎都要重新编译整个项目。
我的项目在忽略缓存的情况下，编译需要30s
调个bug，一下午就过去了。。&lt;/p&gt;

&lt;p&gt;回头一看整个过程，总结就是&lt;/p&gt;

&lt;p&gt;　　&lt;center&gt; &lt;h2&gt; 民科 &lt;/h2&gt; &lt;/center&gt;&lt;/p&gt;

&lt;p&gt;于是，放下一切，重新开始&lt;/p&gt;

&lt;p&gt;我想要什么？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不用太多重复代码，好维护&lt;/li&gt;
&lt;li&gt;需要时再加载，不需要在测试时搞一堆没用的东西&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看看成熟的框架是如何处理的，以我熟悉的 Laravel 为例，很多地方都采用了这样的思路：先注册，后使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class FooServiceProvider {
	function register($app) {
		$app-&amp;gt;singleton(&amp;quot;noteDB&amp;quot;, function(){
			$noteDB = new NoteDB();
		})
		
		$app-&amp;gt;sinleton(IRouter::class, new Router())
	}
	
	function boot() {
		make(IRouter::class)-&amp;gt;load();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;突然发现，Go的init就是天然的注册机制&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有的init都一定会在main之前执行&lt;/li&gt;
&lt;li&gt;依赖包的init一定先于本包的init，连优先级都帮我做好了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是大概轮廓就出来了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在每个 init 里定义自己需要启动什么，代码里依赖了哪个包，就会调用对应的init，不依赖的不会启动&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行cmd（webserver/script/test）时，再逐个执行init时注册的任务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package dao
func init(){
	boot.Register(func(){
		// ...
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// web server
func main(){
	boot.Boot()
	defer boot.Shutdown()

	api.Route(artemis.App)
	artemis.Run()
}

// script
func main(){
	boot.Boot()
	// ...
}

// test
func TestMain(m *testing.M){
	boot.Register(factories.Init)

	boottest.Boot()
	defer boottest.Shutdown()

	m.Run()
	// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/07/07/5d20cf8d95b3762646.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;!-- ![image-20190702122735634](boot_test_in_go.assets/image-20190702122735634.png) --&gt;

&lt;p&gt;到此，基本上达成了写脚本、写单测时不用操心框架启动的问题。&lt;/p&gt;

&lt;p&gt;不过限于框架限制，依然有一些不爽的地方没有解决。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Go很多人摒弃了面向接口编程，导致在写UT时无从mock。后面想办法靠工具对所有的类走一次DI容器&lt;/li&gt;
&lt;li&gt;测试的问题，限于框架限制，不能全局开始事务&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>当我们在说浮点数精度不准的时候，到底在说什么</title>
      <link>/post/float_kidding/</link>
      <pubDate>Mon, 24 Jun 2019 22:12:55 +0800</pubDate>
      
      <guid>/post/float_kidding/</guid>
      <description>

&lt;p&gt;原以为浮点数是计算机编程的基础知识，后来发现个奇怪的现象：很多人都说浮点很坑，千万不要用，至于为什么却说不出个所以然。更有甚者，以专业民科的架势发明出一套处理浮点的办法，应该如何如何，不该如何如何。网上也看到不少人对这个现象很困惑，解释为湿猴理论。&lt;/p&gt;

&lt;p&gt;通常你问别人浮点有什么坑，如果别人说浮点数不能用==，十有八九这个人会认为，浮点数可以用&amp;gt;&amp;lt;的。不过你继续追问，他可能就会犹豫了。&lt;/p&gt;

&lt;p&gt;看代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a := 0.1
b := 0.2
c := 0.3

fmt.Printf(&amp;quot;%10s =&amp;gt; %v\n&amp;quot;, &amp;quot;a+b&amp;quot;, a+b)
fmt.Printf(&amp;quot;%10s =&amp;gt; %v\n&amp;quot;, &amp;quot;a+b == c&amp;quot;, a+b == c)
fmt.Printf(&amp;quot;%10s =&amp;gt; %v\n&amp;quot;, &amp;quot;a+b &amp;lt; c&amp;quot;, a+b &amp;lt; c)
fmt.Printf(&amp;quot;%10s =&amp;gt; %v\n&amp;quot;, &amp;quot;a+b &amp;gt; c&amp;quot;, a+b &amp;gt; c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/QdoleMRyJr3&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/QdoleMRyJr3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;why？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;按照浮点标准，0.1 转化成二进制是个无限小数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;浮点数有效长度有限，必有取舍&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结，二进制无法准确表达0.1，多多少少会有点失真。遂不能直接比较大小。&lt;/p&gt;

&lt;p&gt;更详细的论述：&lt;a href=&#34;https://www.zhihu.com/question/28551135&#34; target=&#34;_blank&#34;&gt;https://www.zhihu.com/question/28551135&lt;/a&gt;
&lt;!-- 另外注意，测试这段代码的时候不要用常亮，可能会被编译器优化掉。 --&gt;&lt;/p&gt;

&lt;h3 id=&#34;浮点数如何比较&#34;&gt;浮点数如何比较？&lt;/h3&gt;

&lt;p&gt;通常做法，如果两个数的差值在可接受范围内，就认为是相等的。其实很多非精确的比较都是类似方法，比如&lt;/p&gt;

&lt;p&gt;1、两个人年龄、五官等等主要特征都很像，你就敢猜这俩人是双胞胎了。
2、你的服务10:03开始大量报错，隔壁服务10:02上了个线，你猜大概就是他的锅。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var floatPrecision = 1e-6

func floatEqual(a float64, b float64) bool {
	return math.Abs(a-b) &amp;lt; floatPrecision
}

func floatLess(a float64, b float64) bool {
	return b-a &amp;gt; floatPrecision
}

func floatGreater(a float64, b float64) bool {
	return a-b &amp;gt; floatPrecision
}

func main(){
	fmt.Println(floatEqual(a+b, c))	// true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;浮点数怎么转换&#34;&gt;浮点数怎么转换&lt;/h3&gt;

&lt;p&gt;跟整型转换比较简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 去尾
func floatFloor(a float64) int {
	return int(a)
}

// 四舍五入
func floatToInt(a float64) int {
	return int(math.Round(a))
	//return int(a + 0.5)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟浮点转换就有意思了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 打印浮点数
func testFloatToString(){	
  f := 16.99
	fmt.Println(f * 10)
	fmt.Println(f * 100)
	fmt.Println(f * 1000)
	fmt.Println(f * 10000)
	fmt.Printf(&amp;quot;%.2f\n&amp;quot;, f*10000)
	fmt.Printf(&amp;quot;%.0f\n&amp;quot;, f*10000)
}

169.89999999999998
1698.9999999999998
16990
169899.99999999997
169900.00
169900
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;strconv&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gowalker.org/strconv#FormatFloat&#34; target=&#34;_blank&#34;&gt;https://gowalker.org/strconv#FormatFloat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gowalker.org/strconv#ParseFloat&#34; target=&#34;_blank&#34;&gt;https://gowalker.org/strconv#ParseFloat&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;浮点数要不要用字符串传输&#34;&gt;浮点数要不要用字符串传输？&lt;/h3&gt;

&lt;p&gt;有人问，如果别人想传1，结果传了个0.99999，不就失真了吗？&lt;/p&gt;

&lt;p&gt;基本上这样问的都是因为用的时候直接用了比较操作符。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;原来的 double 有 15 位有效数字，一般转成 string 后只刻意保留了几位，如果是直接截取，其实是主动丢弃了准确度。&lt;/p&gt;

&lt;p&gt;举例：本来要传 1，截取之后传了 0.999 ，别人并不不知道这个 0.999 是准确值还是你截出来的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;个人推荐，传输的时候保留原数据，只有在渲染的时候再做格式化处理。&lt;/p&gt;

&lt;p&gt;问题核心：怎么存不重要，怎么用才是关键。想着存的时候干净一点，用的时候就随意了。&lt;/p&gt;

&lt;h3 id=&#34;财务场景下的特殊处理&#34;&gt;财务场景下的特殊处理&lt;/h3&gt;

&lt;p&gt;仔细想了想，好像财务上也没什么特别要处理的，怀疑自己知识面不够，就去网上翻了翻，虽然没看到什么新问题，却又不少其他的收获。比如&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;系统性误差有系统性解决办法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我对这句话的理解，不要把计算机看得太重了，计算机只是解决领域问题的一个工具，准确的说只是特定时期的计算工具，专业的领域在手工计算的时代就有专业的算法了。&lt;/p&gt;

&lt;p&gt;这里只提一个最开始想到的跟普通场景的区别：不能简单的四舍五入&lt;/p&gt;

&lt;p&gt;先抛开小数不谈，现实生活中，3个人平分10块钱，理论上一人3.33，实际上大家会按照3-3-4来分就够了。放到微信群收款里，也是3.33*2+3.34。并没有统一用四舍五入。&lt;/p&gt;

&lt;p&gt;这种问题在实际问题中出现也比较多，把一笔订单拆分成几笔子订单，把一笔成本摊销到一年。在做除法的时候都要根据具体场景来做取舍。其实都不算什么浮点问题。&lt;/p&gt;

&lt;h2 id=&#34;扩展&#34;&gt;扩展&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;能否直接用高精度 math/big.Float 来解决浮点数的诡异问题？&lt;a href=&#34;https://play.golang.org/p/-8C7Gg7uHxd&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/-8C7Gg7uHxd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;wiki &lt;a href=&#34;https://zh.wikipedia.org/wiki/IEEE_754&#34; target=&#34;_blank&#34;&gt;https://zh.wikipedia.org/wiki/IEEE_754&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>在 Go 里避免空指针问题</title>
      <link>/post/avoid_npe_in_go/</link>
      <pubDate>Thu, 16 May 2019 21:58:24 +0800</pubDate>
      
      <guid>/post/avoid_npe_in_go/</guid>
      <description>

&lt;p&gt;空指针异常 NPE 在所有编程语言里都是个很麻烦的事情，Go 在设计之初已经在尽力减少 null 的使用范围，但恰恰由于隐藏了值和引用的概念，使得很多新手在处理的时候把空引用当成空值，从而引发了 panic。另一种常见的 npe 是使用指针不当引起。&lt;/p&gt;

&lt;p&gt;本文通过自己的经验，试图提供一些避免 NPE 的方法出来。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;先来看一种最常见的情形&lt;/p&gt;

&lt;h2 id=&#34;定义嵌套结构体时-尽可能不嵌套指针&#34;&gt;定义嵌套结构体时，尽可能不嵌套指针&lt;/h2&gt;

&lt;p&gt;比较容易理解&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Male struct{
	Human
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;组合时优先用 Human 而不是 &lt;code&gt;*Human&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;有人会顾虑，那我想用 &lt;code&gt;*Human&lt;/code&gt; 的方法怎么办，很简单，&lt;code&gt;*Male&lt;/code&gt; 其实是包含 &lt;code&gt;*Human&lt;/code&gt; 的方法的。&lt;/p&gt;

&lt;p&gt;这样做最主要的原因，也是很多人在 &lt;code&gt;new(Male)&lt;/code&gt; 时忘记 &lt;code&gt;new(Human)&lt;/code&gt;，导致给上层抛了个 nil。更要命的，如果这个 struct 直接转成 json 抛了出去，如果下游对 null 也没处理好，这就是个跨端 bug 了。&lt;/p&gt;

&lt;p&gt;这个也可以衍生一个小规范，定义变量尽量用 struct 而不是指针，传参的时候再使用。不过我感觉这个带来的坑不如上面大，所以不支持不反对。。&lt;/p&gt;

&lt;h2 id=&#34;函数返回值返回了-nil&#34;&gt;函数返回值返回了 nil&lt;/h2&gt;

&lt;p&gt;一个连环坑&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 获取 user 对象
func GetUser() (*User, error)

func main() {
	user,err := GetUser()
	if err != nil { 
		write(err.Error())
		return 
	}

	println(user.Name)	// panic user=nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般的，我们会觉得既然我都判 error 了，user 的值总该是正常了吧。只能说 too naive。聪明一点的人可能马上想到解决办法，在 &lt;code&gt;err != nil&lt;/code&gt; 的地方也判一下 user：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if err != nil || user == nil {
	write(err.Error())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，就悲催的发现还是 panic 了。因为当 &lt;code&gt;user=nil &amp;amp;&amp;amp; err==nil&lt;/code&gt; 时，也会走到 &lt;code&gt;err.Error()&lt;/code&gt; 这里，这里的 &lt;code&gt;err.xx&lt;/code&gt; 又是一个 NPE！&lt;/p&gt;

&lt;p&gt;老老实实的一个个处理固然是好办法，但是难保谁一个手抖。&lt;/p&gt;

&lt;p&gt;所以我们换个思路，想想能不能对 GetUser 这个函数做一些要求。问题就变成了有什么简单的办法让函数不返回 nil。&lt;/p&gt;

&lt;p&gt;不说中间的尝试了，直接说我们的结论：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;函数返回值可能返回 nil 时，定义返回值必须 &lt;strong&gt;&lt;em&gt;带上变量名&lt;/em&gt;&lt;/strong&gt;，并且在函数体内 &lt;strong&gt;&lt;em&gt;首行进行初始化&lt;/em&gt;&lt;/strong&gt;。函数返回时 &lt;strong&gt;&lt;em&gt;不带变量名&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;给个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GetUsers() (users []*User, err error) {
	users = make([]*User, 0, 32)
	// function body
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三个条件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;必须有变量名&lt;/li&gt;
&lt;li&gt;必须首行初始化&lt;/li&gt;
&lt;li&gt;return 无参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三点共同保证第一个目的：函数在任何地方 return，都不会给上层抛出 nil&lt;/p&gt;

&lt;p&gt;具体解释一下，为什么 变量名放在函数签名里而不在 return 里。是因为当函数很复杂需要多个 return 时，每个 return 时 users 里是啥你心里不一定有概念。也顾不上去考虑。索性把这个任务就交给定义阶段了。&lt;/p&gt;

&lt;p&gt;另外，返回值在函数开头就一起定义&amp;amp;初始化了。在 code review 时也更容易注意到。在看函数体的时候也不用再去想这个问题了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;函数入参有指针时给了-nil-怎么办&#34;&gt;函数入参有指针时给了 nil 怎么办&lt;/h2&gt;

&lt;p&gt;在 Go 里有个很普遍的情况，函数的最后一个入参其实表示的是函数返回值。看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getUserArticles(userId int, articles map[int]Article) {
	articles[1] = &amp;amp;Article{}	// panic: articles 未初始化
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好说，那我 new 一个吧。一般没问题。&lt;/p&gt;

&lt;p&gt;但是如果 articles 里已经有一部分数据了，这里只是需要你 append 呢？更常见的，articels 是个结构体指针，里面有一些字段是需要的，你不能给删咯。&lt;/p&gt;

&lt;p&gt;更可怕的，如果这个参数传了好多层，鬼还记得他里面到底是啥。&lt;/p&gt;

&lt;p&gt;针对这种 case，我们也做了一些简单的约定：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;谁定义，谁初始化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参照这个例子来说，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果函数为 &lt;code&gt;func() articles&lt;/code&gt;，那我来初始化，保证不返回 nil，如果保证呢？参照上面那条规范。&lt;/li&gt;
&lt;li&gt;如果函数为 &lt;code&gt;func(articles)&lt;/code&gt;，那调用方来初始化，保证不传 nil&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个简单的约束，保证绝大多数参数简单稳定地运行。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;下班时突然心血来潮想整理一下，休息一下。未完待续。。&lt;/p&gt;

&lt;p&gt;欢迎讨论。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Goption：一个针对 Go struct 的代码生成器</title>
      <link>/post/goption/</link>
      <pubDate>Tue, 14 May 2019 01:09:31 +0800</pubDate>
      
      <guid>/post/goption/</guid>
      <description>

&lt;h2 id=&#34;缘起&#34;&gt;缘起&lt;/h2&gt;

&lt;p&gt;写代码里有个绕不开的话题就是如何写构造函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java 里有 JavaBean 作为标准，空构造参数 + 自定义的 setter&lt;/li&gt;
&lt;li&gt;C++ 里靠重载实现任意场景的构造&lt;/li&gt;
&lt;li&gt;Python 里可以可以支持传你需要的参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go 呢，一无所有，最通行的办法，大概是可变参作为可选的 options&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewX(options ...Option) *X {
	x := &amp;amp;X{}
	for _, opt := range options {
		opt.apply(x)
	}
	return x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，你每次不得不把一个个简单的参数定义成一大堆的 option，多么烦人。&lt;/p&gt;

&lt;p&gt;所以，goption 就出场了&lt;/p&gt;

&lt;h2 id=&#34;一睹为快&#34;&gt;一睹为快&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://cdn.sinaimg.cn.52ecy.cn/large/005BYqpgly1g307gsts99g30gn0amx6w.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;是不是太快了看不清。听我慢慢道来。&lt;/p&gt;

&lt;p&gt;以 Goland 为示例，首先在定义 struct 时添加标识&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//go:generate goption -p . -c Person -w
type Person struct{
	// your person fields
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的好处是，IDE 可以为你提供快捷按钮，你只需要点一下就生成了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/14/5cd9ab3b3a6d835729.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;点击按钮后，会在同 packagge 下生成 &lt;code&gt;person_option_gen.go&lt;/code&gt; 代码大约是这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type PersonOption func(*Person)

func NewPerson(opts ...PersonOption) (person *Person) {
	person = &amp;amp;Person{}
	for _, opt := range opts {
		opt(person)
	}
	return
}

func WithPersonName(name string) func(*Person) {
	return func(person *Person) {
		person.Name = name
	}
}

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何使用呢，也很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	p1 := NewPerson()		// 普通构造方式

	p2 := NewPerson(		// 自定义字段方式
		WithPersonName(`zhangsan`),
		WithPersonAge(18),
	)
	println(p1, p2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用起来真是爽了不少。&lt;/p&gt;

&lt;p&gt;放上代码地址：&lt;a href=&#34;https://github.com/micln/goption&#34; target=&#34;_blank&#34;&gt;https://github.com/micln/goption&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;如何实现&#34;&gt;如何实现&lt;/h2&gt;

&lt;p&gt;最开始绕了点弯路，自己一层层解析 ast.Node，后来发现 &lt;a href=&#34;https://gowalker.org/go/doc&#34; target=&#34;_blank&#34;&gt;go/doc&lt;/a&gt; 已经帮你解析了 package，里面有哪些 Types，哪些 Funcs，都非常清楚，可以直接拿来用。&lt;/p&gt;

&lt;p&gt;唯一需要处理的就是如何 ast.Expr 表示的代码展示出来，好在之前玩过 ast 相关的，也整理了一下 &lt;a href=&#34;https://github.com/Kretech/xgo/blob/master/astutil/expr.go&#34; target=&#34;_blank&#34;&gt;astutil 放了出来&lt;/a&gt;，后面还会继续完善。所以就大大减少了难度。&lt;/p&gt;

&lt;h2 id=&#34;后续&#34;&gt;后续&lt;/h2&gt;

&lt;p&gt;费这么大劲如果只做这一件事确实有点亏，后续希望把 Generator 开放出来，我帮你解析源码和集成 IDE，你只需要自定义模板，就可以生成任何你想要的辅助方法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一个会导致 go build panic 的 bug</title>
      <link>/post/a_go_build_panic_bug/</link>
      <pubDate>Tue, 14 May 2019 00:35:38 +0800</pubDate>
      
      <guid>/post/a_go_build_panic_bug/</guid>
      <description>&lt;p&gt;起因是因为犯懒，随手在一个函数体内定义一个类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func foo() {
	type Article = map[string]interface{}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来好像也很正常，突然有一天在 gowatch 的控制台里看到了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;runtime: goroutine stack exceeds 1000000000-byte limit
fatal error: stack overflow
runtime stack:
runtime.throw(0x1a556a1, 0xe)
/usr/local/Cellar/go/1.12.5/libexec/src/runtime/panic.go:617 +0x72
runtime.newstack()
/usr/local/Cellar/go/1.12.5/libexec/src/runtime/stack.go:1041 +0x6f0
runtime.morestack()
/usr/local/Cellar/go/1.12.5/libexec/src/runtime/asm_amd64.s:429 +0x8f
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以为是程序出 panic 了，不过仔细看了看，好像不是我的代码，仔细一研究，发现程序还没跑起来，&lt;code&gt;go build&lt;/code&gt; 时已经 panic 了。然后经过各种 &lt;code&gt;git stash&lt;/code&gt;，终于发现，原来是因为外面也定义了一个 &lt;code&gt;type Article struct{}&lt;/code&gt; 导致的 panic。&lt;/p&gt;

&lt;p&gt;印象中函数体内和函数外是可以重名的，而且，即便不可以，也应该编译失败才对，怎么就 panic 了。&lt;/p&gt;

&lt;p&gt;于是尝试了一下&lt;/p&gt;

&lt;p&gt;如果同时定义两个重名类型，会提示 &lt;code&gt;redeclared in this block&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type A struct{}
type A = map[string]string

// A redeclared in this block
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果分开到两个 block，就编译通过了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type A struct{}
func main(){
	type A = map[string]string
}

// build success
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;奇了个怪。那为什么我的程序会 panic 呢？&lt;/p&gt;

&lt;p&gt;又经过尝试，终于发现，在本包内正常调用是可以的，只有当其他包引用此包时才会 panic。而且，如果把函数体内的 &lt;code&gt;type X = Y&lt;/code&gt; 改成 &lt;code&gt;type X Y&lt;/code&gt; 也是可以编译通过的。&lt;/p&gt;

&lt;p&gt;总结起来，两个条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在两个 block 内同时定义 &lt;code&gt;type X&lt;/code&gt; 和 &lt;code&gt;type X=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在其他包里引入此包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之后，给 goteam &lt;a href=&#34;https://github.com/golang/go/issues/31959&#34; target=&#34;_blank&#34;&gt;提了个 issue 来反馈这个诡异的 bug&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;忧伤的地方来了，自己只能发现 bug，完全不具备追查 bug 产生的原因。&lt;/p&gt;

&lt;p&gt;立个 flag 吧，希望有时间可以研究研究编译器相关的一些知识。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Module 实践中的问题（持续更新）</title>
      <link>/post/gomod/</link>
      <pubDate>Sun, 14 Apr 2019 11:20:27 +0800</pubDate>
      
      <guid>/post/gomod/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;项目逐渐都切到了 go mod，用的时候遇到了各种奇奇怪怪的坑，记录一下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;流程实践&#34;&gt;流程实践&lt;/h2&gt;

&lt;h3 id=&#34;语义化版本&#34;&gt;语义化版本&lt;/h3&gt;

&lt;p&gt;Go mod 在设计时没有支持诸如 &lt;code&gt;&amp;gt;2.0&lt;/code&gt;, &lt;code&gt;~3.4&lt;/code&gt;, &lt;code&gt;^4.0&lt;/code&gt; 这样场景的语法。而是以语义化版本的约定来处理：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;x.y.z&lt;/code&gt; ≈ &lt;code&gt;^x.y&lt;/code&gt; + &lt;code&gt;&amp;lt;=y.z&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;实际中，对于内部频繁升级的 common 包，每次改动都需要 &lt;code&gt;y+=1&lt;/code&gt; 才能保证兼容性。为此我专门搞了个&lt;a href=&#34;https://github.com/micln/gt&#34; target=&#34;_blank&#34;&gt;小玩意&lt;/a&gt;来升级 y，可以通过 hook 在 push 前先 &lt;code&gt;gt ft&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;有个比较恶心的问题，common 包的版本号长期维持在 &lt;code&gt;1.y.0&lt;/code&gt; 且 y 很大。暂时没用解决的办法，后面再看看 &lt;code&gt;x&lt;/code&gt; 能有什么新玩法。&lt;/p&gt;

&lt;h3 id=&#34;不同分支依赖冲突&#34;&gt;不同分支依赖冲突&lt;/h3&gt;

&lt;p&gt;如图，一个常见的场景，多人开发项目时，有可能在开发过程中使用了不同的依赖包，在合并代码的时候也会冲突。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/04/14/5cb2ad7c07f41.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;以前的办法是有个专门的 vendor 分支，把有关依赖的变动串行化。&lt;/p&gt;

&lt;p&gt;但是用了 gomod 后，如果你只在 vendor 分支 里加了依赖没有用，&lt;code&gt;go mod tidy&lt;/code&gt; 时又会把依赖给去掉。&lt;/p&gt;

&lt;p&gt;好在大部分时候都是需要更新而不是新增依赖，这个思路依然可用。我们给项目里专门准备了一个脚本来升级依赖，这个脚本做的事情也比较简单，切换到 vendor 分支，更新，提交。再合回 feature 分支。&lt;/p&gt;

&lt;h2 id=&#34;异常问题处理&#34;&gt;异常问题处理&lt;/h2&gt;

&lt;h3 id=&#34;go-replace-替换大小写时不支持同时依赖大小写&#34;&gt;go replace 替换大小写时不支持同时依赖大小写&lt;/h3&gt;

&lt;p&gt;P-&amp;gt;A
P-&amp;gt;xx-&amp;gt;a&lt;/p&gt;

&lt;p&gt;天真以为把 A replace a 就好了。还是会报同时用了大小写的错。&lt;/p&gt;

&lt;p&gt;只有当所有依赖都依赖 A，但是 github 已经改成 a 时，才能 replace。&lt;/p&gt;

&lt;p&gt;问题最初是由于 github.com/sirupsen/logrus 更换大小写引起，如果项目全用 Sirupsen 是可以 replace 的，后来有了混用就不行了。终极解决办法是干掉 logrus 。。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;凡是随意修改包路径、函数签名的 Go Libs，基本上都被我列入黑名单了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;build-xx-ambiguous-import-xx-in-multiple-modules&#34;&gt;build xx: ambiguous import: xx in multiple modules:&lt;/h3&gt;

&lt;p&gt;通常是在没有使用语义化版本时，对一个包有不同版本的依赖导致。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build xxx.com/com/projA: cannot load xxx.com/com/projB/model: ambiguous import: found xxx.com/com/projB/model in multiple modules:
	xxx.com/com/projB v0.0.0-20181119101949-92ae1f75b49a (.../pkg/mod/xxx.com/com/projB@v0.0.0-20181119101949-92ae1f75b49a/model)
	xxx.com/com/projB/model v0.0.0-20190311082816-bfb94e79a84f (.../pkg/mod/xxx.com/com/projB/model@v0.0.0-20190311082816-bfb94e79a84f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过下面方式来找&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fd go.mod | xargs grep -r projB
vendor/xxx.com/com/base/go.mod:	xxx.com/com/projB/registry v0.0.0-20190312132550-a101ae8810b6 // indirect
vendor/xxx.com/com/artemis/go.mod:	xxx.com/com/projB/app/goprojB v0.0.0-20190312132550-a101ae8810b6
vendor/xxx.com/com/projB/registry/go.mod:module xxx.com/com/projB/registry
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;go-replace-不能替换依赖包的依赖&#34;&gt;go replace 不能替换依赖包的依赖&lt;/h3&gt;

&lt;p&gt;我的项目P -&amp;gt; A&amp;amp;B，且 B-&amp;gt;A&lt;/p&gt;

&lt;p&gt;如果把 A replace 成 A‘，只能修改 P-&amp;gt;A 的依赖， B-&amp;gt;A 是改不了的。&lt;/p&gt;

&lt;p&gt;所以 replace 不能解决梯子的问题，要用 goproxy&lt;/p&gt;

&lt;h3 id=&#34;go-get-error-loading-module-requirements&#34;&gt;go get: error loading module requirements&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;go clean -modcache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;清理 modcache 几乎是各种问题的终极大杀器，但是成本也很高，需要你下次重拉所有 mod。如果公司内有 proxy 做 cache 的话会好一些。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gt</title>
      <link>/project/gt/</link>
      <pubDate>Thu, 11 Apr 2019 23:39:11 +0800</pubDate>
      
      <guid>/project/gt/</guid>
      <description>&lt;p&gt;abc&lt;/p&gt;

&lt;p&gt;aaa&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Json Iterator 在 swagger 下卡死程序的排查</title>
      <link>/post/jianshu/json-iterator-%E5%9C%A8-swagger-%E4%B8%8B%E5%8D%A1%E6%AD%BB%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%92%E6%9F%A5/</link>
      <pubDate>Mon, 25 Mar 2019 00:22:45 +0800</pubDate>
      
      <guid>/post/jianshu/json-iterator-%E5%9C%A8-swagger-%E4%B8%8B%E5%8D%A1%E6%AD%BB%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%92%E6%9F%A5/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;迁移自简书，格式可能未经校对。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;事件经过&#34;&gt;事件经过：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;收到反馈测试环境某个服务打开 swagger ，进程会卡死&lt;/li&gt;
&lt;li&gt;根据经验，初步判定是有死循环。&lt;/li&gt;
&lt;li&gt;在本地启动该服务，打开 swagger ，发现 CPU 单核100%，确认有死循环&lt;/li&gt;
&lt;li&gt;pprof 抓取 cpu profile&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/444689-09f40a9ba477adc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;cpu profile&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在 marshal 前后打断点，对于特定链接，marshal 没结束(没看到 done 日志)&lt;/li&gt;
&lt;li&gt;更换为官方 json 库，恢复正常。确认是 json-iterator 导致&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/444689-48997521bb661586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在其他项目做同样操作，未能复现问题。对比jsoniter 版本，初步判定是版本过老导致。&lt;/li&gt;
&lt;li&gt;通过 debug，确认是下面这个循环走不出来&lt;/li&gt;
&lt;li&gt;升级 jsoniter ，恢复正常&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/444689-db03ec2a8790b391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;到官方一看，这个bug 很早就解决了。但是出事的服务还在依赖 2017-8-9 的版本。（修复链接：&lt;a href=&#34;https://github.com/json-iterator/go/commit/f7063353029dd177a959dbf6b29f48746441fbfa#diff-34ab17b5ece86461ae47905134a8d94c）&#34; target=&#34;_blank&#34;&gt;https://github.com/json-iterator/go/commit/f7063353029dd177a959dbf6b29f48746441fbfa#diff-34ab17b5ece86461ae47905134a8d94c）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/444689-f323b426f928371c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;第二个问题-为什么整个程序会假死&#34;&gt;第二个问题，为什么整个程序会假死&lt;/h3&gt;

&lt;p&gt;按理说，for{} 会造成单个协程停不下，CPU 单核打满都好理解，但为什么会让整个进程死掉？&lt;/p&gt;

&lt;p&gt;原因在于 GC标记前，需要通知所有 goroutine 停下来，但是问题协程一直停不下来，而正常协程都已经停下来在等待。所以对外无法正常服务，看起就是死掉了。&lt;/p&gt;

&lt;h3 id=&#34;暴露的问题&#34;&gt;暴露的问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;对 Go 底层完全 hold 不住&lt;/li&gt;
&lt;li&gt;第三方依赖管理不规范&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;参考链接&#34;&gt;参考链接&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;历史四年的关于for{}的抢占式讨论 &lt;a href=&#34;https://github.com/golang/go/issues/10958&#34; target=&#34;_blank&#34;&gt;https://github.com/golang/go/issues/10958&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Goroutine调度实例简要分析 &lt;a href=&#34;https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/&#34; target=&#34;_blank&#34;&gt;https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;滴滴大佬如何定位 golang 进程 hang 死的 bug &lt;a href=&#34;https://gocn.vip/article/441&#34; target=&#34;_blank&#34;&gt;https://gocn.vip/article/441&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>关于计算机的一些反直觉现象</title>
      <link>/post/jianshu/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%8E%B0%E8%B1%A1/</link>
      <pubDate>Sat, 23 Mar 2019 15:37:33 +0800</pubDate>
      
      <guid>/post/jianshu/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%8E%B0%E8%B1%A1/</guid>
      <description>

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;背景&lt;/p&gt;

&lt;p&gt;最近想写一些简单的非技术文章，希望能给其他行业的说明白计算机所能和所不能，方便大家用好计算机这个工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;为什么数据都有了-但是不让我查询和统计&#34;&gt;为什么数据都有了，但是不让我查询和统计？&lt;/h2&gt;

&lt;p&gt;思考：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果计算机记录了每个用户读了哪本书，那么是不是也很容易知道一本书被哪些用户读过？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你可能会觉得理所当然。&lt;/p&gt;

&lt;p&gt;但是，答案其实是 No。关键在于索引，什么是索引呢，举个例子：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果我要在字典里取找“李”这个字，常见的办法是在字典目录里先找“木”字头的所有字，假如找出100个，再到这些字里找到“李”。&lt;/p&gt;

&lt;p&gt;反过来，我能不能先找“子”为底的所有字，再从中找“李”呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;想法是好的，但现实是，没有哪本字典能提供这样的功能。&lt;/p&gt;

&lt;p&gt;之所以我们能先找“木”字头而不能先找“子”字底，是因为字典帮我们提供了一份“木”字头的目录而没有提供后者的目录。&lt;/p&gt;

&lt;p&gt;这个目录，在计算机里就称作“&lt;strong&gt;索引&lt;/strong&gt;”（&lt;strong&gt;Index&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;我们一般会说，字典为“木”字头建立了索引，但是没有为“子”字底建立索引。如果我们也为“子”建立一份索引，就可以反过来查到“李”字了。顺便，我们也可以在索引里面直接数出“子”字底的字有多少个。&lt;/p&gt;

&lt;p&gt;回到思考题，我们知道用户读过的书，但却不能统计一本书的阅读用户。你就大概猜到了，记录每个用户读了哪些书，潜台词就是我在“用户”维度建立了索引，但是却不一定也给“书”的维度建立了索引。&lt;/p&gt;

&lt;p&gt;再举个例子加深你的理解&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你在大街上随便问一个人读过哪些书，他可以很快答出来。&lt;/p&gt;

&lt;p&gt;但是，如果要问你大街上有哪些人读过某一本书，你可能就需要大费周折了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是因为，当一本书被一个人读了之后。虽然是“书”和“人”这两个主体发生了关联。但是，只有人的脑子里记录了这个关联，书店并不会记录这本书被某人读了。人脑记住的这份关联，就是索引。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go encoding json 的几个坑</title>
      <link>/post/jianshu/go-encoding-json-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91/</link>
      <pubDate>Mon, 27 Aug 2018 20:28:35 +0800</pubDate>
      
      <guid>/post/jianshu/go-encoding-json-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91/</guid>
      <description>

&lt;p&gt;以前在引入第三包的时候，为了兼容性和定制扩展的考虑，一般会浅浅地封装一层。自从入了 Go 坑，发现连标准库也得小心再小心了。&lt;/p&gt;

&lt;h2 id=&#34;decode-map-之后-int-会变成-float64&#34;&gt;decode(map) 之后 int 会变成 float64&lt;/h2&gt;

&lt;p&gt;思考一下，把一个 map encode 之后再 decode，结果和原来的 map 是否相等？直觉上肯定是对的，然而&amp;hellip;&lt;/p&gt;

&lt;p&gt;看一段代码（&lt;a href=&#34;https://play.golang.org/p/DHb-kZNHidd）：&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/DHb-kZNHidd）：&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;m := make(map[int]interface{})
m1 := make(map[int]interface{})

m[2] = 3

b, _ := json.Marshal(m)
json.Unmarshal(b, &amp;amp;m1)

fmt.Println(m)	// map[2:3]
fmt.Println(m1)	// map[2:3]
fmt.Println(reflect.DeepEqual(m, m1))	// false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来是不是很诡异，打印出来的都一模一样，然而两个却不相等。是不是 &lt;code&gt;DeepEqual&lt;/code&gt; 里藏着什么猫腻？按照&lt;a href=&#34;https://github.com/golang/go/blob/master/src/reflect/deepequal.go#L149&#34; target=&#34;_blank&#34;&gt;代码注释&lt;/a&gt;， 只要每个元素都相等，整个 map 就相等。&lt;/p&gt;

&lt;p&gt;难不成这个2和3有问题？我们再打印一下看看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Printf(&amp;quot;%T %T&amp;quot;, m[2], m1[2])
// int float64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候发现，decode 出来的数字被悄悄地变成了 float64。后来发现，其实官方也早有&lt;a href=&#34;https://golang.org/pkg/encoding/json/#Unmarshal&#34; target=&#34;_blank&#34;&gt;说明&lt;/a&gt;。只是这种不起眼的功能平时没注意。&lt;/p&gt;

&lt;p&gt;如果上面例子里改成 &lt;code&gt;m[2] = 3.0&lt;/code&gt;，结果就正常了。参见：&lt;a href=&#34;https://play.golang.org/p/vAC1BXc7nCO&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/vAC1BXc7nCO&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;encoding-时自动追加-n&#34;&gt;encoding 时自动追加 &amp;lsquo;\n&amp;rsquo;&lt;/h2&gt;

&lt;p&gt;跑 &lt;code&gt;Unit Testing&lt;/code&gt; 时遇到的。在 github 上看到有人问到过这个问题，官方给的理由是&lt;a href=&#34;https://github.com/golang/go/issues/7767&#34; target=&#34;_blank&#34;&gt;看起来舒服&lt;/a&gt;。不得不说，Go Team 在写 std 时真是太随意了。&lt;/p&gt;

&lt;p&gt;暂时没想到特别好的解决方案，在自己的工具类 &lt;a href=&#34;https://sourcegraph.com/github.com/Kretech/xgo/-/blob/encoding/json.go&#34; target=&#34;_blank&#34;&gt;JsonEncode&lt;/a&gt; 里手动给去掉了。因为一般使用的 json 末尾都是 &lt;code&gt;}&lt;/code&gt; &lt;code&gt;]&lt;/code&gt;。后面或许会加个全局的开关来配置？&lt;/p&gt;

&lt;h2 id=&#34;默认情况下会开启-escapehtml&#34;&gt;默认情况下会开启 &lt;code&gt;escapeHTML&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;严格来说不能算坑，但确实跟我之前的习惯不太一样。而且要关闭的时候，还不能直接设置，得绕个大弯：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;buffer := &amp;amp;bytes.Buffer{}
encoder := json.NewEncoder(buffer)
encoder.SetEscapeHTML(false)

// 到这才算 init 完成

encoder.Encode(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在很多人使用 Go 只是提供一个简单的 json 给客户端，html 字符，其实不太会搞出什么麻烦，有时候也就懒得处理了。&lt;/p&gt;

&lt;h2 id=&#34;不能处理递归指针-会死循环&#34;&gt;不能处理递归指针（会死循环）&lt;/h2&gt;

&lt;p&gt;如果对象的属性是指向自己的指针（例如循环列表），marshal 时会陷入死循环。在 dump 复杂对象时需要注意。&lt;/p&gt;

&lt;p&gt;println 函数没有这个问题，因为会把指针直接打印出地址。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;建议大家使用的自己也能稍微封装一下，至少在各种特殊场景下能自己掌控住。尤其 Go 很多官方包不像 Java 那样接口先行，而且 Go 还不支持继承，以至于在项目大了后想替换个 struct 非常痛苦。&lt;/p&gt;

&lt;p&gt;另外我自己也在尝试对这些问题&lt;a href=&#34;https://www.jianshu.com/p/10d556a4c60f&#34; target=&#34;_blank&#34;&gt;做一些整理&lt;/a&gt;，欢迎加入。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HttpClient 的几个点</title>
      <link>/post/jianshu/httpclient-%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9/</link>
      <pubDate>Sun, 26 Aug 2018 20:22:26 +0800</pubDate>
      
      <guid>/post/jianshu/httpclient-%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;迁移自简书，格式可能未经校对。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;越来越多的应用里需要依赖大量的对外请求（内部服务或第三方平台）。但是很多的 client 只有基本的请求，这在复杂的场景里根本无法应对各种问题，所以我试图整理一下之前遇到的坑，也是封装一个 httpClient 所需要支持的地方。&lt;/p&gt;

&lt;p&gt;重试策略：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;立即重试&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;延时重试&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;动态延时，1s 2s 4s 8s &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;频率限制&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;全局 Pool&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;针对同一服务下，排队&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;配置级别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;全局&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务级&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调用方&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务方&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Request&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;日志记什么：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;请求耗时&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请求信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;url = host + path&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;args = header + query + form&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请求结果&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;response header 一定得记&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果结果是简单数据，比如 json，就全记下&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果对方接口挂了，返回了 nginx 错误HTML，比如5xx，要记录&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果是文本文件流，可以记录关键部分；如果是二进制，至少记下 md5 + size&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TraceId（参考 &lt;a href=&#34;https://www.jianshu.com/p/73346f667f3d&#34; target=&#34;_blank&#34;&gt;https://www.jianshu.com/p/73346f667f3d&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>关于日志的几个想法</title>
      <link>/post/jianshu/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E5%87%A0%E4%B8%AA%E6%83%B3%E6%B3%95/</link>
      <pubDate>Sat, 25 Aug 2018 21:02:45 +0800</pubDate>
      
      <guid>/post/jianshu/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E5%87%A0%E4%B8%AA%E6%83%B3%E6%B3%95/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;迁移自简书，格式可能未经校对。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;场景还原&#34;&gt;场景还原&lt;/h2&gt;

&lt;p&gt;先说个场景：&lt;/p&gt;

&lt;p&gt;APP上某个操作出现了 &lt;code&gt;系统异常。错误码：abc012&lt;/code&gt;，我们收到错误码之后，可以一次性查出这条请求完整的请求路径，穿越了哪几个服务，出错的代码堆栈信息，甚至中间发生了哪些 SQL 查询。这样我们基本在脑子里复现整个场景了。&lt;/p&gt;

&lt;p&gt;其中涉及的几个地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;错误码：很多时候并不能得到这个错误截图，我们可以用户反馈的时间、用户ID、功能大致定位到。错误码放在全局的 &lt;code&gt;response header&lt;/code&gt; 里&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请求轨迹：在请求来的时候加个 traceId，这个 traceId 注入到后面的 logger 和 client，这样所有的log就都能识别了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;堆栈信息：像 Php Java 可以很方便的在出现 ERROR 时把堆栈信息跑出去（Php还能记录每个函数的调用参数）。我们用 Go 比较麻烦一些，要专门加个记录 stack 的 error 类型。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SQL日志：这个看需要了，如果你的 ORM 框架对钩子支持好，加起来也不是难事。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;日志框架&#34;&gt;日志框架&lt;/h2&gt;

&lt;p&gt;功能上，个人觉得有个强大的 Hook 就够了。这样每个团队都可以根据自己需要来加自己需要的东西&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Hook&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;继承 context&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;必要时候输出代码位置信息&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Keyword&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Extra Map&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;输出和存储&#34;&gt;输出和存储&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;格式：支持不同环境下不同的格式，比如dev模式，关键字就挺好。线上可能需要以json格式打到相关的日志服务里。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分卷存储：有的框架会按照日期来分文件，个人觉得没必要，可以用 logrotate 这样专业的工具来做。还有一种思路，用 rsyslog 把日志导出到你的日志服务里去，本机的日志，不用存多少就可以删掉了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;监控报警&#34;&gt;监控报警&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果性能没那么苛刻，推荐直接集成 Sentry&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果团队实力比较强，可以根据日志做各种分析和监控，参考 &lt;a href=&#34;http://open-falcon.com/&#34; target=&#34;_blank&#34;&gt;open-falcon&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tech.lede.com/2017/06/30/rd/server/loggingHabit/&#34; target=&#34;_blank&#34;&gt;优秀日志实践准则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>整理一套 Go 的轮子</title>
      <link>/post/jianshu/%E6%95%B4%E7%90%86%E4%B8%80%E5%A5%97-go-%E7%9A%84%E8%BD%AE%E5%AD%90/</link>
      <pubDate>Sat, 18 Aug 2018 01:26:15 +0800</pubDate>
      
      <guid>/post/jianshu/%E6%95%B4%E7%90%86%E4%B8%80%E5%A5%97-go-%E7%9A%84%E8%BD%AE%E5%AD%90/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;迁移自简书，格式可能未经校对。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Github：&lt;a href=&#34;https://github.com/Kretech/xgo&#34; target=&#34;_blank&#34;&gt;https://github.com/Kretech/xgo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;缘起是因为 Go 的很多语法太啰嗦，也许 Go 官方为了通用性牺牲了简洁，而我们日常更青睐于 &lt;code&gt;约定优于配置&lt;/code&gt;，所以我们需要对我们的80%情况做一些优化。&lt;/p&gt;

&lt;p&gt;整理了哪些东西：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常见的 utils 库&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;类似于随机数 &lt;code&gt;rand(100)&lt;/code&gt;、转下划线 &lt;code&gt;word.UnderlineCase(&#39;HelloWorld&#39;)&lt;/code&gt;等等
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;基础数据结构&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;科班都学过的链表、树、图以及这些数据结构上的基本算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;略复杂的数据结构&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Array&lt;/code&gt; + &lt;code&gt;Dict&lt;/code&gt; 类似于 &lt;code&gt;Php&lt;/code&gt; 里的 &lt;code&gt;array&lt;/code&gt;。在性能不那么要命的地方用起来很爽&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt; 基本数据结构：跳跃表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
