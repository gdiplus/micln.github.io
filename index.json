[{"authors":["admin"],"categories":null,"content":"最爱拼积木，买不起后就玩 Flash 和 3D Max 过眼瘾。动画太弱智，就开始学编程\n高中开始接触 Pascal/Cpp，用 Visual Basic 给家里写了个进销货的小软件，赶过用开源程序折腾网站的小尾巴。\n大学先修电子，焊过板子烧过灯泡，业余开始接触 web 开发，用 JavaScript 移植过编程小游戏和一些其它的小玩意，用 Php/Go 改造过学校的 Online Judge。\n工作后先以全栈工程师加入创业公司，见识了各种好玩的业务形态。目前逐步专注于后端架构，同时开始试水项目管理。\n一句话，从兴趣驱动逐步沦为职业小码农\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"最爱拼积木，买不起后就玩 Flash 和 3D Max 过眼瘾。动画太弱智，就开始学编程 高中开始接触 Pascal/Cpp，用 Visual Basic 给家里写了个进销货的小软件，赶过用开","tags":null,"title":"huiren","type":"author"},{"authors":null,"categories":[],"content":"组内分享，大纲见 https://mubu.com/doc/5rXXQikGmPT\n","date":1587615784,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1587615784,"objectID":"b0719cb3179e71f1c3547c646ec59e54","permalink":"/post/ast_in_go/","publishdate":"2020-04-23T12:23:04+08:00","relpermalink":"/post/ast_in_go/","section":"post","summary":"组内分享，大纲见 https://mubu.com/doc/5rXXQikGmPT","tags":["Go"],"title":"Ast in Golang","type":"post"},{"authors":null,"categories":[],"content":"[TOC]\n从哪学  官方教程，有中文，提供给交互式练习，注意网络环境 https://kubernetes.io/zh/docs/tutorials/  概念  Pod：一个抽象的应用实例，含义上约等于 docker 里 container 的一层 wrapper，但是因为有了这一层，可以把多个 container 包在一起，共享网络和 Volume 等资源。 Service：也就是我们一般所理解的应用服务，通过 label 把一组 Pod 组织起来。 Devlopment：（没有找到什么特别清晰的定义）简单理解为一个应用的控制器，一般情况下通过它来间接管理 Pod  kubectl 常用命令 应用管理 create -f app.yaml 发布应用\nkubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1  scale 扩容\nkubectl scale deployments/kubernetes-bootcamp --replicas=4  set image 更新命令\nkubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2  rollout 等待更新完成\nkubectl rollout status deployments/kubernetes-bootcamp  本地安装过程的坑  网络必须ok，不然各种没反应，因为不知道依赖了哪些站点，直接用全局模式 图形界面（Dashboard）  介绍 https://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/ 安装时需要配个帐号（原链接失效，我看的这里）：https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md    ","date":1583986054,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1583986054,"objectID":"d6e3214119bcd12b8e70cb5725e37a20","permalink":"/post/k8s_starter/","publishdate":"2020-03-12T12:07:34+08:00","relpermalink":"/post/k8s_starter/","section":"post","summary":"[TOC] 从哪学 官方教程，有中文，提供给交互式练习，注意网络环境 https://kubernetes.io/zh/docs/tutorials/ 概念 Pod：一个抽象的应用实例，含义上约等于 docker 里 container 的一层 wrapper，但是因为有","tags":["k8s","快速上手"],"title":"k8s 上手笔记","type":"post"},{"authors":null,"categories":[],"content":"放在幕布里了，有需要再解释：https://mubu.com/doc/2neaB-ofTo\n","date":1577968442,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1577968442,"objectID":"8da746d3f467e7695f396323396c8522","permalink":"/post/tools/","publishdate":"2020-01-02T20:34:02+08:00","relpermalink":"/post/tools/","section":"post","summary":"放在幕布里了，有需要再解释：https://mubu.com/doc/2neaB-ofTo","tags":[],"title":"码农的神兵利器","type":"post"},{"authors":null,"categories":["项目管理"],"content":" 大概从小开始就没有时间观念，毕竟穷人的时间不值钱。上学时经常通宵敲代码，除了兴趣外，也有时间管不好的原因：大不了拖到晚上搞。最后就一直成了习惯\n 工作后，这个坏习惯就成了大毛病了：我做的项目经常延期。即便是一些没延期的，也不乏快结束时加班突击才搞完的，前期的时间管理依然做的很差。\n在两家公司做过开发，都多多少少有这个问题。即便是小项目，有时反而会想着，反正不是啥大问题，那就多设计，写的漂亮一些，七搞八搞还是延。\n一直到今年一次以项目负责人的角色去推动一次技术改造。先要说明，这种技术改造项目比较特殊，它本身更侧重长期价值。所以业务方和公司层面没有给出明确的要求和时间点，对应的，管理层会优先保证能带来直接收益的项目，对这些项目也只提供有限的支持。\n如往常一样，当目前出现重大意外时，我就去找领导说明情况了。以前很多领导对都我比较照顾，兴许就宽限两天了，最多说我两句也就过去了。但不巧这次碰上个不好惹的领导，他了解情况后告诉我：你是项目负责人，你要自己去想办法，别出了问题让别人来给你擦屁股，实在不行你就延到下个版本吧。再好好总结总结，为什么提前没有管理好风险。\n被骂回来一脸无助，不知道接下来该怎么办，想想实在不行就延吧。在我准备给20+个开发同步这个信息时，我就犹豫了：我司一个版本固定为15天，即便项目只需延2天，最终还是得跟15天后的版本发布。我完全不知道该如何告知大家这个悲惨的事实。\n我说你们干吧，干完别上线，等我通知？还是说你们先干别的吧，十天后再回来跟我继续搞？十天后要是又有突发情况怎么办，继续延？简直是搞笑。而且这个项目本身周期就很长了，再拖下去，我自己都疲惫了。\n那天晚上想了很久（印象中很多人都走了，我还发呆到很晚），想了各种方案和可能、好的不好的结果，最后终于认识到了一件事：无论如何，我都必须按时交付。\n跟三位小组长沟通了我的想法后，得到了结论：\n 必须按时交付 整理手上的资源，按照剩余时间重新排期 按优先级排期，排不上的东西就坚决砍掉 排上的东西，按优先级、任务量，先做重要的，万一后面再有意外，不重要的也砍掉  其实这四点里，只有第一点是目标，按照项目管理金三角，自然会得到后面的手段。惭愧的是，在我以前经历的那么多项目里，从来没有把时间当做一个目标点来对待。\n这中间还做了很多具体的事情，比如最紧张的阶段，我们一天早晚两次例会，早上确定今天要做的事、相关的资源准备是否到位；下午“检查”今天的任务是否如期完成。出现任何问题，第一时间处理。确保跟计划没有偏差（这个地方还有个话题：你以为没有偏差真的就没有偏差嘛）。\n后来，在很多人都不相信的情况下（包括我自己），我们居然如期上线了。因为项目的特殊性，中间出现了好几次意外，每次都觉得自己扛不住了，发项目日报时用词都是“坚守XX号提测”，但幸运的是，最终还是在所有人的帮助下挺了过来。\n最后，综合项目的难度、复杂度和不确定性，整个项目得到的评价也很高。\n总结一下，最大的认识就是，把时间当做一个目标点来对待。以前提目标时只说“完成XXX”，之后必须要写 “XX前完成XXX”。\n只有真正把时间放在心里，才会有抵消延期的行动。\n","date":1571497867,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1571497867,"objectID":"6ed0bbd87da9fe1f41f065275067e2f8","permalink":"/post/overcome_procrastination/","publishdate":"2019-10-19T23:11:07+08:00","relpermalink":"/post/overcome_procrastination/","section":"post","summary":"大概从小开始就没有时间观念，毕竟穷人的时间不值钱。上学时经常通宵敲代码，除了兴趣外，也有时间管不好的原因：大不了拖到晚上搞。最后就一直成了习","tags":[],"title":"拯救拖延症","type":"post"},{"authors":null,"categories":[],"content":"之前遇到了很多 timeout，但是仔细看错误提示好像不完全一样，于是就做了个简单的试验：\nClient 上看到的错误 找不到服务器（no such host）的几种情况：\n# 域名不存在，瞄了下代码，应该是 dns 包返回的 Get http://a.b/abc: dial tcp: lookup a.b: no such host # ip 不合法不会直接检查，也会返回同样错误 Get http://127.0.0.1888:8080/abc: dial tcp: lookup 127.0.0.1888: no such host # 端口瞎填会直接报错，都不会发请求 Get http://127.0.0.1:65536/abc: dial tcp: address 65536: invalid port 拒绝连接，对方端口未监听、进程挂掉等等\nGet http://127.0.0.1:8080/abc: dial tcp 127.0.0.1:8080: connect: connection refused 建立连接超时\nGet http://127.0.0:8080/abc: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 等待返回 header， 一般是接口还在处理逻辑，没有返回任何数据；或者对方只是个普通的 tcp 服务，但不是 http\nGet http://127.0.0.1:8080/abc: net/http: request canceled (Client.Timeout exceeded while awaiting headers) 客户端读取超时：已建立好连接，已经开始返回数据，但是body 太大太慢：\nwait_test.go:48: net/http: request canceled (Client.Timeout exceeded while reading body) Server 上看到的错误 客户端主动断开连接，服务器端在调用 Write(p []byte) (n int, err error) 时会返回：\nwait_test.go:21: write tcp 127.0.0.1:8080-\u0026gt;127.0.0.1:49290: write: broken pipe 客户端主动断开连接，通常会直接使用 ctx.Done() 检测到，这个时候 ctx.Err() 里会拿到这个信息：\ncontext canceled 参考链接：\n https://colobu.com/2016/07/01/the-complete-guide-to-golang-net-http-timeouts/  ","date":1570176674,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1570176674,"objectID":"fee99d74e8b9d46c30d69930c7c19942","permalink":"/post/go_net_errors/","publishdate":"2019-10-04T16:11:14+08:00","relpermalink":"/post/go_net_errors/","section":"post","summary":"之前遇到了很多 timeout，但是仔细看错误提示好像不完全一样，于是就做了个简单的试验： Client 上看到的错误 找不到服务器（no such host）的几种情","tags":["Go"],"title":"Go 网络处理中的几种错误","type":"post"},{"authors":null,"categories":["项目管理"],"content":"先说下标题，所谓独立推项目跟之前的推项目（最多只能叫跟项目）区别在哪里。\n    跟项目 推项目     项目来源 主版本的大项目，分了一小块给我来跟 由我向上面发起   需求定义 PM 说啥就干啥，PM 说砍啥就砍啥 共同协商，我拍板   风险处理 报给大版本负责人 自己消化，消化不了就背延期的锅   资源排期 整体安排，各别协调 啥啥没有，自己想办法    最明显的区别是，凡事没有退路。心(pi)态(gu)变换导致很多做事方法完全不一样\n注：后面每个大标题都表示一块项目管理的工作内容，不分先后，重点写自己做的不好的，可以挑自己感兴趣的看。\n为了便于后面描述，这里简单介绍下这个项目，简单说，我们做的就是统一实体的唯一标识。\n比如用户的唯一标识是什么，至少我见过几种方式：user_id、id_card、phone、email等等。 不同系统存一个用户用的标识不一样，通信的时候非常麻烦，来回转换。\n然而，我们系统内的情况更复杂：\n 我们有10+种主要实体（课程、电子书、音视频等等） 每个实体要对接8+种通用服务（收藏、进度等等） 超过一半的实体都用了两种以上的标识（数字 ID、别名 alias、甚至还有人用课程关联的视频 ID 作为课程的 ID）  在我的理解里，N种实体，M 种抽象服务，如果抽象得当，那么对接成本应该是 N+M。但在这种实际情况下，对接成本可能到了 NM2.5。\n除了开发成本，带来的问题更加可怕。\n 用户反馈收藏的课程不见了，一查发现，收藏接口传的音频 ID，取收藏数据传的视频 ID，其实应该传课程 ID。 某节课程的所有用户留言都不见了，一查发现，留言系统用的“课程所关联的音频ID”作为课程ID ，然而这批课程换了一批音频，音频 ID 全变了。数据也自然都对不上了。你说赶紧洗数据吧，可是都不知道哪些音频改过  后来我实在受不了这些祖传屎山了，就找老板讨个规范。老板一听很高兴，把我跟几个端的 leader拉了个小群，提了一下这个问题，说统一业务模型很重要、隔离系统边界很重要。xxx 来负责，先把接口搞干净。\n于是就稀里糊涂地接了这个活，坦白说，这个事情技术难度只能算中等偏上，也就是一点点抽象能力。但它极大考验协调和项目管理能力。具体说，需要配合的人非常多，因为各个端都得改一通，在我司极少有项目需要牵扯这么多人和端。而且，我的职级也不高，要让这么多人因为我一句负面的吐槽就听我号令，实在是痴人说梦。\n光我说难不算，我也问过几个leader意见。客户端某端负责人说，你们这么折腾，就相当于把 App 重写一遍。一位架构师告诉我说，去年就想搞了，但是端上的阻力太大，就不了了之了。\n最后给我的感觉就是：大概率不成，全当一次历练吧。\n万幸中的万幸，经过一个多月的鏖战，总算是上线交付，得到的评价还不错。\n后面就来说说一些过程中遇到的问题\n最耗精力的工作内容：划清项目范围边界。 一般随版本走的的产品需求，在开工前80%的需求都是确定的，时间点也是固定的，资源也比较足，按部就班地做一般不会出问题。\n但是技术改造就很麻烦，名义上是一个独立项目，可以做完后单独发版，没有明确deadline。但实际上，每个人都会先做火烧眉毛的事情，没有 deadline说明还能放一放。而且老板那里肯定会有个心理预期的，不能一直拖。于是大家一起简单梳理了接口范围，定了个“一个月”。\n技术改造还有个问题，准确的成本要看到代码才知晓。我们也是真正开工的时候才发现，这个技术改造跟其他6个技术改造项目有关联，比如迁移新接口、迁移新路由、 服务化改造、部分系统重构等等。这些改造目前都算是“重要不紧急”，很多都是说要做，但是做了一半就放在那里了。一说这次要动那部分的代码，都想着能不能“顺手”把哪个改造也一起做了。\n如果拒绝有什么影响呢：\n 面上的，减少项目成果，降低项目意义和价值。像是做了个半吊子工程 部分代码要改，但改的不是最终版本，还要兼容，后面可能还要返工。这点会严重打击开发的积极性  如果接受，自然能避免这两个问题，但是会有其他问题\n 改动代码范围变多，质量风险会大大提高 项目范围膨胀，极有肯能严重延期或烂尾。 这两点都算是项目的命根子，如果发生这类问题，约等于成果为0，前功尽弃  为了在这些矛盾点做取舍，我们耗费了大量的精力去讨论、调整项目的边界。如果一件事情不做，项目意义是否会丢失，丢下的有什么补救措施，是否还需要二次开工。如果做了，对我们目标帮助到底有多大，会引入多少风险，需要多少资源开销。\n最开始的时候风险看起来不多，可以考虑多做一点，也很容易借此把大家团结到贼船上。到了中期，我们对整个项目的时间点已经有了比较清晰的预估，也提前协调好了测试资源和上线准备。但与此同时，整个项目有不断膨胀的趋势，我们几个主要负责人调整策略，一切以项目按时按质交付为第一目标。遇到任何带来风险的包袱，果断丢下。最终卡在边缘完成了交付。\n项目目标同步不到位 这个跟上面的相反，范围不清晰会引来项目膨胀，但目标不明确，会在开发过程中丢三落四。\n最广为熟知的案例莫过于造秋千。当工程师认为要做的只是在树上挂两根绳子时，整个项目已经在脱离目标和计划了。很多工程师最终得到的任务是给接口加两个字段，至于字段最后干嘛用，也不是特别清楚，更不用说加的对不对了。\n同样，我们耗费了很多精力去说明白我们到底要做什么，要向大家确认，做的事情跟目标是否一致。\n去年锁元老师带我们做了一个叫项目管理ABC的小游戏，我非常推荐刚开始接触项目管理的同学去玩两把。每次想到这个游戏和凄惨的结果，都觉得好像还有什么没跟大家交代清楚。\n规范型项目，项目的意义和愿景要深入人心 我以为有了目标，这事就算结了。直到我发现有一位同学，在参与这次技术改造时，很配合地把那些乱七八糟的接口都改成了约定的 ID，结果在新开的项目和接口里又用回了乱七八糟的标识。交流之后发现，在他理解上，只是以为我们要把那部分接口改一下，为什么要改，不关心。也不会意识到以后新的接口应该按规范的方式来。\n这件事情一开始我以为是规范没有确立导致的，加个明文规范：“强制必须使用业务主键来通信”。后来发现，这个规范其实跟没有一样，因为什么是“业务主键”完全是由开发自己说了算。\n在我的意识里，所谓的 MySQL范式可能是不言而喻的，但是对于很多人来说，根本分不清何为实体（entity），何为标识（Identity）和属性（property）。你得去跟他们讲明白，举例子，为什么这个字段是ID而那个字段不能是 ID。在别人看来，可能也只是你的一厢情愿。\n必须承认这里有个困局，一般项目宣讲会上，愿景、意义、目标普遍被认为是假大空，也是大家最不想听的，通常得到的反馈就是“你啰嗦了那么半天，我就想知道我具体要怎么做”。对于这一点，我自己也一直也没有什么好办法。目前唯一在尝试的，就是在过程中面对成员的困惑时，借机再用意义目标来引导。通常这个时候我讲的也更容易被接受。\n最惨的一个教训：拆分到具体可观测的小任务。 站会的时候，我们得到了开发同学的答复：某个接口已改完。后来发现，所谓“改完”。。\n这个问题以前就经常遇到，就连《人月神话》里也提过“已完成80%”的梗。但是直到自己的角色成了“项目负责人”，才真正开始思考怎样减少这类风险。\n代码未动，计划先行。 计划不一定是把准确的尺子，但一定是任何情况下的行动指南。\n最尴尬的问题：砍掉的范围，如何给后人交代 最没脾气的错误：对客户端的了解和发言权远少于后端 经常会面对这样一个场景，客户端告诉你这个太复杂，他那边不好处理。这个时候，即便你的意义愿景再牛逼，目标再清晰，这个时候也发挥不了什么用。\n我的一个经验是，主动走进客户端，了解他们的架构。通常情况下，你会发现他们说太复杂是按照要改5个模块算的，当你看了他们的架构后，可能只需要改2个模块就够了。这个过程中，也花了不少时间跟客户端同学在一块，人手把手地给我讲客户端的一些东西。就这次的案例来说，我觉得还是很值得的。\n你可能会问，这是否在质疑客户端的专业能力和架构能力。我觉得并没有，之所以能帮他们找到答案，并不是专业能力的差距，更多地是对项目目标的清晰认识和坚持，而他们，正因为对代码太熟了，更容易忘记自己当下的目的。举个不恰当的例子，我觉得我的器官缺一不可，结果一位盲人说，就算没有眼睛也可以活得不差。显然这位盲人并不是在说我眼睛没用。\n应对突发状况：灰度前2个小时发现新问题 可以有两分钟的情绪宣泄期，但作为“负责人”，一定要尽快冷静，召集相关的人，商量解决方案，做好接下来的安排。\n要顺势而为 开会叫多少人 最不好开口的：要资源 ","date":1569380909,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1569380909,"objectID":"429b11e4a7c084f1c204dd3db8fb703c","permalink":"/post/engineering/project_first/","publishdate":"2019-09-25T11:08:29+08:00","relpermalink":"/post/engineering/project_first/","section":"post","summary":"先说下标题，所谓独立推项目跟之前的推项目（最多只能叫跟项目）区别在哪里。 跟项目 推项目 项目来源 主版本的大项目，分了一小块给我来跟 由我向上面发起","tags":[],"title":"记一次“独立推项目”的心得体会","type":"post"},{"authors":null,"categories":["Kretech"],"content":"Go 让人吐槽的点之一就是动态特性低，比如不支持泛型、反射鸡肋等等。所以长期以来一直觉得搞一些动态功能是一件很酷的事情。\n这里主要做了两件事：\n 运行时获取变量名，并以此为基础做了一个调试工具 XGo/Dumper 运行时获取函数签名，以此为基础做了个小类库，可以将任意函数暴露为 http 接口，同时还支持生成 swagger 文档。  中间主要用到了 ast 包的工具（因为想偷懒，也踩了不少坑）。基本思路都是通过 runtime 或 reflect 包，得到一些基本的信息，比如 fileline 和 pc，然后借此再拿到 ast，通过一些上下文信息来定位相关部分的代码，转换为需要的东西。\n","date":1566578036,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1566578036,"objectID":"18f3bcdaf8e3843340ed6733147543e0","permalink":"/post/dynamic_in_go/","publishdate":"2019-08-24T00:33:56+08:00","relpermalink":"/post/dynamic_in_go/","section":"post","summary":"Go 让人吐槽的点之一就是动态特性低，比如不支持泛型、反射鸡肋等等。所以长期以来一直觉得搞一些动态功能是一件很酷的事情。 这里主要做了两件事： 运行","tags":["Go"],"title":"在 Go 里用 reflect 和 ast 实现动态特征","type":"post"},{"authors":null,"categories":[],"content":"先说说背景，为什么MacBook还在吃灰，又开始折腾Linux Desktop了\n 家里组了台PC，只打游戏太浪费，且实在搞不定windows写代码。 传闻 manjaro 优化的不错  于是同时把pc和数莓派都改了。\n烧U盘偶尔失败 表现为：烧录校验失败、无法启动\n按理以前从不会遇到，重新烧几次就好了，可能是u盘年久失修了。\n加速源 这个地方坑了半天，一直以为manjaro就是arch的源，后来经 zsrkmyn大佬 鄙视，才知道是不一样的。。\n所以 manjaro要做两件事，一是加速manjaro源，二是引进archlinux源，后者用来加一部分arch社区的软件。\n参考：\n# 换中国源 $ cat /etc/pacman.d/mirrorlist ### Country : China Server = https://mirrors.ustc.edu.cn/manjaro/stable/$repo/$arch # 加 archlinux $ tail /etc/pacman.conf [archlinuxcn] SigLevel = Optional TrustedOnly Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 还有个深坑，数莓派用的源的地址不能只把 manjaro 改成 manjaro-arm，后面的 $repo 和 $arch 顺序也不一样。 而且很多镜像源只提供 manjaro 不提供 marjaro-arm。\n最开始没仔细看，坑了好久。。\n无线网卡驱动 刚装机的时候没有网络，我用的老旧android手机连wifi，插到电脑上，允许usb上网。电脑会识别成以太网（win/mac也支持），网速还是挺快的，除了累赘，体验比无线网卡还好。\n我用的华硕USB-AC57，官网有驱动，下下来不能用。看下文件名，一般是 rtlXXX-linux-driver，这个rtlxxx就是型号，直接去网上搜关键词。arch aur 里就有社区版本，按步骤编译安装就好使了。\nTODO 开机联网慢，还没处理\nTODO 最近网络不稳，猜测也是这个驱动问题\n尽量还是走有线吧。\n输入法 默认安装好 fcitx 后，状态栏也有了，但是不能切换。原因是并没有在x环境下启用，我的处理办法是在 xinitrc 里加了几行配置。\n参考：\ntail ~/.xinitrc export XMODIFIERS=\u0026#34;@im=fcitx\u0026#34; export GTK_IM_MODULE=xim export QT_IM_MODULE=xim exec $(get_session) # 这行原来就有，不要动。在上面加三个export就行。 另外，fcitx-qt4 会和 fcitx-gtk* 冲突，我用的后者。前者貌似才能支持搜狗。\n网络 装机需要配个pac，不然很多东西下不动。\n最好是在路由器里支持。\nmanjaro里的话，好像只能针对每个网络单独配置。\n数莓派同时安装了酸酸乳和奶牛作为统一的入口，macbook顺利通过，但manjaro走奶牛PAC一直走不通，后来莫名其妙好了。。\n用户目录改英文 网上搜了一堆教程都需要 xdg-user-dirs-gtk-update，但默认只有 xdg-user-dirs-update，擅自用了后者发现不好使，要装一下前者：sudo pacman -S xdg-user-dirs-gtk\n","date":1565453088,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1565453088,"objectID":"b7ac54782f337f6ee0152f18f1d5bd87","permalink":"/post/manjaro_go/","publishdate":"2019-08-11T00:04:48+08:00","relpermalink":"/post/manjaro_go/","section":"post","summary":"先说说背景，为什么MacBook还在吃灰，又开始折腾Linux Desktop了 家里组了台PC，只打游戏太浪费，且实在搞不定windows写代","tags":["Linux","Manjaro"],"title":"Manjaro 踩坑记录","type":"post"},{"authors":null,"categories":["最佳实践"],"content":"今年接手了一个新项目，不算vendor包，大概6W行代码，接的时候信心满满准备大干一场。结果半年内线上出了100多个bug。\n粗糙统计下，80%的代码是原来直接留下的，剩下的基本都是一脸懵逼地踩坑。其中也有不少是之前都知道，但是没处理掉，甚至还有查不到原因最后不了了之的。\n流程与业务规则隔离 其实在上一家公司工作时就已经意识到这个问题的严重性，尤其是业务流程和业务规则经常来回改。\n业务流程通常是一段简单的过程，甚至都不包含太多的分支流程。\n业务规则是指针对不同的数据，在各个环节里需要不同的处理。\n最常见的处理方式就是无处不在的 ifelse，这种方式的问题在于，每次改规则都要从头改一大堆代码，改完了还可能会影响其它 case，要整体回归才可以。效率和稳定性都很差。\n更好的办法是，在主流程上使用 interface 把业务流串下来，每种 case 各自实现接口，各自测试。\n有个小地方要注意，在设计这个 interface 时，要注意接口隔离原则，否则可能会出现为了增加一个特殊的 case，导致其它实现也跟着改一通。\n日志那么多，有多少能帮助你还原现场 每打一行日志，都想想什么时候用，怎么用。\n横向耦合、纵向耦合如果同时出现，代码就废了 一脚一个雷。\n该收的口子一定要收口 一段代码同时copy在多个流程里，维护起来丢三落四。\n丑陋的封装优于复制粘贴。\n聚合服务，千万不要关心别人的细节 尤其是多个依赖的细节还不一样，真是灾难\n双写幂等性，可修复性 不要第一次双写失败，导致后面数据都对不上。\n出现不一致，一定要第一时间报警\n避免阻塞性依赖 阻塞性依赖在流程管理中挺常见的，通常表现为在一系列操作中有几个操作依赖于不稳定的第三方。当中间一个环节出现不可控的故障时，会导致你的整个流程走不下去，然而因为是第三方出了问题，你只能干等着。\n如果同时你的接口不具有全局的幂等性，这个问题还会造成非常恶心的数据不一致，处理起来也非常麻烦。\n一个设计上的优化是把依赖第三方的环节后置。举个例子：\nBBS 里用户发的消息要经过敏感词检查才能放出来，但如果你的敏感词接口挂了，可能导致全站不能发帖。一个可行的办法是，先发帖成功，再异步调用敏感词接口。有个问题是，在敏感词接口返回结果或恢复正常前的这段时间，贴子展示出来是否有风险？这个可以依据业务场景来处理，平时可以默认先放出来，敏感时期，那就让这个帖子只有自己可见，其它人等审核完成后才能看到。\n成本会稍微高一些，但是系统健壮性会好很多。\n字段命名一致性 数据结构上，不建议一个字段在不同场景下表示不同含义 大概出于省空间的目的，一个字段在不同 case 下表示了完全不一样的含义，时间长了。大家都懵逼了。\n依赖服务的返回值，日志一定要清晰 善意的质疑，降低撕逼风险，这大概叫职业。\n处理err时，一定要想想：如果这个error出来了，如何主动让我发现 api 错误后，如何快速定位哪一层抛的错\n任何有业务含义的字段不能用来做pk 一改就疯\n数据修改记录的重要性 最严重的有一张表没有创建和修改的时间戳，查数据问题时，都不知道从哪里开始查。\n","date":1564381171,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1564381171,"objectID":"3101941da25de25fb42e0f0daed37b73","permalink":"/post/code_after_100_bugs/","publishdate":"2019-07-29T14:19:31+08:00","relpermalink":"/post/code_after_100_bugs/","section":"post","summary":"今年接手了一个新项目，不算vendor包，大概6W行代码，接的时候信心满满准备大干一场。结果半年内线上出了100多个bug。 粗糙统计下，80","tags":["Go"],"title":"Coding After 100+ Bugs","type":"post"},{"authors":null,"categories":["最佳实践"],"content":"最开始的项目目录\n$ tree . ├── ./api/ ├── ./service/ ├── ./dao/ ├── ./model/ ├── main.go func main(){ flag.Parse() artemis := NewArtemis(flag.String(`config`))\t// artemis 是我们的框架，类似beego \tlog.init() service.init() dao.init() worker.init() api.Route(artemis.Router) artemis.Run() } 写个测试吧\npackege dao func TestGetNote(t *testing.T){ db := NewNoteDB()\t// panic: app not init \tdb.Get(1) } 改：\n copy启动代码 把config路径改一下 去除不需要的部分，比如在 dao 里去掉 service.init()  func TestGetNote(t *testing.T){ artemis := NewArtemis(`../../config`) log.init() ddns.init() service.init() dao.init() // test code } // 也可以放在 TestMain 里统一处理 func TestMain(m *testing.M){ // init()  m.Run() }  简单粗暴的解决办法，调试也够用了。\n如果 package 比较少，也没那么多脚本要用，已经能满足需要了\n 但当时我觉得还是不完美，我的项目又比较复杂，然后继续尝试优化：\n先\u0008抽出个函数放重复代码\npackage boot func Boot(){ // init() } func BootTest(){ SetRootPath()\t// 在子目录跑ut时，要把 wd 对齐到项目目录 \tBoot() } package main func main(){ boot.Boot() artemis.Run() } package dao func test(){ boot.BootTest() // test code } $ go build import cycle not allowed # dao 和 boot 互相依赖 改成外部测试\npackage dao_test import \u0026#34;dao\u0026#34; func test(){ db := dao.NewDB() } 缺点：\n ugly 不能测私有函数 每次改动几乎重新编译整个项目  最后一点很重要，测试代码时会频繁修改，而每次修改几乎都要重新编译整个项目。 我的项目在忽略缓存的情况下，编译需要30s 调个bug，一下午就过去了。。\n回头一看整个过程，总结就是\n　民科 于是，放下一切，重新开始\n我想要什么？\n 不用太多重复代码，好维护 需要时再加载，不需要在测试时搞一堆没用的东西  看看成熟的框架是如何处理的，以我熟悉的 Laravel 为例，很多地方都采用了这样的思路：先注册，后使用\nclass FooServiceProvider { function register($app) { $app-\u0026gt;singleton(\u0026#34;noteDB\u0026#34;, function(){ $noteDB = new NoteDB(); }) $app-\u0026gt;sinleton(IRouter::class, new Router()) } function boot() { make(IRouter::class)-\u0026gt;load(); } } 突然发现，Go的init就是天然的注册机制\n 所有的init都一定会在main之前执行 依赖包的init一定先于本包的init，连优先级都帮我做好了  于是大概轮廓就出来了：\n 在每个 init 里定义自己需要启动什么，代码里依赖了哪个包，就会调用对应的init，不依赖的不会启动 运行cmd（webserver/script/test）时，再逐个执行init时注册的任务  package dao func init(){ boot.Register(func(){ // ... \t}) } // web server func main(){ boot.Boot() defer boot.Shutdown() api.Route(artemis.App) artemis.Run() } // script func main(){ boot.Boot() // ... } // test func TestMain(m *testing.M){ boot.Register(factories.Init) boottest.Boot() defer boottest.Shutdown() m.Run() // ... } 到此，基本上达成了写脚本、写单测时不用操心框架启动的问题。\n不过限于框架限制，依然有一些不爽的地方没有解决。\n Go很多人摒弃了面向接口编程，导致在写UT时无从mock。后面想办法靠工具对所有的类走一次DI容器 测试的问题，限于框架限制，不能全局开始事务  ","date":1562037076,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1562037076,"objectID":"7f1e84edcc3f8c718bf4b5118db750a1","permalink":"/post/boot_test_in_go/","publishdate":"2019-07-02T11:11:16+08:00","relpermalink":"/post/boot_test_in_go/","section":"post","summary":"最开始的项目目录 $ tree . ├── ./api/ ├── ./service/ ├── ./dao/ ├── ./model/ ├── main.go func main(){ flag.Parse() artemis := NewArtemis(flag.String(`config`)) // artemis 是我们的框架，类似beego log.init() service.init() dao.init() worker.init() api.Route(artemis.Router) artemis.Run() } 写个测试吧 packege dao func TestGetNote(t *testing.T){","tags":["Go"],"title":"Go项目在组织启动代码上的一次尝试","type":"post"},{"authors":null,"categories":["最佳实践"],"content":"原以为浮点数是计算机编程的基础知识，后来发现个奇怪的现象：很多人都说浮点很坑，千万不要用，至于为什么却说不出个所以然。更有甚者，以专业民科的架势发明出一套处理浮点的办法，应该如何如何，不该如何如何。网上也看到不少人对这个现象很困惑，解释为湿猴理论。\n通常你问别人浮点有什么坑，如果别人说浮点数不能用==，十有八九这个人会认为，浮点数可以用\u0026gt;\u0026lt;的。不过你继续追问，他可能就会犹豫了。\n看代码：\na := 0.1 b := 0.2 c := 0.3 fmt.Printf(\u0026#34;%10s =\u0026gt; %v\\n\u0026#34;, \u0026#34;a+b\u0026#34;, a+b) fmt.Printf(\u0026#34;%10s =\u0026gt; %v\\n\u0026#34;, \u0026#34;a+b == c\u0026#34;, a+b == c) fmt.Printf(\u0026#34;%10s =\u0026gt; %v\\n\u0026#34;, \u0026#34;a+b \u0026lt; c\u0026#34;, a+b \u0026lt; c) fmt.Printf(\u0026#34;%10s =\u0026gt; %v\\n\u0026#34;, \u0026#34;a+b \u0026gt; c\u0026#34;, a+b \u0026gt; c) https://play.golang.org/p/QdoleMRyJr3\nwhy？\n  按照浮点标准，0.1 转化成二进制是个无限小数\n  浮点数有效长度有限，必有取舍\n  总结，二进制无法准确表达0.1，多多少少会有点失真。遂不能直接比较大小。\n更详细的论述：https://www.zhihu.com/question/28551135\n浮点数如何比较？ 通常做法，如果两个数的差值在可接受范围内，就认为是相等的。其实很多非精确的比较都是类似方法，比如\n1、两个人年龄、五官等等主要特征都很像，你就敢猜这俩人是双胞胎了。 2、你的服务10:03开始大量报错，隔壁服务10:02上了个线，你猜大概就是他的锅。\nvar floatPrecision = 1e-6 func floatEqual(a float64, b float64) bool { return math.Abs(a-b) \u0026lt; floatPrecision } func floatLess(a float64, b float64) bool { return b-a \u0026gt; floatPrecision } func floatGreater(a float64, b float64) bool { return a-b \u0026gt; floatPrecision } func main(){ fmt.Println(floatEqual(a+b, c))\t// true } 浮点数怎么转换 跟整型转换比较简单\n// 去尾 func floatFloor(a float64) int { return int(a) } // 四舍五入 func floatToInt(a float64) int { return int(math.Round(a)) //return int(a + 0.5) } 跟浮点转换就有意思了\n// 打印浮点数 func testFloatToString(){\tf := 16.99 fmt.Println(f * 10) fmt.Println(f * 100) fmt.Println(f * 1000) fmt.Println(f * 10000) fmt.Printf(\u0026#34;%.2f\\n\u0026#34;, f*10000) fmt.Printf(\u0026#34;%.0f\\n\u0026#34;, f*10000) } 169.89999999999998 1698.9999999999998 16990 169899.99999999997 169900.00 169900 strconv\n https://gowalker.org/strconv#FormatFloat https://gowalker.org/strconv#ParseFloat  浮点数要不要用字符串传输？ 有人问，如果别人想传1，结果传了个0.99999，不就失真了吗？\n基本上这样问的都是因为用的时候直接用了比较操作符。\n 原来的 double 有 15 位有效数字，一般转成 string 后只刻意保留了几位，如果是直接截取，其实是主动丢弃了准确度。\n举例：本来要传 1，截取之后传了 0.999 ，别人并不不知道这个 0.999 是准确值还是你截出来的。\n 个人推荐，传输的时候保留原数据，只有在渲染的时候再做格式化处理。\n问题核心：怎么存不重要，怎么用才是关键。想着存的时候干净一点，用的时候就随意了。\n财务场景下的特殊处理 仔细想了想，好像财务上也没什么特别要处理的，怀疑自己知识面不够，就去网上翻了翻，虽然没看到什么新问题，却又不少其他的收获。比如\n 系统性误差有系统性解决办法\n 我对这句话的理解，不要把计算机看得太重了，计算机只是解决领域问题的一个工具，准确的说只是特定时期的计算工具，专业的领域在手工计算的时代就有专业的算法了。\n这里只提一个最开始想到的跟普通场景的区别：不能简单的四舍五入\n先抛开小数不谈，现实生活中，3个人平分10块钱，理论上一人3.33，实际上大家会按照3-3-4来分就够了。放到微信群收款里，也是3.33*2+3.34。并没有统一用四舍五入。\n这种问题在实际问题中出现也比较多，把一笔订单拆分成几笔子订单，把一笔成本摊销到一年。在做除法的时候都要根据具体场景来做取舍。其实都不算什么浮点问题。\n扩展  能否直接用高精度 math/big.Float 来解决浮点数的诡异问题？https://play.golang.org/p/-8C7Gg7uHxd wiki https://zh.wikipedia.org/wiki/IEEE_754  ","date":1561385575,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1561385575,"objectID":"23b9393d8aa77a6c74bdd520cccba5b0","permalink":"/post/float_kidding/","publishdate":"2019-06-24T22:12:55+08:00","relpermalink":"/post/float_kidding/","section":"post","summary":"原以为浮点数是计算机编程的基础知识，后来发现个奇怪的现象：很多人都说浮点很坑，千万不要用，至于为什么却说不出个所以然。更有甚者，以专业民科的","tags":["float"],"title":"当我们在说浮点数精度不准的时候，到底在说什么","type":"post"},{"authors":null,"categories":["最佳实践"],"content":"原文地址：https://romatic.net/post/avoid_npe_in_go/\n空指针异常 NPE 在所有编程语言里都是个很麻烦的事情，Go 在设计之初已经在尽力减少 null 的使用范围。但是由于 Go 刻意隐藏了值和引用的概念，很多新手在编码时容易搞混空引用和空值，引发了不少 panic。\n这里试图提供一些减少 NPE 的方法出来。经验之谈，供参考。\n 先来看一种最常见的情形\n定义嵌套结构体时，尽可能不嵌套指针 比较容易理解\ntype Male struct{ Human } 组合时优先用 Human 而不是 *Human。\n有人会顾虑，那我想用 *Human 的方法怎么办，其实，*Male 其实是包含 *Human 的方法的。\n这样做最主要的原因，也是很多人在 new(Male) 时忘记 new(Human)，导致给上层抛了个 nil。如果这个 struct 直接转成 json 抛了出去，下游恰好对 null 也没处理好，这就是个跨端 bug 了。\n帮同事查问题时还遇到过更隐藏的坑，这个 Human 里可能还有个结构体指针假如是 *Face，代码从 Male 直接调 *Face 的方法，自然就 panic 了。悲催的是，在 IDE 里帮他调代码，会直接跳过 Human 这一层，在阅读代码时没有直接找到问题所在，不得不搬出 DEBUG 才看到。\n这个也可以衍生一个小建议，定义变量尽量用 struct 而不是指针，传参的时候再使用。不过到底有多少收益，还值得商榷。\n函数尽可能不返回 nil 看一个连环坑\n// 获取 user 对象 func GetUser() (*User, error) func main() { user,err := GetUser() if err != nil { write(err.Error()) return } println(user.Name)\t// panic user=nil } 一般的，我们会觉得既然我都判 error 了，user 的值总该是正常了吧。只能说 too naive，真正垃圾的代码是没有底线的。反应快的人可能马上想到解决办法，在 err != nil 的地方也判一下 user：\nif err != nil || user == nil { write(err.Error()) } 然后，就悲催的发现还是 panic 了。因为当 user=nil \u0026amp;\u0026amp; err==nil 时，也会走到 err.Error() 这里，这里的 err.xx 又是一个 NPE！\n老老实实的一个个处理固然是好办法，但是难保谁一个手抖。\n所以我们换个思路，想想能不能对 GetUser 这个函数做一些要求。问题就变成了有什么简单的办法让函数不返回 nil。\n不说中间的尝试了，直接说我们的结论：\n 函数返回值可能返回 nil 时，定义返回值必须 带上变量名，并且在函数体内 首行进行初始化。函数返回时 不带变量名\n 给个例子：\nfunc GetUsers() (users []*User, err error) { users = make([]*User, 0, 32) // function body \treturn } 三个条件\n 必须有变量名 必须首行初始化 return 无参数  这三点共同保证第一个目的：函数在任何地方 return，都不会给上层抛出 nil\n具体解释一下，为什么 变量名放在函数签名里而不在 return 里。是因为当函数很复杂需要多个 return 时，每个 return 时 users 里是啥你心里不一定有概念。也顾不上去考虑。索性把这个任务就交给定义阶段了。\n另外，返回值在函数开头就一起定义\u0026amp;初始化了。在 code review 时也更容易注意到。在看函数体的时候也不用再去想这个问题了。\n 调用函数时尽可能不传 nil 在 Go 里有个很普遍的情况，函数的最后一个入参其实表示的是函数返回值。看例子：\nfunc getUserArticles(userId int, articles map[int]Article) { articles[1] = \u0026amp;Article{}\t// panic: articles 未初始化 } 好说，那我 new 一个吧。一般没问题。\n但是如果 articles 里已经有一部分数据了，这里只是需要你 append 呢？更常见的，articels 是个结构体指针，里面有一些字段是需要的，你不能给删咯。\n还有，如果这个参数传了好多层，鬼还记得他里面到底是啥。\n针对这种 case，我们也做了一些简单的约定：\n 谁定义，谁初始化\n 参照这个例子来说，\n 如果函数为 func() articles，那我来初始化，保证不返回 nil，如果保证呢？参照上面那条规范。 如果函数为 func(articles)，那调用方来初始化，保证不传 nil  两个简单的约束，保证绝大多数参数简单稳定地运行。\n 下班时突然心血来潮想整理一下，休息一下。未完待续。。\n欢迎讨论。\n","date":1558015104,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1558015104,"objectID":"7baba1c21fc791d040959ffc2f6c4405","permalink":"/post/avoid_npe_in_go/","publishdate":"2019-05-16T21:58:24+08:00","relpermalink":"/post/avoid_npe_in_go/","section":"post","summary":"原文地址：https://romatic.net/post/avoid_npe_in_go/ 空指针异常 NPE 在所有编程语言里都是个很麻烦的事情，","tags":["NPE","Go"],"title":"Go 里减少空指针异常的小经验","type":"post"},{"authors":null,"categories":[],"content":"缘起 写代码里有个绕不开的话题就是如何写构造函数\n Java 里有 JavaBean 作为标准，空构造参数 + 自定义的 setter C++ 里靠重载实现任意场景的构造 Python 里可以可以支持传你需要的参数  Go 呢，一无所有，最通行的办法，大概是可变参作为可选的 options\nfunc NewX(options ...Option) *X { x := \u0026amp;X{} for _, opt := range options { opt.apply(x) } return x } 但是，你每次不得不把一个个简单的参数定义成一大堆的 option，多么烦人。\n所以，goption 就出场了\n一睹为快 是不是太快了看不清。听我慢慢道来。\n以 Goland 为示例，首先在定义 struct 时添加标识\n//go:generate goption -p . -c Person -w type Person struct{ // your person fields } 这样的好处是，IDE 可以为你提供快捷按钮，你只需要点一下就生成了。\n点击按钮后，会在同 packagge 下生成 person_option_gen.go 代码大约是这个样子：\ntype PersonOption func(*Person) func NewPerson(opts ...PersonOption) (person *Person) { person = \u0026amp;Person{} for _, opt := range opts { opt(person) } return } func WithPersonName(name string) func(*Person) { return func(person *Person) { person.Name = name } } // ... 如何使用呢，也很简单：\nfunc main() { p1 := NewPerson()\t// 普通构造方式  p2 := NewPerson(\t// 自定义字段方式 \tWithPersonName(`zhangsan`), WithPersonAge(18), ) println(p1, p2) } 使用起来真是爽了不少。\n放上代码地址：https://github.com/micln/goption\n如何实现 最开始绕了点弯路，自己一层层解析 ast.Node，后来发现 go/doc 已经帮你解析了 package，里面有哪些 Types，哪些 Funcs，都非常清楚，可以直接拿来用。\n唯一需要处理的就是如何 ast.Expr 表示的代码展示出来，好在之前玩过 ast 相关的，也整理了一下 astutil 放了出来，后面还会继续完善。所以就大大减少了难度。\n后续 费这么大劲如果只做这一件事确实有点亏，后续希望把 Generator 开放出来，我帮你解析源码和集成 IDE，你只需要自定义模板，就可以生成任何你想要的辅助方法。\n","date":1557767371,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557767371,"objectID":"df21a8ddac8d6525a06153bab788100f","permalink":"/post/goption/","publishdate":"2019-05-14T01:09:31+08:00","relpermalink":"/post/goption/","section":"post","summary":"缘起 写代码里有个绕不开的话题就是如何写构造函数 Java 里有 JavaBean 作为标准，空构造参数 + 自定义的 setter C++ 里靠重载实现任意场景的构造 Python 里可以可以支持传你需要的","tags":["Go"],"title":"Goption：一个针对 Go struct 的代码生成器","type":"post"},{"authors":null,"categories":[],"content":"起因是因为犯懒，随手在一个函数体内定义一个类型\nfunc foo() { type Article = map[string]interface{} } 看起来好像也很正常，突然有一天在 gowatch 的控制台里看到了\nruntime: goroutine stack exceeds 1000000000-byte limit fatal error: stack overflow runtime stack: runtime.throw(0x1a556a1, 0xe) /usr/local/Cellar/go/1.12.5/libexec/src/runtime/panic.go:617 +0x72 runtime.newstack() /usr/local/Cellar/go/1.12.5/libexec/src/runtime/stack.go:1041 +0x6f0 runtime.morestack() /usr/local/Cellar/go/1.12.5/libexec/src/runtime/asm_amd64.s:429 +0x8f ... 以为是程序出 panic 了，不过仔细看了看，好像不是我的代码，仔细一研究，发现程序还没跑起来，go build 时已经 panic 了。然后经过各种 git stash，终于发现，原来是因为外面也定义了一个 type Article struct{} 导致的 panic。\n印象中函数体内和函数外是可以重名的，而且，即便不可以，也应该编译失败才对，怎么就 panic 了。\n于是尝试了一下\n如果同时定义两个重名类型，会提示 redeclared in this block\ntype A struct{} type A = map[string]string // A redeclared in this block 如果分开到两个 block，就编译通过了。\ntype A struct{} func main(){ type A = map[string]string } // build success 奇了个怪。那为什么我的程序会 panic 呢？\n又经过尝试，终于发现，在本包内正常调用是可以的，只有当其他包引用此包时才会 panic。而且，如果把函数体内的 type X = Y 改成 type X Y 也是可以编译通过的。\n总结起来，两个条件：\n 在两个 block 内同时定义 type X 和 type X= 在其他包里引入此包  之后，给 goteam 提了个 issue 来反馈这个诡异的 bug。\n忧伤的地方来了，自己只能发现 bug，完全不具备追查 bug 产生的原因。\n立个 flag 吧，希望有时间可以研究研究编译器相关的一些知识。\n","date":1557765338,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557765338,"objectID":"a65b3c4e30de8941c9d7c25b3e982974","permalink":"/post/a_go_build_panic_bug/","publishdate":"2019-05-14T00:35:38+08:00","relpermalink":"/post/a_go_build_panic_bug/","section":"post","summary":"起因是因为犯懒，随手在一个函数体内定义一个类型 func foo() { type Article = map[string]interface{} } 看起来好像也很正常，突然有一天在 gowatch 的控制台里看到了 runtime: goroutine stack exceeds 1000000000-byte limit fatal error: stack overflow runtime stack: runtime.throw(0x1a556a1, 0xe)","tags":["Go"],"title":"一个会导致 go build panic 的 bug","type":"post"},{"authors":null,"categories":["最佳实践"],"content":" 项目逐渐都切到了 go mod，用的时候遇到了各种奇奇怪怪的坑，记录一下。\n 流程实践 语义化版本 Go mod 在设计时没有支持诸如 \u0026gt;2.0, ~3.4, ^4.0 这样场景的语法。而是以语义化版本的约定来处理：\nx.y.z ≈ ^x.y + \u0026lt;=y.z\n实际中，对于内部频繁升级的 common 包，每次改动都需要 y+=1 才能保证兼容性。为此我专门搞了个小玩意来升级 y，可以通过 hook 在 push 前先 gt ft。\n有个比较恶心的问题，common 包的版本号长期维持在 1.y.0 且 y 很大。暂时没用解决的办法，后面再看看 x 能有什么新玩法。\n不同分支依赖冲突 如图，一个常见的场景，多人开发项目时，有可能在开发过程中使用了不同的依赖包，在合并代码的时候也会冲突。\n以前的办法是有个专门的 vendor 分支，把有关依赖的变动串行化。\n但是用了 gomod 后，如果你只在 vendor 分支 里加了依赖没有用，go mod tidy 时又会把依赖给去掉。\n好在大部分时候都是需要更新而不是新增依赖，这个思路依然可用。我们给项目里专门准备了一个脚本来升级依赖，这个脚本做的事情也比较简单，切换到 vendor 分支，更新，提交。再合回 feature 分支。\n异常问题处理 go replace 替换大小写时不支持同时依赖大小写 P-\u0026gt;A P-\u0026gt;xx-\u0026gt;a\n天真以为把 A replace a 就好了。还是会报同时用了大小写的错。\n只有当所有依赖都依赖 A，但是 github 已经改成 a 时，才能 replace。\n问题最初是由于 github.com/sirupsen/logrus 更换大小写引起，如果项目全用 Sirupsen 是可以 replace 的，后来有了混用就不行了。终极解决办法是干掉 logrus 。。\n 凡是随意修改包路径、函数签名的 Go Libs，基本上都被我列入黑名单了。\n build xx: ambiguous import: xx in multiple modules: 通常是在没有使用语义化版本时，对一个包有不同版本的依赖导致。例如：\nbuild xxx.com/com/projA: cannot load xxx.com/com/projB/model: ambiguous import: found xxx.com/com/projB/model in multiple modules: xxx.com/com/projB v0.0.0-20181119101949-92ae1f75b49a (.../pkg/mod/xxx.com/com/projB@v0.0.0-20181119101949-92ae1f75b49a/model) xxx.com/com/projB/model v0.0.0-20190311082816-bfb94e79a84f (.../pkg/mod/xxx.com/com/projB/model@v0.0.0-20190311082816-bfb94e79a84f) 可以通过下面方式来找\nfd go.mod | xargs grep -r projB vendor/xxx.com/com/base/go.mod:\txxx.com/com/projB/registry v0.0.0-20190312132550-a101ae8810b6 // indirect vendor/xxx.com/com/artemis/go.mod:\txxx.com/com/projB/app/goprojB v0.0.0-20190312132550-a101ae8810b6 vendor/xxx.com/com/projB/registry/go.mod:module xxx.com/com/projB/registry go replace 不能替换依赖包的依赖 我的项目P -\u0026gt; A\u0026amp;B，且 B-\u0026gt;A\n如果把 A replace 成 A‘，只能修改 P-\u0026gt;A 的依赖， B-\u0026gt;A 是改不了的。\n所以 replace 不能解决梯子的问题，要用 goproxy\ngo get: error loading module requirements go clean -modcache  清理 modcache 几乎是各种问题的终极大杀器，但是成本也很高，需要你下次重拉所有 mod。如果公司内有 proxy 做 cache 的话会好一些。\n","date":1555212027,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1555212027,"objectID":"21d372529fb9c0ff684ebc8680679fef","permalink":"/post/gomod/","publishdate":"2019-04-14T11:20:27+08:00","relpermalink":"/post/gomod/","section":"post","summary":"项目逐渐都切到了 go mod，用的时候遇到了各种奇奇怪怪的坑，记录一下。 流程实践 语义化版本 Go mod 在设计时没有支持诸如 \u0026gt;2.0, ~3.4, ^4.0 这样场景的语法。而是以语","tags":["go","gomod"],"title":"Go Module 实践中的问题（持续更新）","type":"post"},{"authors":null,"categories":null,"content":"abc\naaa\n","date":1554997151,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554997151,"objectID":"a6f52b0e5c0ef5dfb93386f030f66472","permalink":"/project/gt/","publishdate":"2019-04-11T23:39:11+08:00","relpermalink":"/project/gt/","section":"project","summary":"abc\naaa","tags":["tool"],"title":"gt","type":"project"},{"authors":null,"categories":["简书","随笔"],"content":" 迁移自简书，格式可能未经校对。\n 事件经过：  收到反馈测试环境某个服务打开 swagger ，进程会卡死 根据经验，初步判定是有死循环。 在本地启动该服务，打开 swagger ，发现 CPU 单核100%，确认有死循环 pprof 抓取 cpu profile  在 marshal 前后打断点，对于特定链接，marshal 没结束(没看到 done 日志) 更换为官方 json 库，恢复正常。确认是 json-iterator 导致  在其他项目做同样操作，未能复现问题。对比jsoniter 版本，初步判定是版本过老导致。 通过 debug，确认是下面这个循环走不出来 升级 jsoniter ，恢复正常  到官方一看，这个bug 很早就解决了。但是出事的服务还在依赖 2017-8-9 的版本。（修复链接：https://github.com/json-iterator/go/commit/f7063353029dd177a959dbf6b29f48746441fbfa#diff-34ab17b5ece86461ae47905134a8d94c）  第二个问题，为什么整个程序会假死 按理说，for{} 会造成单个协程停不下，CPU 单核打满都好理解，但为什么会让整个进程死掉？\n原因在于 GC标记前，需要通知所有 goroutine 停下来，但是问题协程一直停不下来，而正常协程都已经停下来在等待。所以对外无法正常服务，看起就是死掉了。\n暴露的问题  对 Go 底层完全 hold 不住 第三方依赖管理不规范  参考链接  历史四年的关于for{}的抢占式讨论 https://github.com/golang/go/issues/10958 Goroutine调度实例简要分析 https://tonybai.com/2017/11/23/the-simple-analysis-of-goroutine-schedule-examples/ 滴滴大佬如何定位 golang 进程 hang 死的 bug https://gocn.vip/article/441  ","date":1553444565,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1553444565,"objectID":"2e054d5bf54a9a8e788af5455bf261ab","permalink":"/post/jianshu/json-iterator-%E5%9C%A8-swagger-%E4%B8%8B%E5%8D%A1%E6%AD%BB%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%92%E6%9F%A5/","publishdate":"2019-03-25T00:22:45+08:00","relpermalink":"/post/jianshu/json-iterator-%E5%9C%A8-swagger-%E4%B8%8B%E5%8D%A1%E6%AD%BB%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8E%92%E6%9F%A5/","section":"post","summary":"迁移自简书，格式可能未经校对。 事件经过： 收到反馈测试环境某个服务打开 swagger ，进程会卡死 根据经验，初步判定是有死循环。 在本地启动该服务，打开 swagger ，发","tags":["Json","Iterator","swagger","Go"],"title":"Json Iterator 在 swagger 下卡死程序的排查","type":"post"},{"authors":null,"categories":["简书","随笔"],"content":"[TOC]\n 背景\n最近想写一些简单的非技术文章，希望能给其他行业的说明白计算机所能和所不能，方便大家用好计算机这个工具。\n 为什么数据都有了，但是不让我查询和统计？ 思考：\n 如果计算机记录了每个用户读了哪本书，那么是不是也很容易知道一本书被哪些用户读过？\n 你可能会觉得理所当然。\n但是，答案其实是 No。关键在于索引，什么是索引呢，举个例子：\n 如果我要在字典里取找“李”这个字，常见的办法是在字典目录里先找“木”字头的所有字，假如找出100个，再到这些字里找到“李”。\n反过来，我能不能先找“子”为底的所有字，再从中找“李”呢？\n 想法是好的，但现实是，没有哪本字典能提供这样的功能。\n之所以我们能先找“木”字头而不能先找“子”字底，是因为字典帮我们提供了一份“木”字头的目录而没有提供后者的目录。\n这个目录，在计算机里就称作“索引”（Index）。\n我们一般会说，字典为“木”字头建立了索引，但是没有为“子”字底建立索引。如果我们也为“子”建立一份索引，就可以反过来查到“李”字了。顺便，我们也可以在索引里面直接数出“子”字底的字有多少个。\n回到思考题，我们知道用户读过的书，但却不能统计一本书的阅读用户。你就大概猜到了，记录每个用户读了哪些书，潜台词就是我在“用户”维度建立了索引，但是却不一定也给“书”的维度建立了索引。\n再举个例子加深你的理解\n 如果你在大街上随便问一个人读过哪些书，他可以很快答出来。\n但是，如果要问你大街上有哪些人读过某一本书，你可能就需要大费周折了。\n 这是因为，当一本书被一个人读了之后。虽然是“书”和“人”这两个主体发生了关联。但是，只有人的脑子里记录了这个关联，书店并不会记录这本书被某人读了。人脑记住的这份关联，就是索引。\n","date":1553326653,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1553326653,"objectID":"d85f2d2f6de69a9779b8f9df180e527a","permalink":"/post/jianshu/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%8E%B0%E8%B1%A1/","publishdate":"2019-03-23T15:37:33+08:00","relpermalink":"/post/jianshu/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E7%9B%B4%E8%A7%89%E7%8E%B0%E8%B1%A1/","section":"post","summary":"[TOC] 背景 最近想写一些简单的非技术文章，希望能给其他行业的说明白计算机所能和所不能，方便大家用好计算机这个工具。 为什么数据都有了，但是不让我查询","tags":[],"title":"关于计算机的一些反直觉现象","type":"post"},{"authors":null,"categories":["简书","随笔"],"content":"以前在引入第三包的时候，为了兼容性和定制扩展的考虑，一般会浅浅地封装一层。自从入了 Go 坑，发现连标准库也得小心再小心了。\ndecode(map) 之后 int 会变成 float64 思考一下，把一个 map encode 之后再 decode，结果和原来的 map 是否相等？直觉上肯定是对的，然而\u0026hellip;\n看一段代码（https://play.golang.org/p/DHb-kZNHidd）：\nm := make(map[int]interface{}) m1 := make(map[int]interface{}) m[2] = 3 b, _ := json.Marshal(m) json.Unmarshal(b, \u0026amp;m1) fmt.Println(m)\t// map[2:3] fmt.Println(m1)\t// map[2:3] fmt.Println(reflect.DeepEqual(m, m1))\t// false 看起来是不是很诡异，打印出来的都一模一样，然而两个却不相等。是不是 DeepEqual 里藏着什么猫腻？按照代码注释， 只要每个元素都相等，整个 map 就相等。\n难不成这个2和3有问题？我们再打印一下看看：\nfmt.Printf(\u0026#34;%T %T\u0026#34;, m[2], m1[2]) // int float64 这个时候发现，decode 出来的数字被悄悄地变成了 float64。后来发现，其实官方也早有说明。只是这种不起眼的功能平时没注意。\n如果上面例子里改成 m[2] = 3.0，结果就正常了。参见：https://play.golang.org/p/vAC1BXc7nCO\nencoding 时自动追加 \u0026lsquo;\\n\u0026rsquo; 跑 Unit Testing 时遇到的。在 github 上看到有人问到过这个问题，官方给的理由是看起来舒服。不得不说，Go Team 在写 std 时真是太随意了。\n暂时没想到特别好的解决方案，在自己的工具类 JsonEncode 里手动给去掉了。因为一般使用的 json 末尾都是 } ]。后面或许会加个全局的开关来配置？\n默认情况下会开启 escapeHTML 严格来说不能算坑，但确实跟我之前的习惯不太一样。而且要关闭的时候，还不能直接设置，得绕个大弯：\nbuffer := \u0026amp;bytes.Buffer{} encoder := json.NewEncoder(buffer) encoder.SetEscapeHTML(false) // 到这才算 init 完成  encoder.Encode(...) 现在很多人使用 Go 只是提供一个简单的 json 给客户端，html 字符，其实不太会搞出什么麻烦，有时候也就懒得处理了。\n不能处理递归指针（会死循环） 如果对象的属性是指向自己的指针（例如循环列表），marshal 时会陷入死循环。在 dump 复杂对象时需要注意。\nprintln 函数没有这个问题，因为会把指针直接打印出地址。\n最后 建议大家使用的自己也能稍微封装一下，至少在各种特殊场景下能自己掌控住。尤其 Go 很多官方包不像 Java 那样接口先行，而且 Go 还不支持继承，以至于在项目大了后想替换个 struct 非常痛苦。\n另外我自己也在尝试对这些问题做一些整理，欢迎加入。\n","date":1535372915,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1535372915,"objectID":"9eacb31828ae63dc0c89e9182bd5a2ce","permalink":"/post/jianshu/go-encoding-json-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91/","publishdate":"2018-08-27T20:28:35+08:00","relpermalink":"/post/jianshu/go-encoding-json-%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91/","section":"post","summary":"以前在引入第三包的时候，为了兼容性和定制扩展的考虑，一般会浅浅地封装一层。自从入了 Go 坑，发现连标准库也得小心再小心了。 decode(map) 之后 int 会变成 float64 思考一","tags":["Go","encoding","json"],"title":"Go encoding json 的几个坑","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 越来越多的应用里需要依赖大量的对外请求（内部服务或第三方平台）。但是很多的 client 只有基本的请求，这在复杂的场景里根本无法应对各种问题，所以我试图整理一下之前遇到的坑，也是封装一个 httpClient 所需要支持的地方。\n重试策略：\n  立即重试\n  延时重试\n 动态延时，1s 2s 4s 8s \u0026hellip;    频率限制\n  全局 Pool\n  针对同一服务下，排队\n  配置级别：\n  全局\n  服务级\n  调用方\n  服务方\n    Request\n  日志记什么：\n  请求耗时\n  请求信息\n  url = host + path\n  args = header + query + form\n    请求结果\n  response header 一定得记\n  如果结果是简单数据，比如 json，就全记下\n  如果对方接口挂了，返回了 nginx 错误HTML，比如5xx，要记录\n  如果是文本文件流，可以记录关键部分；如果是二进制，至少记下 md5 + size\n    TraceId（参考 https://www.jianshu.com/p/73346f667f3d)\n  ","date":1535286146,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1535286146,"objectID":"ca8880b2be732a5666e93ad6fa97d40d","permalink":"/post/jianshu/httpclient-%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9/","publishdate":"2018-08-26T20:22:26+08:00","relpermalink":"/post/jianshu/httpclient-%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9/","section":"post","summary":"迁移自简书，格式可能未经校对。 越来越多的应用里需要依赖大量的对外请求（内部服务或第三方平台）。但是很多的 client 只有基本的请求，这在复杂的场景里根","tags":["HttpClient"],"title":"HttpClient 的几个点","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 场景还原 先说个场景：\nAPP上某个操作出现了 系统异常。错误码：abc012，我们收到错误码之后，可以一次性查出这条请求完整的请求路径，穿越了哪几个服务，出错的代码堆栈信息，甚至中间发生了哪些 SQL 查询。这样我们基本在脑子里复现整个场景了。\n其中涉及的几个地方：\n  错误码：很多时候并不能得到这个错误截图，我们可以用户反馈的时间、用户ID、功能大致定位到。错误码放在全局的 response header 里\n  请求轨迹：在请求来的时候加个 traceId，这个 traceId 注入到后面的 logger 和 client，这样所有的log就都能识别了。\n  堆栈信息：像 Php Java 可以很方便的在出现 ERROR 时把堆栈信息跑出去（Php还能记录每个函数的调用参数）。我们用 Go 比较麻烦一些，要专门加个记录 stack 的 error 类型。\n  SQL日志：这个看需要了，如果你的 ORM 框架对钩子支持好，加起来也不是难事。\n  日志框架 功能上，个人觉得有个强大的 Hook 就够了。这样每个团队都可以根据自己需要来加自己需要的东西\n  Hook\n  继承 context\n  必要时候输出代码位置信息\n    Keyword\n  Extra Map\n  输出和存储   格式：支持不同环境下不同的格式，比如dev模式，关键字就挺好。线上可能需要以json格式打到相关的日志服务里。\n  分卷存储：有的框架会按照日期来分文件，个人觉得没必要，可以用 logrotate 这样专业的工具来做。还有一种思路，用 rsyslog 把日志导出到你的日志服务里去，本机的日志，不用存多少就可以删掉了。\n  监控报警   如果性能没那么苛刻，推荐直接集成 Sentry\n  如果团队实力比较强，可以根据日志做各种分析和监控，参考 open-falcon\n  参考  优秀日志实践准则  ","date":1535202165,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1535202165,"objectID":"3a405deb7efba0b441221eadb28cc21c","permalink":"/post/jianshu/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E5%87%A0%E4%B8%AA%E6%83%B3%E6%B3%95/","publishdate":"2018-08-25T21:02:45+08:00","relpermalink":"/post/jianshu/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E5%87%A0%E4%B8%AA%E6%83%B3%E6%B3%95/","section":"post","summary":"迁移自简书，格式可能未经校对。 场景还原 先说个场景： APP上某个操作出现了 系统异常。错误码：abc012，我们收到错误码之后，可以一次性查出这","tags":[],"title":"关于日志的几个想法","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n Github：https://github.com/Kretech/xgo\n缘起是因为 Go 的很多语法太啰嗦，也许 Go 官方为了通用性牺牲了简洁，而我们日常更青睐于 约定优于配置，所以我们需要对我们的80%情况做一些优化。\n整理了哪些东西：\n  常见的 utils 库\n 类似于随机数 rand(100)、转下划线 word.UnderlineCase('HelloWorld')等等    基础数据结构\n 科班都学过的链表、树、图以及这些数据结构上的基本算法    略复杂的数据结构\n Array + Dict 类似于 Php 里的 array。在性能不那么要命的地方用起来很爽 Redis 基本数据结构：跳跃表    ","date":1534526775,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1534526775,"objectID":"e6b65dc4e95e8c55c9280c89945a19ee","permalink":"/post/jianshu/%E6%95%B4%E7%90%86%E4%B8%80%E5%A5%97-go-%E7%9A%84%E8%BD%AE%E5%AD%90/","publishdate":"2018-08-18T01:26:15+08:00","relpermalink":"/post/jianshu/%E6%95%B4%E7%90%86%E4%B8%80%E5%A5%97-go-%E7%9A%84%E8%BD%AE%E5%AD%90/","section":"post","summary":"迁移自简书，格式可能未经校对。 Github：https://github.com/Kretech/xgo 缘起是因为 Go 的很多语法太啰嗦，也许 Go","tags":["Go"],"title":"整理一套 Go 的轮子","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 这里只会记录在学习 Redis 源码时觉得比较好玩的地方，不会一五一十的讲细节。\n内存分配 zmalloc 在实际 malloc 到的内存前面加一个 size 。\nvoid *zmalloc(size_t size) { void *ptr = malloc(size+PREFIX_SIZE); *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE; } 动态字符串 sds sds 在基础的 char* 前面加一段 header 来记录信息（类似于 Go 实现）。\n// 除了 sdshdr64，还有 sdshdr32、sdshdr16... 区分不同的长度上限 struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; sds sdsnewlen(const void *init, size_t initlen) { ... sh = s_malloc(hdrlen+initlen+1); s = (char*)sh+hdrlen;\t// 实际字符串  memcpy(s, init, initlen); return s; } 字典 dict   基本数据结构\n dictEntry：键值对。（冲突处理：开链） dictht：哈希表。记录使用情况用来 rehash dict typedef struct dict { dictType *type;\t// 不同type有不同的hash算法  void *privdata; dictht ht[2];\t// 两个 ht 来实现渐进式的 rehash  long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */ } dict;     哈希算法\n  rehash：冲突元素太多时扩容。通过两个哈希表进行\n 渐进式策略：  每次执行操作时转移一个 定时每次转移100个      数据操作\n 每次操作前尽可能进行一次 rehash。 rehash 时，要依次在两个表里查询；其他操作类似。    跳跃表 zset  数据结构  span    整数集合 intset  数据结构  encoding 记录元素大小，对于小的数字，使用 int16_t 来节省内存。   resize  先分配足够内存，再调用 memmove 函数进行搬移 单向升级，只有在插入元素的时候，如果 encoding 过小时会进行    鸣谢  Redis源码剖析  ","date":1533402967,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1533402967,"objectID":"284998423a012dba36e3936c2a713a82","permalink":"/post/jianshu/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","publishdate":"2018-08-05T01:16:07+08:00","relpermalink":"/post/jianshu/redis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"post","summary":"迁移自简书，格式可能未经校对。 这里只会记录在学习 Redis 源码时觉得比较好玩的地方，不会一五一十的讲细节。 内存分配 zmalloc 在实际 malloc 到的内存前面加一个 size 。 void","tags":["Redis"],"title":"Redis 学习笔记","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 用 Laravel 很久了，whereHas 简直是连表大杀器，本来需要写大量 SQL 的查询用 whereHas 都可以很快的实现。不过在一些场景里，遇到了严重的性能问题。\n我们有个A表，大约是百万级数据，与之关联的有个B表，大约万级数据。在做关联查询的时候我们自然使用 A::whereHas('b', function(){...}) 。\n后来发现了许多慢查询，仔细一看发现，Laravel 的 whereHas 在生成 SQL 的时候会使用  select * from A where exists ( select * from b where ... ) 。当我们的左表远远大于右表时，A 表就成了性能瓶颈。\n最直接的方法当然是拆成两条 SQL，但是嫌麻烦，还得一条条优化。再加上我们很多 SQL 都是靠各种工具生成，所以改起来也挺麻烦。\n于是就考虑加了个 whereHasIn 的方法，接口参数跟 whereHas 一致，只不过在生成 SQL 的时候会生成 select * from A where A.id in (select id from B)。这样就不需要改什么 SQL 了，只要在调用 A::whereHas() 的地方加两个字符变成 A::whereHasIn() 就搞定了。在实际中，我们这条查询的耗时从几秒一下降低到了20毫秒。\n下面是一个实现的 demo，暂时只支持 一对多的情况。如果大家有什么更好的想法，一起讨论讨论。\n\u0026lt;?php use Illuminate\\Database\\Eloquent\\Relations; abstract class AbstractModel { /** * whereHas 的 where in 实现 * * @param \\Illuminate\\Database\\Eloquent\\Builder $builder * @param string $relationName * @param callable $callable * @return Builder * * @throws Exception */ public function scopeWhereHasIn($builder, $relationName, callable $callable) { $relationNames = explode(\u0026#39;.\u0026#39;, $relationName); $nextRelation = implode(\u0026#39;.\u0026#39;, array_slice($relationNames, 1)); $method = $relationNames[0]; /** @var Relations\\BelongsTo|Relations\\HasOne $relation */ $relation = Relations\\Relation::noConstraints(function () use ($method) { return $this-\u0026gt;$method(); }); /** @var Builder $in */ $in = $relation-\u0026gt;getQuery()-\u0026gt;whereHasIn($nextRelation, $callable); if ($relation instanceof Relations\\BelongsTo) { return $builder-\u0026gt;whereIn($relation-\u0026gt;getForeignKey(), $in-\u0026gt;select($relation-\u0026gt;getOwnerKey())); } elseif ($relation instanceof Relations\\HasOne) { return $builder-\u0026gt;whereIn($this-\u0026gt;getKeyName(), $in-\u0026gt;select($relation-\u0026gt;getForeignKeyName())); } throw new Exception(__METHOD__ . \u0026#34; 不支持 \u0026#34; . get_class($relation)); } } ","date":1530018441,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1530018441,"objectID":"55d5121dc7a5495dec45bbfe7269a8b8","permalink":"/post/jianshu/laravel-eloquent-wherehas-%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BC%98%E5%8C%96/","publishdate":"2018-06-26T21:07:21+08:00","relpermalink":"/post/jianshu/laravel-eloquent-wherehas-%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BC%98%E5%8C%96/","section":"post","summary":"迁移自简书，格式可能未经校对。 用 Laravel 很久了，whereHas 简直是连表大杀器，本来需要写大量 SQL 的查询用 whereHas 都可以很快的实现。不过在一些场景里，遇","tags":["Laravel","Eloquent","whereHas"],"title":"Laravel Eloquent whereHas 的一个优化","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 最近看到了几种加缓存的方法，整理对比一下。\n拿一个case来说，我们要去数据库取一条用户记录，迫于性能，还要加一层缓存。我们针对这个问题看看几种使用姿势的对比。\nLaravel 中 Facades 做法\n$person = Cache::remember(\u0026quot;person.{$id}\u0026quot;, 5, function () use ($id) { return PersonDao::find($id); });  Spring Cache 的做法\n@Cache(key = \u0026quot;person#id\u0026quot;, ttl = 5) public Person getPerson(Integer id) { return PersonDao.find(id); } Person person = repository.getPerson();  备注：\n PersonDao.find 表示从DB里去拿数据  这两种方法看起来都很简单，除了必要的语法格式，你需要写的代码就是：\n cache 函数或标记，表明需要缓存 key 不解释 ttl 不解释 func… 回源数据  基本上可以说是要啥写啥了，不啰嗦。\n其实 Php 和 Java 的语法很接近，两种方法在两种语言里都适用。不过 Php 需要第三方的注解支持；Java 需要 8 以上来支持 lambda。\n简单的东西一定面临扩展性的问题，我们来看一看他们的可能性。\n如果我们要更换缓存驱动怎么办？\nLaravel\nCache::store('redis')-\u0026gt;remember(...)  Spring\n@Cache(driver = redisCache.class)  依然很简单。\n有些时候，在使用 redis 作为缓存的时候，我们会用不同的编码\nLaravel\nCache::store('redis')-\u0026gt;encoding('json')-\u0026gt;remember(...)  Spring\n@Cache(encoding = JsonEncoding.class)  方法其实是相似的，一般的，Lavavel 利用自己习惯的链式操作和 Php 的不定参数，可以让你随时传入自己个性化的需求。Spring 也利用 Annotation 来实现类似的效果。\n更多的，Laravel 和 Spring Boot 都遵循了约定优于配置的原则，使得在大多数情况下，你都不需要传这些，只需要使用全局的默认配置就能满足需求。也就是上面的最方便的办法。\n简单的方法介绍完了，我们来聊聊 Go 里的做法\n刚刚接手一个 Go 项目，里面看到是这样处理缓存的：\nproxy := Proxy{ Prefered: RedisAdapter{ RedisClient }, Backup: DaoAdapter{ PersonDao } } person := proxy.Get('xxx').(Person)  是不是一下看懵逼了，我也是，这还是简化的版本。真正实现一个这样的功能，大约新增了三个实现了数个空接口新类和几个方法。\n更蛋疼的，这三个类都是类型相关的，换句话说，list/detail 两种功能各自都需要3个类，换个 model 也不能复用。更悲催的，因为 IDE 对 Go 的 interface 分析都不太好，当你阅读别人的代码的时候，你完全不知道哪里是哪里。\n所以，这里想尝试一下，能否在 Go 里使用上面的简单方法处理缓存。\nid := 9 person := remember(\u0026quot;key\u0026quot;, 30 * time.Second, func() interface{} { return PersonDao.find(id) }).(*Person) // 或者更 Go 一点 var person Person remember(\u0026amp;person, \u0026quot;key\u0026quot;, 30 * time.Second, func(iface interface{}) { *iface.(*Person) = *PersonDao.find(id) })  比较烦的是，Go 不支持泛型，定义函数的时候要尽可能少依赖类型。常用的办法是把类型传入。\n前者看起来简单，但有个很要命的地方，你需要很严格的把 Person 类进行序列化。否则从 cache 里取出来后类型可能会丢，导致断言失败。\n那么，第二种办法可以吗？或者说，在 Go 里能不能通过简单标记的办法来实现多态？\n我只能说，不好弄。\nSpring 里很多注解效果，都是靠动态代理实现的（相当于 Php 里阉割版的 __call )。但遗憾的是，Go 目前不能支持这一特性。如果要硬上的话，也可以，搞出来可能跟我接的代码挺像的。\n","date":1529067814,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1529067814,"objectID":"4b10750e96178f96713e67bea6bfb428","permalink":"/post/jianshu/%E6%80%8E%E6%A0%B7%E5%BF%AB%E9%80%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98-cache/","publishdate":"2018-06-15T21:03:34+08:00","relpermalink":"/post/jianshu/%E6%80%8E%E6%A0%B7%E5%BF%AB%E9%80%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98-cache/","section":"post","summary":"迁移自简书，格式可能未经校对。 最近看到了几种加缓存的方法，整理对比一下。 拿一个case来说，我们要去数据库取一条用户记录，迫于性能，还要加一","tags":["Cache","Laravel","Go","Java","Spring"],"title":"好用的 Cache API","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 入门  官方文档 英文 中文  深入理解  《From Apprentice To Artisan》 讲Laravel内部设计的小册子，能帮你了解laravel的整体实现 《详解Laravel源码》 分模块去介绍源码  开发相关  Laravel Plugin for PhpStorm Laravel ide-helper for PhpStorm 识别各种魔术方法，包括 Facedes 和 Eloquent 等。最好先了解 PhpDoc  社区  Laravel China  ","date":1521598915,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1521598915,"objectID":"2c694ff18623f81dcf0e51b32f155334","permalink":"/post/jianshu/laravel-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","publishdate":"2018-03-21T10:21:55+08:00","relpermalink":"/post/jianshu/laravel-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","section":"post","summary":"迁移自简书，格式可能未经校对。 入门 官方文档 英文 中文 深入理解 《From Apprentice To Artisan》 讲Laravel内部设计的小册子，能帮你了解lara","tags":["Laravel"],"title":"Laravel 学习路线","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" 迁移自简书，格式可能未经校对。\n 还会更新，只是懒得整理，先堆这里了\nPlatUML 代码：\n@startuml \u0026#39; 底层驱动部分 class DatabaseManager{ connection() factory的大脑 } class ConnectionFactory{ newConnection() } interface Connection { defaultBuilder defaultGrammar defaultProcesser run() // 真正到DB里跑SQL的 } interface Connector { connect() } package Query|Schema { interface Grammar interface Processer note right of Processer: 对数据库返回值的二次拼装 class QueryBuilder { IConnection IGrammar IProcesser paginate() } } DatabaseManager *--\u0026gt; ConnectionFactory DatabaseManager *--\u0026gt; Connection DatabaseManager *--\u0026gt; Connector ConnectionFactory *--\u0026gt; Connection ConnectionFactory *--\u0026gt; Connector Connection --|\u0026gt; Grammar Connection --|\u0026gt; Processer QueryBuilder --|\u0026gt; Grammar QueryBuilder --|\u0026gt; Processer Connection -- QueryBuilder \u0026#39; Eloquent package Eloquent{ abstract class Relation{ Ebuilder constraints } class EBuilder{ model scopes earerLoad macro first() has() } class model{ scopes events __call() serialize() } } @enduml ","date":1520047425,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1520047425,"objectID":"986f66489a4209df7fab9b98fe664210","permalink":"/post/jianshu/laravel-orm-%E6%A8%A1%E5%9D%97%E5%9B%BE/","publishdate":"2018-03-03T11:23:45+08:00","relpermalink":"/post/jianshu/laravel-orm-%E6%A8%A1%E5%9D%97%E5%9B%BE/","section":"post","summary":"迁移自简书，格式可能未经校对。 还会更新，只是懒得整理，先堆这里了 PlatUML 代码： @startuml \u0026#39; 底层驱动部分 class DatabaseManager{ connection() factory的大脑 } class ConnectionFactory{ newConnection() } interface Connection { defaultBuilder defaultGrammar defaultProcesser run() //","tags":["Laravel","ORM"],"title":"Laravel ORM 模块图","type":"post"},{"authors":null,"categories":["简书","Kretech"],"content":" ORM 于创业项目快速迭代的重要性不言而喻。我也一直在不停地寻找更好的方案。\n 造了个轮子：Loulan-java\n市面上有些不错的 orm 框架，诸如 Laravel、Ror、Gorm。\n参考这些整理并增加了下面的特征：\n OR Mapping 约定及自定义的mapping规则，书写简单，不能每个字段都写一堆标记 Scalable 只需简单配置，支持各个级别的分库分表分读写 Hook / Plugin 支持各个级别的hook，支持自定义插件/中间件 Functional QueryBuilder 良好的细节屏蔽，需要语法简约，支持复用，可扩展，容易支持缓存 Pagination 简单的分页接口支持 Relations Eager Loading 预加载 Collections 兼容链式操作的集合框架 Mutators / Casting Full SQL 诸如事务、联表、简单计算等  ","date":1516074342,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1516074342,"objectID":"9b71a097efcf6a349d85545c65e9143b","permalink":"/post/jianshu/%E7%90%86%E6%83%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%BA%93/","publishdate":"2018-01-16T11:45:42+08:00","relpermalink":"/post/jianshu/%E7%90%86%E6%83%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%BA%93/","section":"post","summary":"ORM 于创业项目快速迭代的重要性不言而喻。我也一直在不停地寻找更好的方案。 造了个轮子：Loulan-java 市面上有些不错的 orm 框架，诸如 Lara","tags":["Laravel","Loulan","Go","ORM"],"title":"理想的数据库操作库","type":"post"},{"authors":null,"categories":["简书","Snippets"],"content":" 迁移自简书，格式可能未经校对。\n 缘由：网上google出来的东西要么排版太丑要么啥都没有\n安装 apt install vsftpd  限制目录 ftp 在 /etc/vsftpd.conf 里有个 local_root=/home/sftp_root。测试发现， 只对不加密的ftp有效。\nsftp 要限制sftp的权限，都要通过限制ssh访问的方式。大概方法是：\n 建立一个用来限制目录的组 sftp-users\n  建立一个专门用来登陆sftp的用户 sftpu1，并加入到上面的组里\n  在sshd里限制这个组的访问空间\n  建用户组\n groupadd sftp-users    建用户并加到组里\n useradd -g sftp-users -s /bin/false sftp    限制该组的活动空间\n  在 /etc/ssh/sshd_config 里追加以下内容\nMatch Group sftpuser ChrootDirectory /home/sftp_root ForceCommand internal-sftp AllowTcpForwarding no X11Forwarding no 改完之后记得让ssh重读配置\nsudo service sshd reload  但是，这样基本上要求你的ssh用户和sftp用户没法是同一个人了\n","date":1496591700,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1496591700,"objectID":"6ce0f2ca11735edc9e6009eb1cf35276","permalink":"/post/jianshu/sftp-%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/","publishdate":"2017-06-04T23:55:00+08:00","relpermalink":"/post/jianshu/sftp-%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/","section":"post","summary":"迁移自简书，格式可能未经校对。 缘由：网上google出来的东西要么排版太丑要么啥都没有 安装 apt install vsftpd 限制目录 ftp 在 /etc/vsftpd.conf 里有个 local_root=/","tags":["sftp"],"title":"sftp 配置笔记整理","type":"post"},{"authors":null,"categories":["简书","Snippets"],"content":" 迁移自简书，格式可能未经校对。\n 下载 \u0026amp; 安装 使用 Visio Studio 2012 开发时，要选 SQL Server Data Tools\n但是！！它其实装的是2010版！！所以装好后只能从 vs2010 里建 IS 项目\n如果要从 vs2012 里建，还需要安装东西。参考 http://blog.csdn.net/CodeRookieGuo/article/details/50471123\n无法读取表或视图 原因不明，暂时用了 select，先解决问题，明天再说\nSQL Server 密码不对 登陆的时候专门选了混合登陆，但是一直提示登不上，改了密码依旧如此，怀疑是缺少证书。\n暂时换了 windows 身份验证连上。\n未完待续，毕竟坑无限。\n","date":1482609970,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1482609970,"objectID":"ba18e0a49fb27badd47cc8f0c54b4b93","permalink":"/post/jianshu/ssis-%E7%AC%94%E8%AE%B0/","publishdate":"2016-12-25T04:06:10+08:00","relpermalink":"/post/jianshu/ssis-%E7%AC%94%E8%AE%B0/","section":"post","summary":"迁移自简书，格式可能未经校对。 下载 \u0026amp; 安装 使用 Visio Studio 2012 开发时，要选 SQL Server Data Tools 但是！！它其实装的是2010版！！所以装好后只能从 vs2010 里建 IS 项目 如果要从","tags":["SSIS"],"title":"SSIS 笔记","type":"post"},{"authors":null,"categories":["简书","Snippets"],"content":" 迁移自简书，格式可能未经校对。\n !/bin/sh # homebrew /usr/bin/ruby -e \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026#34; # iTerm2 brew install Caskroom/cask/iterm2 # zsh zsh # .oh-my-zsh sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026#34; # macdown brew install Caskroom/cask/macdown PhpStorm Dash macdown ","date":1482116591,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1482116591,"objectID":"fab49d4987328aca852e03bcb2424857","permalink":"/post/jianshu/mac-%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","publishdate":"2016-12-19T11:03:11+08:00","relpermalink":"/post/jianshu/mac-%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","section":"post","summary":"迁移自简书，格式可能未经校对。 !/bin/sh # homebrew /usr/bin/ruby -e \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026#34; # iTerm2 brew install Caskroom/cask/iterm2 # zsh zsh # .oh-my-zsh sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026#34; # macdown brew install Caskroom/cask/macdown PhpStorm Dash macdown","tags":["Mac"],"title":"Mac 基本开发环境","type":"post"},{"authors":null,"categories":["简书","Snippets"],"content":" 迁移自简书，格式可能未经校对。\n 推荐 https://github.com/fatedier/frp 比 ngrok 好用很多  看文档太复杂了，脑子又记不住，先贴这了。\n需要的时候改一下DOMAIN 直接跑\n参考自：https://aotu.io/notes/2016/02/19/ngrok/\nInstall #!/bin/sh  DOMAIN=your-domain.com cd $GOPATH/src git clone https://github.com/inconshreveable/ngrok.git cd ngrok # 生成 key openssl genrsa -out rootCA.key 2048 openssl req -x509 -new -nodes -key rootCA.key -subj \u0026#34;/CN=${DOMAIN}\u0026#34; -days 5000 -out rootCA.pem openssl genrsa -out device.key 2048 openssl req -new -key device.key -subj \u0026#34;/CN=${DOMAIN}\u0026#34; -out device.csr openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000 cp rootCA.pem assets/client/tls/ngrokroot.crt cp device.crt assets/server/tls/snakeoil.crt cp device.key assets/server/tls/snakeoil.key make release-server make release-client Run Server bin/ngrokd -domain=\u0026quot;${DOMAIN}\u0026quot; -httpAddr=\u0026quot;:10080\u0026quot; -httpsAddr=\u0026quot;:10443\u0026quot;  Client cd bin echo \u0026#39;server_addr: \u0026#34;\u0026#39;${DOMAIN}\u0026#39;:4443\u0026#34;\u0026#39; \u0026gt; ngrok.cfg echo \u0026#39;trust_host_root_certs: false\u0026#39; \u0026gt;\u0026gt; ngrok.cfg ./ngrok -subdomain demo -config=ngrok.cfg 8080 ","date":1481299893,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1481299893,"objectID":"19143fc86be7691e3edc92f4a7a16bfa","permalink":"/post/jianshu/ngrok-%E6%90%AD%E5%BB%BA%E8%84%9A%E6%9C%AC/","publishdate":"2016-12-10T00:11:33+08:00","relpermalink":"/post/jianshu/ngrok-%E6%90%AD%E5%BB%BA%E8%84%9A%E6%9C%AC/","section":"post","summary":"迁移自简书，格式可能未经校对。 推荐 https://github.com/fatedier/frp 比 ngrok 好用很多 看文档太复杂了，脑子又记不住，先贴这了。 需要的时候改一下DOMAIN 直接跑 参考自：https","tags":["ngrok"],"title":"ngrok 搭建脚本","type":"post"},{"authors":null,"categories":["简书","随笔"],"content":" 迁移自简书，格式可能未经校对。\n 大学时，我一直有个问题不明白。为什么我不是我的team里最厉害的，跟其它team的老大相比也不是那么耀眼，但我带的team却成了最成功的团队（之一）。\n说说一些看法\n提前说明，大部分基于上学时的经验，少量参考职场经验。\nleader定位 工作后，我发现很多leader所谓的带人，不过就是让手底下的人能按照自己的吩咐去做事，当你真正交给他一个事情时，他就懵逼了。挑不起担子，无法独立思考，做决定。\n再联想到大学的时候学校也有其他的team，有一大类特别强调leader的权威，最后都很难成气候。虽然会在开始的一阵子让你感到满面春风，到长久也就成了行尸走肉。\n但是那些一开始就相对注重团队成员自我实现的，尽管前期会充满荆棘与摇摆。但会有一天，每个人都会释放无穷尽的能量。大一呆的辩论队也隐约有这个感觉。\n我觉得，leader从来就不应该是一个团队的核心，也完全不应该成为一个团队的精神象征。leader的作用应该只是维护团队的核心灵魂，维护好了，那个魂自己就回去吸引合适的人参与进来。\n带什么 举个很明显的区别，我们备课的时候，最不能接受知识点的罗列，经常在课前让主讲同学把整个ppt的逻辑颠倒。讲课的时候也一直强调在过程中启发。结果啥样自己去试。\n有些团队的培训，大部分都是很直白的一份讲义，散漫的列着想到啥是啥的东西，然后一个个过一下教大家这东西怎么用。\n从效率上来说，后者还是很明显的，一节课下来很多人反应收获不少。但是我们那样上课会让人觉得讲的太空太范。\n但实际上我认识的比较厉害的同学，大都是在自己折腾的过程中，突然脑海浮现一个点，然后把问题搞定。没有谁会去靠着课上那些东西来用。\n工作后也很明显，很多老大都是说你要做什么，却不提及背后的逻辑。底下人只能套用“做事模板”来干活。突然有天事情有了微妙的变化，然后不明所以的遭到了一顿骂。\n未完待续。\n","date":1480732013,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1480732013,"objectID":"6eaa5da03691c570170e0b588346eb5f","permalink":"/post/jianshu/%E5%BC%80%E5%9D%91%E5%85%B3%E4%BA%8E%E5%B8%A6%E5%9B%A2%E9%98%9F/","publishdate":"2016-12-03T10:26:53+08:00","relpermalink":"/post/jianshu/%E5%BC%80%E5%9D%91%E5%85%B3%E4%BA%8E%E5%B8%A6%E5%9B%A2%E9%98%9F/","section":"post","summary":"迁移自简书，格式可能未经校对。 大学时，我一直有个问题不明白。为什么我不是我的team里最厉害的，跟其它team的老大相比也不是那么耀眼，但我","tags":[],"title":"开坑，关于带团队","type":"post"},{"authors":null,"categories":["简书","随笔"],"content":" 迁移自简书，格式可能未经校对。\n 突然发现，工作已经一年了。\n87天日报，18篇周报，78000+字，算是记录。\n前半年里，多是些完成一个清晰明确的既定任务，之后更多的是处理一个相对大一点的项目。\n之前从0到1，现在从1到10，后面的过程，加入了许多非技术因素，很多时候少了所谓的标准答案，不确定性增多了，犯的错也多了，所思所想也开始变多变杂，很多时候就在说不清道不明的是非中突然顿悟。问我顿悟了什么，也说不明白，只是感觉曾经书本上那些无聊的讨论今天就摆在了面前。\n从小，有人会教你工作应该是啥样，不该是啥样。一入职场，发现并不是那么回事，时间久了，发现又好像是那么回事。\n赶上美国大选，结果算是如愿。我一直不知道我什么对川普感兴趣，现在想想，可能我也一贯如此，总想打破污浊的黑云。\n我从来不知道前路在哪里，但是却鄙夷那些肮脏的路。\n未完待续先吃饭。。\n","date":1479032630,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1479032630,"objectID":"988c0733b94c5284f74085e03d3d2a9e","permalink":"/post/jianshu/%E8%81%8C%E5%9C%BA%E5%91%A8%E5%B9%B4%E8%AE%B0/","publishdate":"2016-11-13T18:23:50+08:00","relpermalink":"/post/jianshu/%E8%81%8C%E5%9C%BA%E5%91%A8%E5%B9%B4%E8%AE%B0/","section":"post","summary":"迁移自简书，格式可能未经校对。 突然发现，工作已经一年了。 87天日报，18篇周报，78000+字，算是记录。 前半年里，多是些完成一个清晰明确的","tags":[],"title":"职场周年记","type":"post"},{"authors":null,"categories":["简书","软件工程"],"content":" 迁移自简书，格式可能未经校对。\n Github 新出的squash 功能可以使主仓的log 更加干净，但是有个恶心的情况：\nfetch  company/master -\u0026gt; my/master -\u0026gt; my/dev\ndevlop  my/dev (10 commit) \u0026ndash;\u0026gt; squash \u0026ndash;\u0026gt; company/master (1 commit)\nmodify  my/dev (11 commit)\nmerge  company/master -\u0026gt; my/dev ==\u0026gt; conflict\n暂时解决方法是要求  每次动手前都要拉代码 每次改动都去开新分支  ","date":1478439620,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1478439620,"objectID":"725cfb3e0decec7214e2502af024e327","permalink":"/post/jianshu/github-squash-%E7%9A%84%E4%B8%80%E7%82%B9%E5%9D%91/","publishdate":"2016-11-06T21:40:20+08:00","relpermalink":"/post/jianshu/github-squash-%E7%9A%84%E4%B8%80%E7%82%B9%E5%9D%91/","section":"post","summary":"迁移自简书，格式可能未经校对。 Github 新出的squash 功能可以使主仓的log 更加干净，但是有个恶心的情况： fetch company/master -\u0026gt; my/master -\u0026gt; my/dev devlop my/dev (10 commit) \u0026ndash;\u0026gt; squash \u0026ndash;\u0026gt; company/master (1 commit) modify my/dev (11","tags":["Github","Squash"],"title":"Github Squash 的一点坑","type":"post"},{"authors":null,"categories":["简书","读书笔记"],"content":" 迁移自简书，格式可能未经校对。\n 看到前5章，只能说是读起来很艰难。\n满满的委曲求全的隐忍和男尊女卑，以及各种拗口的日本名词。\n序言说这是二战后的作品，隐忍就好理解了。但时代背景太强，心生一股抵触。我对历史一贯的态度是，可以有作者自身的态度（没有主观态度的书籍是不存在的），但是如果受外界大环境影响太深，就会遮住历史原来的道理。\n在日本女性要听话挺常见，但作者不知为何花那么大笔墨去强调这个问题，暂时没有查到相关资料。难道是作者是故意反讽吗？前五章里，重大的历史进行都托付在女人身上，你说他们不重要，当然不对。广忠以一种 loser 的姿态听从着三个女人对他“男尊女卑”的教诲，实在太搞笑。\n有人把它比作日本的三国演义？我还真保持质疑，三国里跑龙套的小城主小将军不计其数，有几个能有这般权谋，就连那些个主要人物，也都是被几个谋士耍来耍去。完全没有这种全民搞计谋、每个人都捉摸不透的渗人。\n","date":1475602040,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1475602040,"objectID":"99394fcdfe4dadde947ed8a10c0d550f","permalink":"/post/jianshu/%E5%BE%B7%E5%B7%9D%E5%AE%B6%E5%BA%B7%E7%AC%AC%E4%B8%80%E7%AF%87/","publishdate":"2016-10-05T01:27:20+08:00","relpermalink":"/post/jianshu/%E5%BE%B7%E5%B7%9D%E5%AE%B6%E5%BA%B7%E7%AC%AC%E4%B8%80%E7%AF%87/","section":"post","summary":"迁移自简书，格式可能未经校对。 看到前5章，只能说是读起来很艰难。 满满的委曲求全的隐忍和男尊女卑，以及各种拗口的日本名词。 序言说这是二战后的作","tags":[],"title":"《德川家康》第一篇","type":"post"},{"authors":null,"categories":["简书","软件工程"],"content":" 迁移自简书，格式可能未经校对。\n 这周也帮其他人看了看代码，发现大家对一些规范不以为然，所以我想借这个机会聊聊。代码规范的重要性说的太多了，我来说说代码不规范的危害。\n为什么要统一、规范的命名 举个例子，我们有公寓表 suites、房间表 rooms ，rooms 里有个关联到公寓的字段叫 suite_id。试问把 suite_id 改成 house_id 是否合理？\n单从这个例子来说，好像并无不妥，suite 和 house 都能表示公寓的意思。\n但是如果我告诉你我们现在还有额外的两张表：\n house_resources 信息采集端的外部房源，是外部房源进入收房系统的入口 resource_house 楼盘字典中的公寓，沉淀下来的外部房源，暂定  这个时候，假如你是非直接开发人员，比如其他工程师、需要看数据库的运营、财务或是 BI，你第一感觉，rooms 表的 house_id 是到哪个表的关联？我觉得猜到 house_resources 的人会多一些，但如果是 suite_id，再辅之以注释，就会好很多。可即便如此，BI 同学也经常过来问字段的关系。。\n这个例子想说明，当你的系统已经复杂到无法靠简单的 “望文生义” 去识别\u0026amp;区分时，你就得靠统一的规范去保证大家不会乱。我们约定所有的 xx_id 都是到 xx 表的关联，大家就不会再困惑。\n如果只是自己私下写一个二三十行的小脚本，你用 abcdefg 命名没啥问题，但在这里，你 hold 不住的。\n 信息采集端的几个表前缀都是 house_resource ，渠道就是house_resource_users ，渠道费就是 house_resource_bills ，也算一个识别标记。其实从更大的角度来说，房源和客源的跟进，也都该放一起，历史遗留问题。。\n 为什么要抽象和封装 思考：为什么我和孟德都没有参与过合同、活动的开发，但都能在几分钟内添加一个可以自定义规则的新活动？答案是，因为现有的封装已经满足现阶段的需要，我们无须关注整个实现逻辑，只需要改一个文件里的一小段（其实就一个 array）就能实现了。\n如果之前没有做这些工作，那么市场部今天下午告诉你12点前要上一个活动，你要从头熟悉整个代码，要熟悉每个节点的处理方式。恐怕你就是不吃饭不睡觉也来不及。\n其他的系统里，遇到的问题也是一样的：\n 做支付平台，能否在不涉及业务逻辑的情况下，快速添加一个支付平台 做分期平台，能否在不涉及业务逻辑的情况下，快速添加一个分期公司 做房源对接，能否在不涉及业务逻辑的情况下，快速添加一个信息平台 做供应商管理，能否在不涉及业务逻辑的情况下，快速添加一个供应商  如果你为了省一天的时间，在将来却给每个人加了一天的工作量，那么你的代码就是有毒的。\n诚然有很多情况，你并不能预测将来发生的情况，但是按照软件工程的原则，你应该留有扩展的空间。如果其他人已经帮你预料到接下来会有一个类似的东西时，你就必须考虑了。\n小故事，退转换上线前的一个晚上，10点多。我在那里吐槽又要改需求，高靖听到了就跑出来跟我说，你们的系统要做的模块化，在碰到这种情况的时候就能快速组合几个模块达到他们的目的，我们以前巴拉巴拉省略500字。。\n我当时一阵惊讶，一个不写代码的人都懂这个道理，可为什么我们这些“专业人员”却要对几十年的行业经验嗤之以鼻。\n为什么会有必读源码 必读源码最大的用处就是让新人知道这个系统是怎么运作的。\n当时我挑了好多个文件才决定选用这几份代码，有几个考虑：\n 里面包含了laravel、orm 的基本用法和文档，能让你快速上手 有我们沉淀下来的各种轮子，能让你快速实现常用的功能 有我们最一般最一般的产品设计规范，避免你为了达到某一个效果费劲脑汁  看这三份代码花不了个把小时，但是不看呢，有几个人都踩了坑，其结果是本来几十行代码的事，花了几百行才搞完。费时费力还有坑\n分享两例小故事，\n  有天雷雷一激动说我们能不能把完成标成红色（好像是喜庆的意思），我还没开口，旁边一个销售就说我们习惯绿色了，然后我才说我们把红色作为警告的意思。\n  还有我们的列表里按钮一般都在首列，结果就是无论第一列是“编辑”还是一个图标，大家都知道那个修改的地方。\n   红和绿、行首或行尾，都不是什么原则问题。但是在现有环境下，随机改动就增加了其他人的识别和使用成本，那就属于不合理的设计。\n  系统内部的 Error、Flash（小提示）、Confirm 以及 DataEditor 的错误提醒，都是统一的组件，即能提高你的开发效率，也能保证绝大多数人快速上手你的作品。\n 总结就是，强调代码规范，不是闲的蛋疼去满足个人的代码洁癖，而是不想让大家再去踩之前已经踩过的坑，提升整个团队的效率。 至于什么是代码洁癖，我可以分享一下我的一些洁癖：\n 我不喜欢一大行从半截折开，我自己设的最大宽度是160，后来妥协于 psr 规范，改成了120，出现了很多我觉得奇丑无比的折行。而且经过“科学试验”，我认为我们的项目设140比较合适，为此和张卫还争论过。。 我写 json，key/val 之间的冒号我要对齐，工具不支持我就手动对齐，但是为了统一，我也放弃了。绝大多数工具是冒号左边有空格，右边却没空格，我也觉得丑，但。。你懂的。 一个表达式a + b*c，仔细看，+ 两边有空格，但 * 两边没有空格，这是 Go 官方fmt 工具的标准格式，它会把优先级高的运算放一起，低的才有空格。在接触 Go 之前，我自己其实也这么干，特长的表达式，几个空格、几对括号的情况都有过。就为了阅读清晰。 有贝原名 uubee ，我在后台都写的 Ubee，是因为首字母要大写，我觉得 Uubee 又极丑无比，所以就省了 u。好在有 namespace 挡着，应该不会干扰其他人。  所以，不要觉得我是在故意刁难，为了遵循psr 规范我已经很委屈了。。\n其实说这些东西，并不是因为水平多么厉害才提，这些规范都和技术本身无关。提到的东西，也都是一路颠簸的血泪教训。谁没被自己的代码恶心过几回？\n今天这些更多的是想说为什么要好好设计你的代码，至于怎么设计，以后一点点的整理吧 ^_^\n最后 我坚信，写代码不是砌砖，不是画条线放块砖就完成任务了。奥对了，即便是砌砖工人，发现有块砖烂掉了也会毫不犹豫的扔掉，也不会以“赶工期”为由说“就这样吧，反正又不会塌”。\n","date":1474770753,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1474770753,"objectID":"7c3238a7fe0a80b2ede83a065d8e7a56","permalink":"/post/jianshu/code-review-%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/","publishdate":"2016-09-25T10:32:33+08:00","relpermalink":"/post/jianshu/code-review-%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/","section":"post","summary":"迁移自简书，格式可能未经校对。 这周也帮其他人看了看代码，发现大家对一些规范不以为然，所以我想借这个机会聊聊。代码规范的重要性说的太多了，我来","tags":["Code","Review"],"title":"Code Review 那点事儿","type":"post"},{"authors":null,"categories":["typecho"],"content":"背景 我们在以前的数学题中一定遇到过这样的问题：\nA说xxxx B说xxx C说xxx\n然后给一些条件，让你判断每个人说话的真假\n这个题目是这样的：\n 计算机学院准备组织院篮球赛，某班有ABCDE五个同学商量组队参加，他们在讨论谁来打前锋的时候发生了争执，于是他们请了另一个班的同学J当评委，五个人PK百米速度，谁的速度最快就由谁来当前锋，其实五个同学速度相当，比赛结束时，J让他们猜猜排名情况\n  A说：“E一定是第一名” B说：“我可能是第二名” C说：“A最慢” D说：“C不是最快的” E说：“D应该是第一名”    J最后说：“E肯定不是第二名或者第三名，你们几个只有获得第一名和第二名的人猜对了，你们应该知道谁最快了吧？” 编程给出五个同学的排名。\n算法 习惯了通过表达式去计算一个结果的人，很难去用枚举的思维方式来处理问题。尤其对于枚举的模型很难把握。\n枚举算法求解这类问题其实很简单，我尝试用以下三句话来说明：\n 把每个人说的话用一个逻辑表达式表示出来 枚举解空间内所有可能出现的情况 按照题中条件，筛选合法解  建立说话内容（断言）的模型 可以很容易想到，上述问题中A的内容“E是第一名”可以写成：\nScore['E'] == 1;\r 关键在于，如何描述“A说”的这个过程。很容易想到，这个过程实际上是一个从字符到表达式的映射。表达式在C语言中如何作为一个变量来使用？当然是函数指针，于是可以写出下面的代码：\nint guessA(){\rreturn Score[\u0026#39;E\u0026#39;] == 1;\r}\rint guessB(){\rreturn Score[\u0026#39;B\u0026#39;] == 2;\r}\r...\rint (*guess[256])();\t//\t定义一个函数指针的数组\rguess[\u0026#39;A\u0026#39;] = guessA;\rguess[\u0026#39;B\u0026#39;] = guessB;\r...\r这样的话，就可以用guess['A']()来表示A猜得正确与否\n枚举解空间 这个题目较为简单，5个人的排名当然有5!种情况，可以用C++提供的全排列的库实现，也可以用深搜自己实现。这里使用康托展开逆运算得到（每次计算的时间复杂度为O(1)）\n//\t生成1~n的全排列中得第k项，返回值在ret中\rint fac[]={1,1,2,6,24,120,720,5040,40320,362880};\rvoid invKT(int n, int k, int ret[]){\rk--;\rint vst[8]={0}, j;\rfor ( int i=0; i\u0026lt;n; i++){\rint t = k/fac[n-i-1];\rfor (j=1; j\u0026lt;=n; j++){\rif (!vst[j]){\rif (t==0) break;\rt--;\r}\r}\rret[i] = j;\rvst[j] = 1;\rk %= fac[n-i-1];\r}\r}\r我们可以枚举得到每次的结果：\nint score[N];\t//\tscore[i]表示(\u0026#39;A\u0026#39;+i)排第几名\rint rank[N];\t//\trank[i]表示第i名是谁\rfor ( int i=1; i\u0026lt;=fac[n]; i++) {\rinvKT(n, i, score);\rfor ( int j=0; j\u0026lt;n; j++) rank[score[i]] = \u0026#39;A\u0026#39;+i;\r}\r筛选 有了以上的准备工作，筛选就非常容易了。\n只有第一名和第二名说的正确：\nif ( guess[ rank[1] ]() == 1 \u0026amp;\u0026amp;\rguess[ rank[2] ]() == 1 \u0026amp;\u0026amp;\rguess[ rank[3] ]() == 0 \u0026amp;\u0026amp;\rguess[ rank[4] ]() == 0 \u0026amp;\u0026amp;\rguess[ rank[5] ]() == 0\r)\rE不是第二和第三：\nif ( score['E'-'A'] != 2 \u0026amp;\u0026amp; score['E'-'A'] != 3 )\r 总代码 实际的代码为了偷懒，在一些细节上跟上面的分析不太一样，仅供参考。\n#include \u0026lt;cstdio\u0026gt;\r#include \u0026lt;cstdlib\u0026gt;\r\rint score[6]; // i排第几\rint rank[6]; // 第i名是谁\r\rvoid invKT(int n, int k, int ret[]);\rint guess(int i);\rint main(){\rint n = 5;\rfor ( int i=1;i\u0026lt;=120;i++){\rinvKT(n, i, score+1);\rfor ( int j=1;j\u0026lt;=n;j++) rank[score[j]] = j;\rif (guess(rank[1]) \u0026amp;\u0026amp; guess(rank[2]) \u0026amp;\u0026amp; guess(rank[3])==0 \u0026amp;\u0026amp; guess(rank[4])==0 \u0026amp;\u0026amp; guess(rank[5])==0 \u0026amp;\u0026amp; score[5]!=2 \u0026amp;\u0026amp; score[5]!=3) {\rfor ( int j=1;j\u0026lt;=n;j++){\rprintf(\u0026#34;%c：第%d名\\n\u0026#34;, \u0026#39;A\u0026#39;+j-1, score[j]);\r}\r}\r}\rreturn 0;\r}\rint guess(int i){\rreturn (i==1)*(score[5]==1)\r|| (i==2)*(score[2]==2)\r|| (i==3)*(score[1]==5)\r|| (i==4)*(score[3]!=1)\r|| (i==5)*(score[4]==1);\r}\rint fac[]={1,1,2,6,24,120,720,5040,40320,362880};\rvoid invKT(int n, int k, int ret[]){\rk--;\rint vst[8]={0}, j;\rfor ( int i=0; i\u0026lt;n; i++){\rint t = k/fac[n-i-1];\rfor (j=1; j\u0026lt;=n; j++){\rif (!vst[j]){\rif (t==0) break;\rt--;\r}\r}\rret[i] = j;\rvst[j] = 1;\rk %= fac[n-i-1];\r}\r}\r","date":1444677300,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1444677300,"objectID":"1f5d3f3475964dc6300aa1f7f9a4513b","permalink":"/post/typecho/shui-shi-qian-feng/","publishdate":"2015-10-13T03:15:00+08:00","relpermalink":"/post/typecho/shui-shi-qian-feng/","section":"post","summary":"背景 我们在以前的数学题中一定遇到过这样的问题：\nA说xxxx B说xxx C说xxx\n然后给一些条件，让你判断每个人说话的真假\n","tags":["IT技术堆"],"title":"用程序去判断每个人说话的真假 - 写给新手的枚举介绍","type":"post"},{"authors":null,"categories":["typecho"],"content":"一直以来很想写一个自动签到的程序，因为很多免费工具网站不签到根本进行不下去。\n问题的关键在于设计一个统一的签到流程。最开始想的很简单，就是一组共享数据的请求，于是就有了第一个版本\nhttps://coding.net/u/kzzhr/p/gosigner/git\n这个程序能够完成ss的签到，但是到了v2ex却不行了。v2ex在login页面有一个用来防止csrf的token，这个token需要在页面中动态获取。\n吃个饭去。。\n","date":1444093380,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1444093380,"objectID":"ebcbc91076d6423cde70cb33e8aaa4dd","permalink":"/post/typecho/gosigner/","publishdate":"2015-10-06T09:03:00+08:00","relpermalink":"/post/typecho/gosigner/","section":"post","summary":"一直以来很想写一个自动签到的程序，因为很多免费工具网站不签到根本进行不下去。 问题的关键在于设计一个统一的签到流程。最开始想的很简单，就是一组","tags":["小玩意"],"title":"一个自动签到的程序","type":"post"},{"authors":null,"categories":["typecho"],"content":"悲剧就是善的冲突。至少，是不坏的冲突。\n因为想离职的事情跟我最敬爱的刘杰老师聊了一会人生，最后伤了老师的心。一个初来乍到的小毛孩，怎么可能跟一位长者有同样的认知。\n前辈们总是不断的分享经验告诫年轻人，而初生牛犊总要去惹一惹凶猛的老虎，人生的喜怒哀乐也尽藏于这样一代一代的循环往复中。\n我们无法得知在多年以后我们会是怎样的感叹庆幸或是哀叹遗憾。在当下，做一个疯狂的决定在自我感觉上无疑是最有价值的一瞬间。\n","date":1442132640,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1442132640,"objectID":"22ddcba62bd6e0be96ffdc73fa02c50d","permalink":"/post/typecho/beiju/","publishdate":"2015-09-13T16:24:00+08:00","relpermalink":"/post/typecho/beiju/","section":"post","summary":"悲剧就是善的冲突。至少，是不坏的冲突。 因为想离职的事情跟我最敬爱的刘杰老师聊了一会人生，最后伤了老师的心。一个初来乍到的小毛孩，怎么可能跟一","tags":["记事","随想"],"title":"悲剧","type":"post"},{"authors":null,"categories":["typecho"],"content":"先呵呵一下表示对自己的鄙视，明明不是写博的料却分要三番五次的开开开，开了又不写字。这次重开有两个基础，一是最近发现需要一个记录点点滴滴，二是发现自己确实需要一个比CSDN更自由的技术页面。所以以后的博客以这两方面为主。另外呢，阿里云提供了学生特惠，每月10块，非常感谢。\n","date":1441955340,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1441955340,"objectID":"0e65c99bd4d1d3f9a2bf33da28b38407","permalink":"/post/typecho/blogagain/","publishdate":"2015-09-11T15:09:00+08:00","relpermalink":"/post/typecho/blogagain/","section":"post","summary":"先呵呵一下表示对自己的鄙视，明明不是写博的料却分要三番五次的开开开，开了又不写字。这次重开有两个基础，一是最近发现需要一个记录点点滴滴，二是","tags":["记事","我的微博","tweet"],"title":"重开博客","type":"post"},{"authors":null,"categories":["typecho"],"content":"2015，真是倒霉。\n回家前一天，实验室一个同学没有锁好门。下午饭时实验室被窃。她的一台笔记本，一部手机，我的移动硬盘，身份证，学生证。\n在派出所搞到第二天接近中午，拿了派出所的证明到火车站取了车票（今年开始代售点必须刷学生证）\n补办身份证需要3个月，正在申请阿里云的备案又得等等了（写这篇文章的时候外网还不能访问）\n最悲剧的莫过于硬盘丢失，从高一开始将近6年的数据，全没了。其中包括很多很多个人信息譬如5年的3个G的QQ聊天记录，上万张照片有贵重的证件照还有珍贵的回忆，有无数日日夜夜积攒的代码，也有费尽精力整理的各种学习资料，各种应用软件。\n回家之后，手机连不上家里的WIFI，于是想重新刷机，忘了m2s没有SD卡，照旧使用Go备份。最后手机数据全没了。\n归零。\n","date":1423078236,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1423078236,"objectID":"cd20d00fb77589c47853aa0edec7ec0f","permalink":"/post/typecho/zero/","publishdate":"2015-02-05T03:30:36+08:00","relpermalink":"/post/typecho/zero/","section":"post","summary":"2015，真是倒霉。 回家前一天，实验室一个同学没有锁好门。下午饭时实验室被窃。她的一台笔记本，一部手机，我的移动硬盘，身份证，学生证。 在派出","tags":["记事"],"title":"归零","type":"post"},{"authors":null,"categories":["typecho"],"content":"温故不一定知新，不温故一定变傻！\n","date":1421517600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1421517600,"objectID":"1151edc73319bb422fff5918c7c47674","permalink":"/post/typecho/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/","publishdate":"2015-01-18T02:00:00+08:00","relpermalink":"/post/typecho/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/","section":"post","summary":"温故不一定知新，不温故一定变傻！","tags":["随想","我的微博","tweet"],"title":"温故而知新","type":"post"},{"authors":null,"categories":["typecho"],"content":"优秀是一种习惯！ 而不是某一时刻的水平高低！！！ 习惯！！！\n","date":1420950420,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1420950420,"objectID":"e2b5c9d8a5db08dd39b297a77fa81f19","permalink":"/post/typecho/excellence_is_habit/","publishdate":"2015-01-11T12:27:00+08:00","relpermalink":"/post/typecho/excellence_is_habit/","section":"post","summary":"优秀是一种习惯！ 而不是某一时刻的水平高低！！！ 习惯！！！","tags":["随想","我的微博","tweet"],"title":"优秀是一种习惯","type":"post"},{"authors":null,"categories":["typecho"],"content":"昨天Deepin2014.2内置了CrossOver Deepin专版，其中最大的惊喜莫过于QQ的正常使用。越来越感觉到 Deepin 才是普通 Linux 用户的未来。所以整理了一下这份资料。\n第一步：添加软件源 这一步网上可以看到很多教程，但是都是两年前的版本了，还得自己改成新的，所以这里重新整理一下\n打开 /etc/apt/sources.list，在末尾添加下面两行。\ndeb http://packages.linuxdeepin.com/deepin trusty main non-free universe\rdeb-src http://packages.linuxdeepin.com/deepin trusty main non-free universe%\r打开终端，导入密钥\nwget http://packages.linuxdeepin.com/deepin/project/deepin-keyring.gpg\rgpg --import deepin-keyring.gpg\rsudo gpg --export --armor 209088E7 | sudo apt-key add -\rsudo apt-get update\r第二步：安装深度商店及组件 sudo apt-get install deepin-software-center\rsudo apt-get install python-deepin-gsettings\r","date":1420752480,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1420752480,"objectID":"33c267eb5747884482f8ed4e353135eb","permalink":"/post/typecho/ubuntu_deepin/","publishdate":"2015-01-09T05:28:00+08:00","relpermalink":"/post/typecho/ubuntu_deepin/","section":"post","summary":"昨天Deepin2014.2内置了CrossOver Deepin专版，其中最大的惊喜莫过于QQ的正常使用。越来越感觉到 Deepin 才是普通 Linux 用户的未来。所以整理了一下这份资料。\n","tags":["IT技术堆"],"title":"xbuntu 添加 Deepin 软件源 2014.2","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 基本的抓取 import urllib content = urllib.urlopen('http://www.x.com').read() 使用代理服务器 proxy = urllib2.ProxyHandler({'http':'http://host:port'}) opener = urllib2.build_opener(proxy, urllib2.HTTPHandler) urllib2.install_opener(opener) content = urllib2.urlopen('http://www.xxxx.com').read() Cookie import urllib2, cookielib cookie = urllib2.HTTPCookieProcessor(cookielib.CookieJar()) opener = urllib2.build_opener(cookie, urllib2.HTTPHandler) urllib2.install_opener(opener) content = urllib2.urlopen('http://www.xxx.com').read() POST 数据 比如说需要向 http://www.xxx.com/post/ 接口 POST 数据 name=’liluo’, age=’21’, blog=’http://liluo.org’\n首先需要准备数据\ndata = urllib.urlencode({ 'name': 'liluo', 'age' : '21', 'blog': 'http://liluo.org' }) 然后生成并发送 HTTP 请求\nreq = urllib2.Request(url='http://www.xxx.com/post/', data=data) ret = urllib2.urlopen(req).read() 伪装成浏览器 很多网站不喜欢爬虫（比如糗事百科），发送的请求会被拒绝。这个时候我们可以用修改 HTTP headers 信息来伪装成浏览器:\nheaders = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.168 Safari/535.19' } req = urllib2.Request( url = 'http://www.xxx.com', headers = headers ) ret = urllib2.urlopen(req).read() 绕过“反盗链” 某些网站（再比如糗事百科）图片会有所谓的反盗链设置，其实就是检查 HTTP 请求的 headers 里的 referer 是否来自该网站。所以只需改下 headers:\nheaders = {'Referer': 'http://www.qiushibai.com' } req = urllib2.Request( url = 'http://qiushibaike.com/', headers = headers ) ","date":1417492800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1417492800,"objectID":"753f52b2b8f11c9dc5a0eae6129a9129","permalink":"/post/dashayu/1417492800-python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/","publishdate":"2014-12-02T12:00:00+08:00","relpermalink":"/post/dashayu/1417492800-python%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 基本的抓取 import urllib content = urllib.urlopen('http://www.x.com').read() 使用代理服务器 proxy = urllib2.ProxyHandler({'http':'http://host:port'}) opener = urllib2.build_opener(proxy, urllib2.HTTPHandler) urllib2.install_opener(opener) content = urllib2.urlopen('http://www.xxxx.com').read() Cookie import urllib2, cookielib cookie = urllib2.HTTPCookieProcessor(cookielib.CookieJar()) opener = urllib2.build_opener(cookie, urllib2.HTTPHandler) urllib2.install_opener(opener)","tags":null,"title":"python爬虫基础","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n [](#什么是tkinter)什么是Tkinter Tkinter（也叫Tk接口）是Tk图形用户界面工具包标准的Python接口。Tk是一个轻量级的跨平台图形用户界面（GUI）开发工具。Tk和Tkinter可以运行在大多数的Unix平台、Windows、和Macintosh系统。 Tkinter 由一定数量的模块组成。Tkinter位于一个名为_tkinter（较早的版本名为tkinter）的二进制模块中 。Tkinter包含了对Tk的低 级接口模块，低级接口并不会被应用级程序员直接使用，通常是一个共享库（或DLL），但是在一些情况下它也被Python解释器静态链接。 除了Tk接口模块，Tkinter也包含了一定数量的Python模块。其中两个最重要的模块是Tkinter本身和名为Tkconstants的模块。前者自动引导后者，因此使用Tkinter，你首先需要做的是导入Tkinter模块， 代码如下： import Tkinter 或 from Tkinter import *\n第一个Tkinter程序 File: hello1.py\nfrom Tkinter import * root = Tk() w = Label(root, text=\u0026quot;Hello, world!\u0026quot;) w.pack() root.mainloop() 运行结果如下： 转-Tkinter入门(一) 关闭这个窗口即可终止这个程序的运行。\n二、对代码的说明：\n我们通过导入Tkinter模块开始。Tkinter模块包含了用Tk工具包工作所需的所有的类，函数和其它一些必须的东西。在大多数情况下，你只需要简单的从Tkinter导入所有的东西到你的模块的名字空间，如下所示： from Tkinter import *\n然 后初始化Tkinter,方法是我们必须先创建一个Tk root（根）窗口部件，它是一个普通的窗口，带有标题条和其它由你的窗口管理器供给的附属。你 应该只创建一个root窗口部件，这个root窗口部件必须在其它窗口部件创建之前创建。初始化Tkinter的代码如下：\nroot = Tk() 接着我们创建一个Label（标签）窗口部件作为这个root窗口的孩子，代码如下：\nw = Label(root, text=\u0026quot;Hello, world!\u0026quot;) Label窗口部件可以显示文本、图标或图象。我们这里用text选项来指定要显示的文本。\n接下来我们在Label窗口部件上调用了pack方法，它告诉Label窗口部件去调整自己的尺寸来适应所给定文本的大小，并且使用自己可见，代码如下：\nw.pack() 但是在这些发生之前，我们必须进入Tkinter的事件循环，代码如下：\nroot.mainloop() 这 个程序将一直处在事件循环之中，直到我们关闭了这个窗口。事件循环不仅仅处理来自用户的事件（如鼠标敲击和按键按下）或者窗口系统（重绘事件和窗口配置消 息），它也处理来自Tkinter自身的工作等待队列，这些工作之一就包括由pack方法所产生的工作和显示更新。这就意味着这个应用程序窗口在进入这个 事件循环之前将不会显示出来。\n第二个Tkinter程序 当我们在写一个较大的程序的时候，把代码封装在类中通常是一个好的主意。\nFile: hello2.py\nfrom Tkinter import * class App: def __init__(self, master): frame = Frame(master) frame.pack() self.button = Button(frame, text=\u0026quot;QUIT\u0026quot;, fg=\u0026quot;red\u0026quot;, command=frame.quit) self.button.pack(side=LEFT) self.hi_there = Button(frame, text=\u0026quot;Hello\u0026quot;, command=self.say_hi) self.hi_there.pack(side=LEFT) def say_hi(self): print \u0026quot;hi there, everyone!\u0026quot; root = Tk() app = App(root) root.mainloop() 运行结果如下： 转-Tkinter入门(一) 如果你点击Hello按钮，将在控制台打印出”hi there, everyone!” 。如果你点击QUIT按钮，程序将终止。\n二、代码说明：\n这个简单的应用程序被写成了一个类。这个构造器（init 方法）通过一个父部件被调用，并针对父部件增加了一些子部件。构造器通过创建一个Frame（帧）窗口部件开始。一个帧是一个简单的容器，在这个例子中，我们仅用来容纳另外的两个部件。\nclass App: def __init__(self, master): frame = Frame(master) frame.pack() 这个帧实例被存储在一个名为Frame的局部变量中。在创建了这个部件后，我们立即调用pack方法来使用这个帧可见。\n然后我们创建两个Button（按钮）窗口部件作为这个帧的孩子。\nself.button = Button(frame, text=\u0026quot;QUIT\u0026quot;, fg=\u0026quot;red\u0026quot;, command=frame.quit) self.button.pack(side=LEFT) self.hi_there = Button(frame, text=\u0026quot;Hello\u0026quot;, command=self.say_hi) self.hi_there.pack(side=LEFT) 这次，我们传递了一定数量的选项给构造器。第一个按钮被标为”QUIT”，字为红色（fg是foreground\u0026lt;前景色\u0026gt;的缩写）。第二个被标为”Hello”。两个按钮都有一个command选项。这个选项指定了一个函数或方法，在按钮被点击时会被调用。\n按 钮实例被存储在实例属性组中。side=LEFT 参数表示这两个按钮在帧中将被分开放置；第一个按钮被放置在帧的左边缘，第二个被放在第一个的右边（帧 的左边缘仍保留着空格）。默认情况下，部件的放置都是相对于它们的父亲（frame部件相对于master，button相对于frame）。如果 side选项没指定，side默认值为TOP。\n“Hello”按钮的回调函数如下所示，它在按钮每次被按下时简单地打印一条信息给控制台：\ndef say_hi(self): print \u0026quot;hi there, everyone!\u0026quot; 最后我们提供了一些脚本级的代码来创建一个Tk root部件，和一个App类的实例（这个实例使用这个root部件作为它的父亲）：\nroot = Tk() app = App(root) root.mainloop() root.mainloop()调用root部件的mainloop方法。它进入Tk事件循环，这个应用程序将处于这个Tk事件循环之中直到quit方法被调用（点击QUIT按钮），或窗口被关闭。\n关于窗口部件引用\n在第二个例子中，frame部件被存储在一个名为frame的局部变量中，而button部件则存储在两个实例的属性组中。这是否隐藏着一个严重的问题呢：当 init 函数返回并且frame变量超出了范围会发生什么呢？。\n不 要紧；这儿确实没有必要去保持对窗口部件实例的引用。Tkinter自动维护一个窗口部件树（通过对象实例的master和children属性），因 此，当应用程序的最后一个引用消失时窗口部件不会消失；窗口部件必须显示的用destroy方法销毁。但是如果你希望在窗口部件被创建以后用它来做一些事 情，你最好保持对你自己的窗口部件实例的引用。\n注意如果你不需要保持对一个窗口部件的引用，你可以用单独的一行来创建和pack（包装）它，如下：\nButton(frame, text=\u0026quot;Hello\u0026quot;, command=self.hello).pack(side=LEFT) 不要存储这个操作的结果，当你试图去用这个结果时你会很失望（因为pack方法返回None）。为小心起见，最好将将pack（包装）分开，如下所示：\nw = Button(frame, text=\u0026quot;Hello\u0026quot;, command=self.hello) w.pack(side=LEFT) 关于窗口部件的名字\n另一个容量引起混淆的方面（尤其是使用Tcl编程Tk的有一些经验的人）是Tinter的窗口部件的名字的概念。在Tcl中，你必须显示的命名每一个窗口 部件。例如下面的Tcl命令创建一个名为ok的按钮作为名为dialog的窗口部件的孩子（dialog又是root窗口的孩子）：\nbutton .dialog.ok 相应的Tkinter调用将如下： ok = Button(dialog) 在 这个Tkinter案例中，ok和dialog是对窗口部件实例的引用，不是窗口部件实际的名字。因为Tk自身需要这些名字，Tkinter自动为每个新 窗口部件赋一个唯一的名字。在这个Tkinter案例中，这个dialog的名字或许类似”.1428748”，并且button可能 是”.1428748.1432920”。如果你希望得到一个Tkinter窗口部件的完整名字，你可以在这个窗口部件实例上使用str函数：\n\u0026gt;\u0026gt;\u0026gt; print str(ok) .1428748.1432920 如果你确实需要为一个窗口部件指定一个名字，你可以在你创建这个窗口部件时使用name选项。你这么做的原因可能是你需要和用Tcl写的代码接口。\n下面的例子将产生一个名为”.dialog.ok”的窗口部件（如果你忘了命名dialog,那么名字可能类似”.1428748.ok”）： ok = Button(dialog, name=“ok”)\n为了避免与此同时Tkinter的名字机制相冲突，不要使用只包含数字的名字。同样注意name是只能创建一次的选项；一旦你创建了这个部件的名字，那么你就不能再改变它的名字了。\n","date":1417406400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1417406400,"objectID":"cb2842362d3fe049803197189935f2c7","permalink":"/post/dashayu/1417406400-tkinter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","publishdate":"2014-12-01T12:00:00+08:00","relpermalink":"/post/dashayu/1417406400-tkinter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 [](#什么是tkinter)什么是Tkinter Tkinter（也叫Tk接口）","tags":null,"title":"Tkinter学习笔记","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n [](#资源列表：)资源列表： python  简明 Python 教程 浅显易懂，快速上手 Python快速教程 全。不过对新手会有点鸭梨 fenby 边学边练 一些可能会用到的模块 网易公开课 零基础学Python - 老齐 东西很全。缺点是太多啰嗦，基础部分适合文科生  Tkinter  易百 全面、详细、图文演示  dajango  【网易公开课】快速上手 一个下午熟悉 Dajango  博客  Sun 很详细的学习笔记 张哲的新浪博客 很全面  [](#别人整理的资源列表)别人整理的资源列表  github.com/Yixiaohan  ","date":1417060800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1417060800,"objectID":"9d5781faf092255f029b0ff94e1cfa1d","permalink":"/post/dashayu/1417060800-python%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/","publishdate":"2014-11-27T12:00:00+08:00","relpermalink":"/post/dashayu/1417060800-python%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 [](#资源列表：)资源列表： python 简明 Python 教程 浅显易懂，快速上手 Python快速教程","tags":null,"title":"python上手指南","type":"post"},{"authors":null,"categories":null,"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1416124002,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1416124002,"objectID":"40142032ecf125ecf8940c1ea220c71b","permalink":"/post/csdn/struts2-%E5%85%A5%E9%97%A8%E5%9B%BE%E8%A7%A3/","publishdate":"2014-11-16T15:46:42+08:00","relpermalink":"/post/csdn/struts2-%E5%85%A5%E9%97%A8%E5%9B%BE%E8%A7%A3/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["struts2"],"title":"struts2 入门图解","type":"post"},{"authors":null,"categories":["typecho"],"content":"以后的Js演示都放在这里啦\n","date":1415847960,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1415847960,"objectID":"9a30360fcb1d29243332476fc66ce566","permalink":"/post/typecho/h5tricks_codingapp_com/","publishdate":"2014-11-13T11:06:00+08:00","relpermalink":"/post/typecho/h5tricks_codingapp_com/","section":"post","summary":"以后的Js演示都放在这里啦","tags":["IT技术堆","我的微博","tweet"],"title":"JS动画","type":"post"},{"authors":null,"categories":["typecho"],"content":"【大清相国】火车上一口气地把《大清相国》读完了。王岐山推荐的书，果然不一般。以往我们看广场小说都写的多么多么黑，且结局一定悲催地发人深省。但是这本书看完了最直观的感受就是对陈廷敬的膜拜。官场辗转多年依然亭亭独立的真不多见。回来后忍不住把康熙王朝又看了一遍，最大的收货就是开始思考趋利避害，对人对事。以往我都是因一弊而舍全身，现在看看人家感觉太厉害了！\n","date":1415430540,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1415430540,"objectID":"22be4ca1daef9fe1d0d5964d550f4062","permalink":"/post/typecho/chentingjing/","publishdate":"2014-11-08T15:09:00+08:00","relpermalink":"/post/typecho/chentingjing/","section":"post","summary":"【大清相国】火车上一口气地把《大清相国》读完了。王岐山推荐的书，果然不一般。以往我们看广场小说都写的多么多么黑，且结局一定悲催地发人深省。但","tags":["随想","读书","tweet"],"title":"大清相国","type":"post"},{"authors":null,"categories":["typecho"],"content":"请到演示地址里进行拖动鼠标吧！\n本来是想看看做一个跟随鼠标的时钟有多复杂，后来就觉得可以尝试做一个图案心，一定特别漂亮。\n关于心形的方程可以在Matrix67的博客里看到，里面有各种复杂的情况，但是对于js而言，太复杂了。于是找了取巧的办法，就是把一个椭圆过中心斜着切一刀，把一半图案反转就可以得到一个近似的心。\n椭圆很容易得到，把一个圆一边压缩就可以了，圆更容易得到，可以通过极坐标方便计算。\n","date":1413162960,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1413162960,"objectID":"581abeb6e62d6b2f537dfd86193805a0","permalink":"/post/typecho/mouseheart/","publishdate":"2014-10-13T09:16:00+08:00","relpermalink":"/post/typecho/mouseheart/","section":"post","summary":"请到演示地址里进行拖动鼠标吧！ 本来是想看看做一个跟随鼠标的时钟有多复杂，后来就觉得可以尝试做一个图案心，一定特别漂亮。 关于心形的方程可以在M","tags":["小玩意"],"title":"一个跟随鼠标变换的心形图案","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n using namespace std;\nconst int INF = 999999999; const double eps = 1e-6;\nint T,I,n,m,t; LL tt, sum; int a[1111]; int f[1111]; int dp[888][888]; char s[888]; char ans[888]; char ss[888];\nint so(int v){ if (a[v] == v ) return 1; int t = a[v]; int res = 1; while (t!=v){ t = a[t]; res++; } return res; }\nint too(int v,int k){ for (int i(1);i\u0026lt;=k;i++){ v = a[v]; } return v; }\nint main(){ while ( fgets(ss, INF, stdin) ) { sscanf(ss, \u0026ldquo;%d%d\u0026rdquo;,\u0026amp;n,\u0026amp;m); if (n==0 \u0026amp;\u0026amp; m==0) break;\n fgets(ss, INF, stdin); char *p = strtok(ss, \u0026quot; \u0026quot;); for (int i(1);i\u0026amp;lt;=n;i++) { sscanf(p, \u0026quot;%d\u0026quot;, \u0026amp;amp;a[i]); p = strtok(NULL, \u0026quot; \u0026quot;); f[i] = 0; } for (int i(1);i\u0026amp;lt;=n;i++) { f[i] = so(i); } fgets(s+1, INF, stdin); for ( int i(1); i\u0026amp;lt;=n; i++) { ans[too(i, m%f[i] )] = s[i]; } ans[n+1] = 0; printf(\u0026quot;%s\\n\u0026quot;,ans+1); } return 0;  } int to(int v, int w){ while( w\u0026ndash; ) v = a[v]; return v; }\nint main(){ while( EOF != scanf(\u0026quot;%d %d\\n\u0026rdquo;, \u0026amp;n, \u0026amp;m) ){ if( !n \u0026amp;\u0026amp; !m ) break; //getchar(); for(int i=1; i\u0026lt;=n; i++) cin\u0026gt;\u0026gt;a[i];//scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;a[i]), getchar(); cin.getline(s+1, MAXN); cin.getline(s+1, MAXN); for(int i=1; i\u0026lt;=n; i++) if( a[i]==i ) f[i] = 1; else{ int t=a[i], cnt=1; while( t!=i ) t=a[t], cnt++; f[i] = cnt; } for(int i=1; i\u0026lt;=n; i++) ans[ to(i, m%f[i]) ] = s[i]; ans[n+1] = 0; cout\u0026lt;\u0026lt;ans+1\u0026lt;\u0026lt;endl; } return 0; } ","date":1412734171,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1412734171,"objectID":"aefa5e63edd7985c72c21e859c1a26a4","permalink":"/post/csdn/usc-1329-decode-%E5%9D%91%E5%9D%91%E5%9D%91gets/","publishdate":"2014-10-08T10:09:31+08:00","relpermalink":"/post/csdn/usc-1329-decode-%E5%9D%91%E5%9D%91%E5%9D%91gets/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 using namespace std; const int INF = 999999999; const double eps = 1e-6; int T,I,n,m,t; LL tt, sum; int a[1111]; int f[1111]; int dp[888][888]; char s[888]; char ans[888]; char ss[888]; int so(int v){ if (a[v] == v ) return 1; int t = a[v]; int res = 1; while (t!=v){","tags":["USC"],"title":"USC 1329 Decode 坑坑坑gets","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n const int INF = 0x3fffffff; const double eps = 1e-6;\nstruct NODE{ int a,b,c; NODE(){} NODE(int x,int y,int z): a(x),b(y),c(z) {} }a[111];\nbool cmp(NODE a,NODE b){ if (a.a==b.a) return a.b\u0026lt;b.b; return a.a\u0026lt;b.a; } int d[111];\nint I,T,n,m;\nint main(){ freopen(\u0026ldquo;in.txt\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); while ( scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;n) \u0026amp;\u0026amp; n){ for ( int i(0); i\u0026lt;n; i++) { int a1,b1,c1; scanf(\u0026quot;%d%d%d\u0026rdquo;,\u0026amp;a1, \u0026amp;b1, \u0026amp;c1); if (b1\u0026lt;a1) swap(a1,b1); if (c1\u0026lt;b1) swap(b1,c1); if (b1\u0026lt;a1) swap(a1,b1); // printf(\u0026quot;%d,%d,%d\\n\u0026rdquo;,a1,b1,c1); a[i3+1]=NODE(a1,b1,c1); a[i3+2]=NODE(a1,c1,b1); a[i3+3]=NODE(b1,c1,a1); } n=3; sort(a+1,a+n+1,cmp); memset(d, 0, sizeof(d)); int ans = 0; for ( int i(1); i\u0026lt;=n; i++) { d[i] = a[i].c; for ( int j(1); j\u0026lt;i; j++) { if (a[j].a\u0026lt;a[i].a \u0026amp;\u0026amp; a[j].b\u0026lt;a[i].b \u0026amp;\u0026amp; d[j]+a[i].c\u0026gt;d[i]){ d[i] = d[j] + a[i].c; } } ans = max(ans, d[i]); }\n printf(\u0026quot;Case %d: maximum height = %d\\n\u0026quot;, ++I, ans); } return 0;  }","date":1412068825,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1412068825,"objectID":"344736ce41b9eb83b0c98dd7460d7f62","permalink":"/post/csdn/uva-437-the-tower-of-babylon/","publishdate":"2014-09-30T17:20:25+08:00","relpermalink":"/post/csdn/uva-437-the-tower-of-babylon/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 const int INF = 0x3fffffff; const double eps = 1e-6; struct NODE{ int a,b,c; NODE(){} NODE(int x,int y,int z): a(x),b(y),c(z) {} }a[111]; bool cmp(NODE a,NODE b){ if (a.a==b.a) return a.b\u0026lt;b.b; return a.a\u0026lt;b.a; } int d[111]; int I,T,n,m; int main(){ freopen(\u0026ldquo;in.txt\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); while ( scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;n) \u0026amp;\u0026amp; n){ for ( int i(0); i\u0026lt;n;","tags":["UVa","Algorithm","ACM"],"title":"UVa 437 The Tower of Babylon","type":"post"},{"authors":null,"categories":["typecho"],"content":"突然觉得《The Road Not Taken》跟王国维先生的《三境界》有点像\n","date":1409250000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1409250000,"objectID":"a908c097b1b714ec2468b0fc081a4177","permalink":"/post/typecho/road_not_taken_vs_sanjingjie/","publishdate":"2014-08-29T02:20:00+08:00","relpermalink":"/post/typecho/road_not_taken_vs_sanjingjie/","section":"post","summary":"突然觉得《The Road Not Taken》跟王国维先生的《三境界》有点像","tags":["随想","读书","我的微博","tweet"],"title":"RoadNotTaken And 三境界","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n int sz[333]; int fa[333]; bool ok[333]; // 数据中使用到的单词 int n, T;\nint getfa(int v) { if ( fa[v] == v ) return v; return fa[v] = getfa(fa[v]); }\nvoid init() { memset(ok, 0, sizeof(ok)); memset(sz, 0, sizeof(sz)); cin \u0026gt;\u0026gt; n; string a; for ( int i(\u0026lsquo;a\u0026rsquo;); i \u0026lt;= \u0026lsquo;z\u0026rsquo;; i++) fa[i] = i; for ( int i(1); i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a; int x = a[0], y = a[a.size() - 1]; fa[getfa(x)] = getfa(y); ok[x] = ok[y] = true; sz[x]++; sz[y]\u0026ndash;; } }\nbool check() { int tf = 0 , i; for ( i = \u0026lsquo;a\u0026rsquo;; i \u0026lt;= \u0026lsquo;z\u0026rsquo;; i++) { if (ok[i]) { if ( !tf ) tf = getfa(i); else if ( getfa(i) != tf ) return false; // 不连通 } }\nint c1 = 0, c2 = 0; for ( int i('a'); i \u0026amp;lt;= 'z'; i++) { if (!ok[i]) continue; if ( sz[i] == 0 ) continue; else if ( sz[i] == 1 ) c1++; else if ( sz[i] == -1) c2++; else return false;\t// 其它乱七八糟的情况 比如 ab ab out[a]=2 in[b]=2 } if ( (c1 == 1 \u0026amp;amp;\u0026amp;amp; c2 == 1) || (c1 == 0 \u0026amp;amp;\u0026amp;amp; c2 == 0) ) // 单向路径 or 回路 return true; else return false;  }\nint main() { freopen(\u0026ldquo;in.txt\u0026rdquo;, \u0026ldquo;r\u0026rdquo;, stdin); for ( cin \u0026gt;\u0026gt; T; T\u0026ndash;; ) { init(); if (check()) cout \u0026lt;\u0026lt; \u0026ldquo;Ordering is possible.\u0026rdquo; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026ldquo;The door cannot be opened.\u0026rdquo; \u0026lt;\u0026lt; endl; } }int in[333], out[333]; int fa[333]; bool ok[333]; // 数据中使用到的单词 int n, T;\nint getfa(int v) { if ( fa[v] == v ) return v; return fa[v] = getfa(fa[v]); }\nvoid init() { memset(ok, 0, sizeof(ok)); memset(in, 0, sizeof(in)); memset(out, 0, sizeof(out)); cin \u0026gt;\u0026gt; n; string a; for ( int i(\u0026lsquo;a\u0026rsquo;); i \u0026lt;= \u0026lsquo;z\u0026rsquo;; i++) fa[i] = i; for ( int i(1); i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a; int x = a[0], y = a[a.size() - 1]; fa[getfa(x)] = getfa(y); ok[x] = ok[y] = true; out[x]++; in[y]++; } }\nbool check() { int tf = 0 , i; for ( i = \u0026lsquo;a\u0026rsquo;; i \u0026lt;= \u0026lsquo;z\u0026rsquo;; i++) { if (ok[i]) { if ( !tf ) tf = getfa(i); else if ( getfa(i) != tf ) return false; // 不连通 } }\nint c1 = 0, c2 = 0; for ( int i('a'); i \u0026amp;lt;= 'z'; i++) { if (!ok[i]) continue; if ( in[i] == out[i] ) continue; else if ( in[i] - out[i] == 1 ) c1++; else if ( in[i] - out[i] == -1) c2++; else return false; //else {printf(\u0026quot;%d%d\\n\u0026quot;,in[i],out[i]);return false;} // 其它乱七八糟的情况 } if ( (c1 == 1 \u0026amp;amp;\u0026amp;amp; c2 == 1) || (c1 == 0 \u0026amp;amp;\u0026amp;amp; c2 == 0) ) // 单向路径 or 回路 return true; else return false;  }\nint main() { //freopen(\u0026ldquo;in.txt\u0026rdquo;, \u0026ldquo;r\u0026rdquo;, stdin); for ( cin \u0026gt;\u0026gt; T; T\u0026ndash;; ) { init(); if (check()) cout \u0026lt;\u0026lt; \u0026ldquo;Ordering is possible.\u0026rdquo; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026ldquo;The door cannot be opened.\u0026rdquo; \u0026lt;\u0026lt; endl; } }","date":1408020898,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1408020898,"objectID":"49d9d7f4184d4c2dd5d5b53eaea84171","permalink":"/post/csdn/uva-10129-play-on-words/","publishdate":"2014-08-14T20:54:58+08:00","relpermalink":"/post/csdn/uva-10129-play-on-words/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 int sz[333]; int fa[333]; bool ok[333]; // 数据中使用到的单词 int n, T; int getfa(int v) { if ( fa[v] == v ) return v; return fa[v] = getfa(fa[v]); } void init() { memset(ok, 0, sizeof(ok)); memset(sz, 0, sizeof(sz)); cin \u0026gt;\u0026gt; n; string a;","tags":["UVa","Algorithm","ACM"],"title":"UVa 10129 Play on Words","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1405923412,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1405923412,"objectID":"eae0856c7b96e4855a7c3ef84b074043","permalink":"/post/csdn/ubuntu-%E5%AE%89%E8%A3%85-wps.deb/","publishdate":"2014-07-21T14:16:52+08:00","relpermalink":"/post/csdn/ubuntu-%E5%AE%89%E8%A3%85-wps.deb/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["ubuntu"],"title":"ubuntu 安装 wps.deb","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  int s =a[6]+a[5]+a[4]; // a5 if (a[5]*11 \u0026amp;gt;= a[1]) a[1] = 0; else a[1] -= a[5]*11; // a4 for ( int i(1);i\u0026amp;lt;=a[4];i++){ t = push(20,2,5); if (t) t = push(t,1,t); } // a3 s += a[3] / 4;\t// 整装3 a[3] %= 4; if (a[3]){\t//\t剩下的空间分情况装2 t = 36 - a[3]*9; if ( a[3] == 1 ) t = push(t,2,5); if ( a[3] == 2 ) t = push(t,2,3); if ( a[3] == 3 ) t = push(t,2,1); if (t) t = push(t,1,t);\t//\t剩下的空间都装1 s++; } // a2 s += a[2] / 9; a[2] %= 9; if (a[2]){ t = 36 - a[2] * 4; t = push(t,1,t); s++; } // a1 s += a[1] / 36; a[1] %= 36; if (a[1]) s++; cout \u0026amp;lt;\u0026amp;lt; s \u0026amp;lt;\u0026amp;lt; endl; } return 0;  } ","date":1405680694,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1405680694,"objectID":"3e02cbe019ddeddd08541caff6006591","permalink":"/post/csdn/poj-1017-packets-%E6%82%BC%E5%BF%B5%E6%AD%BB%E5%8E%BB%E7%9A%84%E6%A8%A1%E6%8B%9F/","publishdate":"2014-07-18T18:51:34+08:00","relpermalink":"/post/csdn/poj-1017-packets-%E6%82%BC%E5%BF%B5%E6%AD%BB%E5%8E%BB%E7%9A%84%E6%A8%A1%E6%8B%9F/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 int s =a[6]+a[5]+a[4]; // a5 if (a[5]*11 \u0026amp;gt;= a[1]) a[1] = 0; else a[1] -= a[5]*11; // a4 for ( int i(1);i\u0026amp;lt;=a[4];i++){ t = push(20,2,5); if (t) t = push(t,1,t); } // a3 s += a[3] / 4; // 整装3 a[3] %= 4; if (a[3]){ // 剩下","tags":["POJ","Algorithm","ACM"],"title":"POJ 1017 Packets 悼念死去的模拟","type":"post"},{"authors":null,"categories":["typecho"],"content":"看围棋抢边界: 不愿费劲冒险只能就此game over, 冒险进击才有可能有收获.\n生命便是如此，很多时候我们或懒惰或畏惧，以至于我们没有向前哪怕迈出一步，其结果是我们永永远远地都停留在那个地方。\n有时候，我们鼓起勇气，往前迈出了哪怕一丁点的距离，多年后回首发现，那其实是你人生中至关重要的一大步。\n常人安于故习，学者溺于所闻。\n如是而已。\n共勉。\n","date":1404849060,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1404849060,"objectID":"9da0450a010075f6d8ec2cbd1b88a585","permalink":"/post/typecho/chess_game_over/","publishdate":"2014-07-09T03:51:00+08:00","relpermalink":"/post/typecho/chess_game_over/","section":"post","summary":"看围棋抢边界: 不愿费劲冒险只能就此game over, 冒险进击才有可能有收获. 生命便是如此，很多时候我们或懒惰或畏惧，以至于我们没有向前哪怕迈出一步，","tags":["随想"],"title":"围棋·变·生命","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 这篇文章有三个标签LXMP``Go``HUSTOJ，在我接管服务器以前，这三个东西我是一个也不知道的，靠着自己的不懈折腾，时隔大半年，收获颇丰。今夜不眠，拿出来聊聊。\n[](#lamp)LAMP 这是HUSTOJ的原始架构，我接管服务器的第一件事就是一周内搭好oj，那一周我是在机房没日没夜的呆了几天，终于把我们自己的oj给架起来了。\nLinux 如果真的要找基础，就是大一下蹭在KDE下生活过三个月，后来移居OSX但是敲命令的习惯还是保留了下来。以至于至今没怎么好好的用过Windows！\n在最开始，很多人给我的建议就是鸟哥的私房菜，天哪这么厚一本书我怎么可能几天内看完！所以在最开始的时候其实很简单，需要什么了就去百度就去Google，查不到的就去问各路大神了。由于迁居OSX导致一直没有踏踏实实地下来学习过Linux，导致今日依旧小白一个。\nApache 最早接触这些东西是当年看哈佛的计算机公开课时提到的XAMPP，然后一直用了它很久包括使用Linux时在本地学HTML5依旧用得它。所以在这个时候格外吃力，都是去百度Apache如何修改网站位置``Apache如何添加子域名之类白痴之极的问题，也曾立志去研习Apache配置详解，后来由于你们猜得到的原因就没怎么碰过了。\n在Linux下最喜欢的命令就是apt-get，特别喜欢update和upgrade的感觉。我曾两次upgrade服务器，第一次出现了小问题一个下午搞定了，第二次依旧手贱，结果把HUSTOJ的Judged搞坏了，边被吐槽边修复了两三天（当时正值计算机学院在OJ上做算法作业！）深感无力回天，不得已拿Go重写了Judged。由于积累了数天的重判任务于是就把判题端开到了十进程。。两三天的调试，至今运行良好。\nMySQL 其实对MySQL的熟悉完全是嘴表层最表层的，没有系统学过数据库理论，甚至连SQL语法都没怎么学过，同样是遇到一个问题就去白痴地问一次。开发oj时几乎也都是copy-paste照猫画虎过来的。后来学Go时认识了orm这类东西，从此对SQL再没有去看了。早上看到一篇程序员等级，最低级的被成为CRUD程序员，我估计我连这些都不算够格。\nPHP PHP在这些东西是最早接触的，曾在w3school上看过，但是由于上述知识的匮乏，其实跟没学一样（曾一度去琢磨php和js该学哪个），\n开发oj时真正要用php了那个时候一般我改一句代码oj就会挂一次，经常被问得就是今天oj我怎么上着上着就上不去了过一会又好了！？``你是在作死！！！等等之类的。\n庆幸毕竟是有压力在身上，学对PHP还是学了点。也认识了很多，从语法灵活度来说PHP是多么简单的语言，但是在语法组织上你会觉得这是让人烦到死的东西。由于是Python``Ruby``Go 等极简语法语言的崛起。\n[](#go)Go 我为什么会走上Go说来完全是打发寂寞，于是我就去网上看世界上有哪些语言，先被python``ruby 这类轻巧的语言所吸引，又因为速度的传言转到了NodeJS，暑假期间蹭用HTML5写过一个游戏，我感觉到了JS在某些方面的力不从心（当然一定是有解的只是感觉不那么优雅）。后来意外看到了Go语言并被它深深地吸引。\n 意外的是我的两个朋友哈工大的光光和电子科大的42大神都开始学Go。回过头看那个时候正是一些东西在国内迅猛发展的时期，Astaxie、UnKnwon等大神开始大力推广Go，MongoDB当时还算最火的，当时SSDB貌似还没出来的说。当时我周围的学长们大多都不知道这是些什么玩意。\n  在那个时候几列火车从我身边高速驶过，我不知道我是否属于这些列车，但是我知道，这些列车都将开往未来。  [](#nginx)Nginx 由于某些历史原因使得我成了在很多方面有强迫症的人，很多方面都试图用最好的且不惜成本，浏览器、编辑器、播放器甚至输入法、日历等几乎所有类型的工具我都要做个横向对比找出最顺手的。\n服务器软件也不例外，不知道被谁忽悠了Nginx远远优于Apache。下定决心要进入Nginx的世界，从LNMP的搭建、配置这些基本的学起，到后来需要高级功能时已不再使用Apache，后来学了Go，对pass``rewrite要求多了就再没离开过Nginx了。但是说时候这个环境比LAMP复杂多了大概最开始的几次每次都出小问题，多配几次才可以顺利地搞下来。\n[](#hustoj)HUSTOJ HUSTOJ的代码写得极其简单随意，像我这种没有软件工程基础的人大概花了不到一天的功夫就搞懂了它的大概框架，改起来自然也是得心应手，越来后来一些问题也越来越明显：\n  代码清晰度有待提高，大框架简单，细节上自然要复杂多了。\n 在做二次开发时每次的思路的很简单，但工作量甚大，譬如user改一个字段，你就得把所有select了user的页面代码全部修改，还得边改边调试。\n   从这几方面来讲随着需求越来越高，一直二次开发下去是个很不明智的做法，所以有必要规划一套适合各种复杂情况的在线编程学习平台。\n庆幸我正好在学Go。\n如果把HUSTOJ分为三块，Web``Judged``Judge_client。前两部分基本已经用Go重写。其中Judged已经在服务器上正常使用半年，目前运行良好。\n[](#最后)最后 之前在做OJ的时候我就考虑一个问题，如果要比做OJ，那我永远做不过杭电，结合自己的教育梦，我希望能一步一步打造一个在线编程教育平台。\n","date":1404273600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1404273600,"objectID":"ed93c40ed901cd174ea8cb852e9fda2b","permalink":"/post/dashayu/1404273600-cs203%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/","publishdate":"2014-07-02T12:00:00+08:00","relpermalink":"/post/dashayu/1404273600-cs203%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 这篇文章有三个标签LXMP``Go``HUSTOJ，在我接管服务器以前，这三个东","tags":null,"title":"cs203的那点事儿","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 网络服务 查看端口占用\n","date":1404187200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1404187200,"objectID":"7bcdbc0dfa5932d06a5928ab3a50acbe","permalink":"/post/dashayu/1404187200-mac-tips/","publishdate":"2014-07-01T12:00:00+08:00","relpermalink":"/post/dashayu/1404187200-mac-tips/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 网络服务 查看端口占用","tags":null,"title":"Mac - tips","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 爱生活，爱思考\n[](#兴趣爱好)兴趣爱好  编程技术  程序设计 服务端开发 前段折腾 嵌入式探索    [](#社交网络)社交网络  Weibo Facebook Github Coding.net  [](#献丑集)献丑集 2011  KJO：基于vs2010的OI题库管理系统。这是高一时第一次在无人指导下完成的作品。 《*r*m*ife》：不忍直视的3D动画  2012  康杰中学3D模型：3DsMAX建模学习 坦克大战游戏：HTML5初体验  2013  ArmGo：通过设计程序指令来控制机械臂。基于HTML5，参照cargo-bot [uscoj]()：基于HUSTOJ二次开发的在线评测系统。纯属为了交差 uoj：基于beego的在线程序评测系统，原想重写OJ，结果。。已残废  2014  [博客前段]()：前段练习 ztalk：精简结构却不失强大的论坛系统，主要是为了练习beego，为 xxx 打基础 zqn: 简单好用的七牛Go库  ","date":1404100800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1404100800,"objectID":"99c6bc396ff33beaea3ec7522b6601c8","permalink":"/post/dashayu/1404100800-about-me/","publishdate":"2014-06-30T12:00:00+08:00","relpermalink":"/post/dashayu/1404100800-about-me/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 爱生活，爱思考 [](#兴趣爱好)兴趣爱好 编程技术 程序设计 服务端开发 前段折腾 嵌入式","tags":null,"title":"About Me","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 既然来了，就说说为什么来吧。\n今天是个比较兴奋地日子，因为我的新显示器（AOC LV242WEM）终于到了，一下子就喜欢上了新屏幕，敞亮、饱和、逼真、鲜艳，反正就是棒极了！\n稀里糊涂就想试试拿 gor 在 github.io 上搭个博客了，说实话阿里的服务器即将到期没有资本也木有必要去续费。github.io 却看起来可以永存。\n[](#使用几分钟后)使用几分钟后 从 gor 的使用到github.io，到各种配置，官网都有很详细的说明我就不再赘述了。也可以看我的第一篇\nDISQUS广告 拿到这个博客你首先得干的第一件事应该就是去除评论框该死的广告！在widgets/comments/config.yml里，把short_name改成你自己的，如果没有怎么办？可以选择去建一个（也可以有一个快速去广告的办法就是乱加几个字母，这样首先就没有广告了），建的时候有一大堆对勾要选注意其中有一个发现，果断去掉。然后更新short_name就ok了\n换成多说评论框 多说是在国内用的还算比较多的一个，所以把disqus替换成多说也是个很好的想法，置于怎么替换，下次再说。。\n[](#题外话)题外话 MacDown 这是一个看起来特别棒的markdown编辑器，堪比CMD Markdown但是看起来不是偏离Markdown那么离谱。但是只支持Mac平台。\n好了该说说这个博客要干嘛了。由于在github上，所以考虑还是技术为主吧。如果搞得还行，把抽风系列挂过来也不错~\n就这样了，还得睡觉。\n","date":1404100800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1404100800,"objectID":"172f9889fc2365122540446b0e869e6d","permalink":"/post/dashayu/1404100800-hello-gor/","publishdate":"2014-06-30T12:00:00+08:00","relpermalink":"/post/dashayu/1404100800-hello-gor/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 既然来了，就说说为什么来吧。 今天是个比较兴奋地日子，因为我的新显示器（AOC LV","tags":["gor","disqus"],"title":"hello, gor","type":"post"},{"authors":null,"categories":["typecho"],"content":"花了两天时间看完《春秋五霸》《战国七雄》，不同于各种一家之言的是，李山教授尽可能地全面讲述历史，在过程中会把各家观点都摆出来做简单地对比，更加全面、客观地理解这个灿烂的时期。\n人物分类  这里并不是要列出所有人物，只是列出一些性格鲜明的人来简单研究  德才兼备 晋文公、楚庄王、管仲、孙叔敖\n毫无疑问，德才兼备是多么优秀的品质。这类君王可以富国强兵，名垂千古。而这类臣子可以建功立业，更重要的权倾朝野却无人嫉妒。\n相比之下，吴起、商鞅等功业千秋却没落得好下场的人也发人深省。（当然简单的治国跟变法还是有很大的不同，我们应当予以认同）。\n有才无德 赵武灵王、齐闵王、庞涓、魏冉、白起、范雎\n这类人大多争议颇多、褒贬不一。很多时候我们可能更多地有一种遗憾。这类人大多都曾经辉煌一时但最后都没得什么好下场。上述两个君王一个抽筋而死一个被活活饿死不可谓可怜。而这些能臣名将大多都有些自己的脾气，在权倾一时之际忘记自己身份，把个人意志置于国家利益之上最终不得好死，也没落得什么好名声。\n有德少才 齐桓公、宋襄公、秦穆公、魏文侯\n只找出四个君主，不过想想也是，没有本事的人也做不了什么大臣，从这个方面来说，贴上“无才”的标签确实有点刻薄。但是客观的跟有才的君王做对比还是能看出一些不同。最明显的就是对贤人的依赖，比如当齐桓公没了管仲之后，齐国再也折腾不起来了。但是整体而言，这四个君王在整个历史上都算的上是一代明主。\n无德无才 赵括\n就列了这么一个，跟上面的原因类似。没本事的人能一下统兵四十万简直不能再幸运。这种人当政给国家带来的影响算是灾难性的。如果不是后来出了个李牧，可能赵国早都被戎狄给吃掉了。\n随便扯一扯 关于权臣 这个似乎是不可避免的问题：国家统一是个浩大的工程，必然要用贤，而用贤必然要重赏，而重赏必然会直接导致私人势力的崛起，然后就开始闹事，国家要处理这个事情，必然要再用其他的贤，然后再赏···就陷入了死循环。看起来似乎是个必然事件。\n秦国是极少出现这类事件的国家，但是秦国的大多宰相下场都很惨。于是乎让人想到了如果把事情都外包出去，乙方做完了事情就跟甲方没啥关系了，是不是就能避免本土势力的积累。当然用相这里毕竟有一点点像是一个卖方市场，找不到那么多人当宰相。人才哪是随随便便说来就来的。\n最后 附录 这里想列一些相关的东西\n  大秦帝国\n  看的时候做的简单的笔记 春秋五霸 战国七雄\n ","date":1402734540,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1402734540,"objectID":"3cd35df937153c6b2aa5e8d4f99d23cb","permalink":"/post/typecho/cqzg/","publishdate":"2014-06-14T16:29:00+08:00","relpermalink":"/post/typecho/cqzg/","section":"post","summary":"花了两天时间看完《春秋五霸》《战国七雄》，不同于各种一家之言的是，李山教授尽可能地全面讲述历史，在过程中会把各家观点都摆出来做简单地对比，更加全面、客观地理解这个灿烂的时期。\n","tags":["随想","影视"],"title":"百家讲坛《春秋五霸》《战国七雄》感悟","type":"post"},{"authors":null,"categories":["typecho"],"content":"才得知云云关门了。翻到一年前随便写的一篇云云的体验，没有回复。http://t.cn/zTU8GF7\n往常写点东西吐个槽提个建议，多多少少会的得到官方的回复。用户的声音都被无视，很难想象在团队内部是如何对待队友的意见。\n","date":1402057260,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1402057260,"objectID":"d84ebdd11114e2fec6e2bc5043421549","permalink":"/post/typecho/57-%E4%BA%91%E4%BA%91%E4%BA%8C%E4%B8%89/","publishdate":"2014-06-06T20:21:00+08:00","relpermalink":"/post/typecho/57-%E4%BA%91%E4%BA%91%E4%BA%8C%E4%B8%89/","section":"post","summary":"才得知云云关门了。翻到一年前随便写的一篇云云的体验，没有回复。http://t.cn/zTU8GF7 往常写点东西吐个槽提个建议，多多少少会的","tags":["互联网"],"title":"云云二三","type":"post"},{"authors":null,"categories":["typecho"],"content":"以下所有命令基于 ubuntu12.04 系统。centos、rhel 慎重\n系统环境 grub修复 linux改为主引导\n之前装mac时把引导毁掉了，pe只能修复win引导。linux引导还得自己再修复。\nliveCD（我直接用的烧在U盘的ubuntu试用）。\n# fdisk -l # mount /dev/sdaX /mnt # mount /dev/sdaY /mnt/boot #如果有单独boot分区 # grub-install --root-directory=/mnt /dev/sda # init 6 重启之后就ok了～\n过程中出现了warning 。不用管，重启没有问题。\ngrub添加到windows下 主要目的是兼顾mac\n在装linux 的时候，可以把grub安装在linux磁盘/sdaX，然后在win下用easyBCD把grub添加到win下，这样在一个引导下就可以选择三个系统。\n不启动桌面环境 首先在 /etc/default/grub 里添加\n然后 sudo update-grub\n用户相关 添加用户 # useradd\r# adduser #会自动创建目录\r添加 sudoers # vim /etc/sudoers\ruser All=(All) NOPASSWD: ALL\r%admin\tALL=(ALL) NOPASSWD: ALL\r服务器环境 修改主机名/机器名 首选修改 /etc/hostname 和 /etc/hosts 文件对应的机器名\n然后 hostname NAME\n查看端口占用 $ netstat -tunpl\r添加ssh免密码登陆 网上教程一大堆，坑在了权限\nsudo chmod 700 ~/.ssh\rsudo chmod 644 ~/.ssh/authorized_keys\rsudo chmod 600 ~/.ssh/id_rsa.pub\r","date":1401955800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1401955800,"objectID":"f22bd67bf5f6aad6f98d02f531126b6c","permalink":"/post/typecho/19-linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","publishdate":"2014-06-05T16:10:00+08:00","relpermalink":"/post/typecho/19-linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"post","summary":"以下所有命令基于 ubuntu12.04 系统。centos、rhel 慎重\n","tags":["IT技术堆"],"title":"Linux学习笔记","type":"post"},{"authors":null,"categories":["typecho"],"content":"突然想到一条为什么fb衰落的如此之快的原因？暂且跟 Google 比一下，google 起家靠的是技术，fb 起家考的是产品形态；google 的核心竞争力是信息交流，是刚需，fb 的核心竞争力是吐槽场所，弹性很大。玩的是新颖，如果不时时刻刻去调整，很容易被大众抛弃\n","date":1401839880,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1401839880,"objectID":"f440fc101e84fb14b5c5b0e86158dcdd","permalink":"/post/typecho/f_b_g_o_o_g_l_e/","publishdate":"2014-06-04T07:58:00+08:00","relpermalink":"/post/typecho/f_b_g_o_o_g_l_e/","section":"post","summary":"突然想到一条为什么fb衰落的如此之快的原因？暂且跟 Google 比一下，google 起家靠的是技术，fb 起家考的是产品形态；google 的核心竞争力是信","tags":["互联网","tweet"],"title":"fbvsGg","type":"post"},{"authors":null,"categories":["typecho"],"content":"团购的立足点到底是帮用户省钱还是帮商家处理产能过剩？http://t.cn/RvIHX26\n","date":1401837300,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1401837300,"objectID":"0b87591f626b7e60ee829f748872290a","permalink":"/post/typecho/meituan/","publishdate":"2014-06-04T07:15:00+08:00","relpermalink":"/post/typecho/meituan/","section":"post","summary":"团购的立足点到底是帮用户省钱还是帮商家处理产能过剩？http://t.cn/RvIHX26","tags":["互联网","我的微博","tweet"],"title":"团购何来","type":"post"},{"authors":null,"categories":["typecho"],"content":"十多年前互联网兴起的时候，这个炒那个炒，然后炒出了一堆泡沫。十年过去，移动互联网兴起，浮躁的90后们也按耐不住了。随便翻开一家科技媒体，都有一大堆两千年前就有了的“新概念”，每个新概念之后都是一大波创业浪潮。\n","date":1397087940,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1397087940,"objectID":"680fa7f310677c3c0b710e7c756c7ef0","permalink":"/post/typecho/paomo/","publishdate":"2014-04-10T07:59:00+08:00","relpermalink":"/post/typecho/paomo/","section":"post","summary":"十多年前互联网兴起的时候，这个炒那个炒，然后炒出了一堆泡沫。十年过去，移动互联网兴起，浮躁的90后们也按耐不住了。随便翻开一家科技媒体，都有","tags":["互联网","我的微博","tweet"],"title":"泡沫","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n void setup() { for ( int i(_r); i \u0026lt;= 12; i++) pinMode(i, OUTPUT); flash(); }\nvoid flash(){ for ( int i(1 + _r); i \u0026lt;= 4 + _r; i++) digitalWrite(i, LOW); for ( int i(1 + _c); i \u0026lt;= 4 + _c; i++) digitalWrite(i, HIGH); }\nvoid echo(int i, int j) { flash(); digitalWrite(i + _r, HIGH); digitalWrite(j + _c, LOW); delay(Fr); }\nvoid loop() { for ( int i(1); i \u0026lt;= 4; i++){ for (int j(1); j \u0026lt;= 4; j++){ echo(i, j); } } } 这个代码会按照行列依次点亮每个灯。\n","date":1396876439,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396876439,"objectID":"6aa10bfcec7d623894fb927397814311","permalink":"/post/csdn/led%E7%82%B9%E9%98%B5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8E%A2%E7%B4%A2/","publishdate":"2014-04-07T21:13:59+08:00","relpermalink":"/post/csdn/led%E7%82%B9%E9%98%B5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8E%A2%E7%B4%A2/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 void setup() { for ( int i(_r); i \u0026lt;= 12; i++) pinMode(i, OUTPUT); flash(); } void flash(){ for ( int i(1 + _r); i \u0026lt;= 4 + _r; i++) digitalWrite(i, LOW); for ( int i(1 + _c); i \u0026lt;= 4 + _c; i++) digitalWrite(i, HIGH); } void echo(int i, int","tags":["LED"],"title":"LED点阵的基本操作探索","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n struct EDGE { int to, cap, rev; };\nvector\u0026lt;EDGE\u0026gt; g[N]; int ff[N][N]; bool used[N]; int n,m;\nint dfs(int v,int t,int f){ if ( v == t ) return f; used[v]= true; for ( int i(0); i \u0026lt; g[v].size(); i++){ EDGE \u0026amp;e = g[v][i]; if ( !used[e.to] \u0026amp;\u0026amp; e.cap \u0026gt; 0){ int d = dfs(e.to, t, min(f,e.cap)); if ( d \u0026gt; 0){ e.cap -= d; g[e.to][e.rev].cap += d; return d; } } } return 0; }\nint max_flow(int s,int t){ int flow = 0; while (1){ memset(used,0,sizeof(used)); int f = dfs(s,t,INF); if (f) flow += f; else return flow; } }\nvoid add_edge(int from, int to, int cap){ g[from].push_back((EDGE){to,cap,g[to].size()}); g[to].push_back((EDGE){from,0,g[from].size()-1}); }\nint main(){ freopen(\u0026ldquo;in.txt\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); while ( ~scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;m,\u0026amp;n)){ for ( int i(0);i\u0026lt;N;i++) g[i].clear(); memset(ff,0,sizeof(ff)); while ( m\u0026ndash; ){ int from,to,cap; scanf(\u0026quot;%d%d%d\u0026rdquo;,\u0026amp;from,\u0026amp;to,\u0026amp;cap); ff[from][to] += cap; } for ( int i(1);i\u0026lt;=n;i++){ for ( int j(1); j\u0026lt;=n;j++){ if ( ff[i][j] ){ add_edge(i,j,ff[i][j]); } } } printf(\u0026quot;%d\\n\u0026rdquo;,max_flow(1,n)); } return 0; }struct EDGE{ int to, cap, rev; }; vector\u0026lt;EDGE\u0026gt; g[N]; queue\u0026lt;int\u0026gt; que; int dist[N]; int n, m;\nvoid add_edge(int from, int to, int cap){ g[from].push_back((EDGE){to, cap, g[to].size()}); g[to].push_back((EDGE){from, 0, g[from].size() - 1}); }\nvoid bfs(int s){ memset(dist, -1, sizeof(dist)); while ( !que.empty() ) que.pop(); dist[s] = 0; que.push(s); while (!que.empty()){ int v = que.front(); que.pop(); for ( int i(0); i != g[v].size(); i++){ EDGE \u0026amp;e = g[v][i]; if ( e.cap \u0026gt; 0 \u0026amp;\u0026amp; dist[e.to] \u0026lt; 0){ dist[e.to] = dist[v] + 1; que.push(e.to); } } } }\nint dfs(int v, int t, int f){ if ( v == t ) return f; for ( int i(0); i != g[v].size(); i++){ EDGE \u0026amp;e = g[v][i]; if ( e.cap \u0026gt; 0 \u0026amp;\u0026amp; dist[e.to] \u0026gt; dist[v]){ int d = dfs(e.to, t, min(f, e.cap)); if ( d \u0026gt; 0){ e.cap -= d; g[e.to][e.rev].cap += d; return d; } } } return 0; }\nint Dinic(int s, int t){ int flow = 0; while (1){ bfs(s); if (dist[t] \u0026lt; 0) return flow; int f; while ((f = dfs(s, t, INF)) \u0026gt; 0) flow += f; } }\nint main(){ freopen(\u0026ldquo;in.txt\u0026rdquo;, \u0026ldquo;r\u0026rdquo;, stdin); while ( ~scanf(\u0026quot;%d%d\u0026rdquo;, \u0026amp;m, \u0026amp;n)){\n for ( int i(0); i \u0026amp;lt; N; i++) g[i].clear(); memset(ff,0,sizeof(ff)); while (m--){ int from, to, cap; scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;amp;from, \u0026amp;amp;to, \u0026amp;amp;cap); add_edge(from,to,cap); } printf(\u0026quot;%d\\n\u0026quot;, Dinic(1, n)); } return 0;  } ","date":1396450665,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396450665,"objectID":"64279ba0bff005642de18ed5cb26e513","permalink":"/post/csdn/poj-1273-drainage-ditches-%E7%BD%91%E7%BB%9C%E6%B5%81%E6%A8%A1%E7%89%88/","publishdate":"2014-04-02T22:57:45+08:00","relpermalink":"/post/csdn/poj-1273-drainage-ditches-%E7%BD%91%E7%BB%9C%E6%B5%81%E6%A8%A1%E7%89%88/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 struct EDGE { int to, cap, rev; }; vector\u0026lt;EDGE\u0026gt; g[N]; int ff[N][N]; bool used[N]; int n,m; int dfs(int v,int t,int f){ if ( v == t ) return f; used[v]= true; for ( int i(0); i \u0026lt; g[v].size(); i++){ EDGE \u0026amp;e = g[v][i]; if ( !used[e.to] \u0026amp;\u0026amp; e.cap \u0026gt; 0){","tags":["POJ","Algorithm","ACM"],"title":"POJ 1273 Drainage Ditches 网络流模版","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n stack\u0026lt;int\u0026gt; st; struct NODE { int v,next; } a[N],e[N]; int tr[N],pre[N],s[N],b[N]; int n,em,root,tt;\nvoid update(int x) { while ( x\u0026lt;=n) { tr[x] += 1; x += x \u0026amp; -x; } }\nint gs(int x) { int s = 0; while (x\u0026gt;0) { s += tr[x]; x -= x \u0026amp; -x; } return s; }\nvoid joint(int a1,int a2){ e[++em].v = a2; e[em].next = a[a1].next; a[a1].next = em; }\nint main() { while ( ~scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;n,\u0026amp;root)) { if ( !n \u0026amp;\u0026amp; !root ) break; for ( int i(1); i\u0026lt;=n; i++) tr[i] = a[i].next = b[i] = pre[i]= 0; em = 0; tt = 0;\n for ( int i(1); i\u0026amp;lt;n; i++) { int a1,a2; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;amp;a1,\u0026amp;amp;a2); joint(a1,a2); joint(a2,a1); } while (!st.empty()) st.pop(); // dfs st.push(root); while (!st.empty()) { int v = st.top(); if ( !b[v] ){ b[v] = 1; pre[v] = gs(v); update(v); for ( int p(a[v].next); p; p=e[p].next) { if ( !b[e[p].v] ) { int u = e[p].v; st.push(u); } } } if ( st.top() == v ) { s[v] = gs(v-1) - pre[v]; st.pop(); } } for ( int i(1); i\u0026amp;lt;n; i++) printf(\u0026quot;%d \u0026quot;,s[i]); printf(\u0026quot;%d\\n\u0026quot;,s[n]); } return 0;  } ","date":1396274398,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396274398,"objectID":"cc9b9be920c8b3a8ff6d463e10ea4bf2","permalink":"/post/csdn/hdu-3887-counting-offspring-dfs%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8-%E9%9D%9E%E9%80%92%E5%BD%92/","publishdate":"2014-03-31T21:59:58+08:00","relpermalink":"/post/csdn/hdu-3887-counting-offspring-dfs%E5%BA%8F%E7%9A%84%E8%BF%90%E7%94%A8-%E9%9D%9E%E9%80%92%E5%BD%92/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 stack\u0026lt;int\u0026gt; st; struct NODE { int v,next; } a[N],e[N]; int tr[N],pre[N],s[N],b[N]; int n,em,root,tt; void update(int x) { while ( x\u0026lt;=n) { tr[x] += 1; x += x \u0026amp; -x; } } int gs(int x) { int s = 0; while (x\u0026gt;0) { s += tr[x]; x -= x \u0026amp; -x;","tags":["HDU"],"title":"HDU 3887 Counting Offspring dfs序的运用 | 非递归","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n void dfs(int v) { P1[v]=++tt; for ( int p = a[v].next; p; p=st[p].next ) dfs(st[p].v); P2[v]=tt; return; }\ninline int l(int i) { return i \u0026amp; -i; }\nvoid update(int x,int k) { while (x\u0026lt;=n) { t[x] += k; x += l(x); } }\nint gs(int x) { int s =0; while ( x) { s += t[x]; x -= l(x); } return s; }\nint main() { scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;n); for ( int i(1); i\u0026lt;n; i++) { int a1,a2; scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;a1,\u0026amp;a2); st[++stn].v = a2; st[stn].next = a[a1].next; a[a1].next = stn; } dfs(1); for ( int i(1); i\u0026lt;=n; i++) h[i]=1,update(P1[i],1); for ( scanf(\u0026quot;%d\\n\u0026rdquo;,\u0026amp;m); m\u0026ndash;;) { char ch; int x; scanf(\u0026quot;%c%d\\n\u0026rdquo;,\u0026amp;ch,\u0026amp;x); if ( ch == \u0026lsquo;C\u0026rsquo; ) { if ( h[x] ) update(P1[x],-1); else update(P1[x],1); h[x] = 1-h[x]; } else printf(\u0026quot;%d\\n\u0026rdquo;,gs(P2[x])-gs(P1[x]-1)); } return 0; } ","date":1396230984,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396230984,"objectID":"437a4343afa44eec54b5fa2146be74eb","permalink":"/post/csdn/poj-3321-apple-tree-dfs%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8/","publishdate":"2014-03-31T09:56:24+08:00","relpermalink":"/post/csdn/poj-3321-apple-tree-dfs%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 void dfs(int v) { P1[v]=++tt; for ( int p = a[v].next; p; p=st[p].next ) dfs(st[p].v); P2[v]=tt; return; } inline int l(int i) { return i \u0026amp; -i; } void update(int x,int k) { while (x\u0026lt;=n) { t[x] += k; x += l(x); } } int gs(int x) { int s","tags":["POJ","Algorithm","ACM"],"title":"POJ 3321 Apple Tree dfs序的应用","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n void prekmp(char* b) { next[0]=-1; int j=-1; for ( int i(1); b[i]; i++) { while ( j!=-1 \u0026amp;\u0026amp; b[i]!=b[j+1]) j=next[j]; if ( b[i]==b[j+1] ) j++; next[i]=j; } }\nint kmp(char *a,char *b) { int j=-1,ans=0; for ( int i(0); a[i]; i++) { while ( j!=-1 \u0026amp;\u0026amp; a[i]!=b[j+1] ) j=next[j]; if (a[i]==b[j+1]) j++; if (!b[j+1]) { ans++; j=next[j]; } } return ans; }\nint main() { int T; freopen(\u0026ldquo;in.txt\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); for (scanf(\u0026quot;%d\\n\u0026rdquo;,\u0026amp;T); T\u0026ndash;;) { scanf(\u0026quot;%s\\n%s\\n\u0026rdquo;,b,a); memset(next,0,sizeof(0)); prekmp(b); printf(\u0026quot;%d\\n\u0026rdquo;,kmp(a,b)); } return 0; } ","date":1396229687,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396229687,"objectID":"7e614614984dec566dd670ce41c31b9a","permalink":"/post/csdn/poj-3461-oulipo-kmp%E7%BB%83%E4%B9%A0/","publishdate":"2014-03-31T09:34:47+08:00","relpermalink":"/post/csdn/poj-3461-oulipo-kmp%E7%BB%83%E4%B9%A0/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 void prekmp(char* b) { next[0]=-1; int j=-1; for ( int i(1); b[i]; i++) { while ( j!=-1 \u0026amp;\u0026amp; b[i]!=b[j+1]) j=next[j]; if ( b[i]==b[j+1] ) j++; next[i]=j; } } int kmp(char *a,char *b) { int j=-1,ans=0; for ( int i(0); a[i]; i++) { while ( j!=-1 \u0026amp;\u0026amp; a[i]!=b[j+1] ) j=next[j]; if","tags":["POJ","Algorithm","ACM"],"title":"POJ 3461 Oulipo KMP练习","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n initial-scale - // 初始的缩放比例 （范围从\u0026gt;0 到10）\nminimum-scale - // 允许用户缩放到的最小比例 maximum-scale - // 允许用户缩放到的最大比例\nuser-scalable - // 用户是否可以手动缩 (no,yes) //竖屏时使用的样式 \u0026lt;style media=\u0026quot;all and (orientation:portrait)\u0026rdquo; type=\u0026quot;text/css\u0026rdquo;\u0026gt; #landscape { display: none; } \u0026lt;/style\u0026gt;\n//横屏时使用的样式 \u0026lt;style media=\u0026quot;all and (orientation:landscape)\u0026rdquo; type=\u0026quot;text/css\u0026rdquo;\u0026gt; #portrait { display: none; } \u0026lt;/style\u0026gt; // 触摸事件 gesturestart //当两个手指接触屏幕时触发 gesturechange //当两个手指接触屏幕后开始移动时触发 gestureend\n// 屏幕旋转事件\nonorientationchange\n// 检测触摸屏幕的手指何时改变方向 orientationchange\n// touch事件支持的相关属性 touches targetTouches changedTouches clientX　// X coordinate of touch relative to the viewport (excludes scroll offset) clientY　// Y coordinate of touch relative to the viewport (excludes scroll offset) screenX　// Relative to the screen screenY // Relative to the screen pageX　// Relative to the full page (includes scrolling) pageY　// Relative to the full page (includes scrolling) target　// Node the touch event originated from identifier　// An identifying number, unique to each touch event4. 屏幕旋转事件：onorientationchange 添加屏幕旋转事件侦听，可随时发现屏幕旋转状态（左旋、右旋还是没旋）。例子： 6. 双手指滑动事件：\n","date":1396067371,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1396067371,"objectID":"7a7fcec71a35ce18ff34ec24f558efc6","permalink":"/post/csdn/webkit-webapp-%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/","publishdate":"2014-03-29T12:29:31+08:00","relpermalink":"/post/csdn/webkit-webapp-%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 initial-scale - // 初始的缩放比例 （范围从\u0026gt;0 到10） minimum-scale - // 允许用户缩放到的最小比例 maximum-scale - // 允许用户缩放到的最","tags":["webkit"],"title":"webkit webApp 开发技术要点总结","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1387715096,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1387715096,"objectID":"1d3d9ccec06c8317e8afae60b3866b4e","permalink":"/post/csdn/%E6%9D%8E%E5%BC%80%E5%A4%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%AE%8C%E6%95%B4%E7%89%88/","publishdate":"2013-12-22T20:24:56+08:00","relpermalink":"/post/csdn/%E6%9D%8E%E5%BC%80%E5%A4%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%8A%9B%E9%87%8F-%E5%AE%8C%E6%95%B4%E7%89%88/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":[],"title":"李开复：算法的力量 （完整版）","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1387640911,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1387640911,"objectID":"3bb8850e3dbfa1ca4a8eea7f74c02c50","permalink":"/post/csdn/2013~2014-%E7%AC%AC%E4%B8%80%E5%AD%A6%E6%9C%9F%E8%AF%BE%E4%BB%B6%E6%95%B4%E7%90%86/","publishdate":"2013-12-21T23:48:31+08:00","relpermalink":"/post/csdn/2013~2014-%E7%AC%AC%E4%B8%80%E5%AD%A6%E6%9C%9F%E8%AF%BE%E4%BB%B6%E6%95%B4%E7%90%86/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["2013"],"title":"2013~2014 第一学期课件整理","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1386208911,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1386208911,"objectID":"1f542c19382e274693cf2bc7a0d23834","permalink":"/post/csdn/%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8Bgo%E7%8E%AF%E5%A2%83%E9%9C%80%E8%A6%81%E7%9A%84%E4%B8%9C%E8%A5%BF%E6%B0%B4%E5%B8%96~/","publishdate":"2013-12-05T10:01:51+08:00","relpermalink":"/post/csdn/%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8Bgo%E7%8E%AF%E5%A2%83%E9%9C%80%E8%A6%81%E7%9A%84%E4%B8%9C%E8%A5%BF%E6%B0%B4%E5%B8%96~/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":[],"title":"整理一下Go环境需要的东西（水帖~）","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| | | | | | | | O | | O | | O | | | | | | | | | | |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| D E F\n|\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| | | | | | | | O | | O\u0026mdash;| | O | | | | | | | | | |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| G H I The goal is to find a minimal sequence of moves to return all the dials to 12 o\u0026rsquo;clock. Nine different ways to turn the dials on the clocks are supplied via a table below; each way is called a move. Select for each move a number 1 through 9 which will cause the dials of the affected clocks (see next table) to be turned 90 degrees clockwise. Move Affected clocks 1 ABDE 2 ABC 3 BCEF 4 ADG 5 BDEFH 6 CFI 7 DEGH 8 GHI 9 EFHI Example Each number represents a time accoring to following table: 9 9 12 9 12 12 9 12 12 12 12 12 12 12 12 6 6 6 5 -\u0026gt; 9 9 9 8-\u0026gt; 9 9 9 4 -\u0026gt; 12 9 9 9-\u0026gt; 12 12 12 6 3 6 6 6 6 9 9 9 12 9 9 12 12 12 [But this might or might not be the `correct\u0026rsquo; answer; see below.] PROGRAM NAME: clocks INPUT FORMAT Lines 1-3: Three lines of three space-separated numbers; each number represents the start time of one clock, 3, 6, 9, or 12. The ordering of the numbers corresponds to the first example above. SAMPLE INPUT (file clocks.in) 9 9 12 6 6 6 6 3 6 OUTPUT FORMAT A single line that contains a space separated list of the shortest sequence of moves (designated by numbers) which returns all the clocks to 12:00. If there is more than one solution, print the one which gives the lowest number when the moves are concatenated (e.g., 5 2 4 6 \u0026lt; 9 3 1 1). SAMPLE OUTPUT (file clocks.out) 4 5 8 9","date":1385627821,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1385627821,"objectID":"7d386d5e81094d8702167fc234d2e6f4","permalink":"/post/csdn/usaco-section-1.4.3-the-clocks/","publishdate":"2013-11-28T16:37:01+08:00","relpermalink":"/post/csdn/usaco-section-1.4.3-the-clocks/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| | | | | | | | O | | O | | O | | | | | | | | | | |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| D E F |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| |\u0026mdash;\u0026mdash;-| | | | | | | | O | | O\u0026mdash;| | O |","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.4.3 The Clocks","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n const int N = 555; int n, m, g[N][N], chk[N], match[N];\nint dfs(int v){ int t; for ( int i = 1; i \u0026lt;= n; i++){ if ( g[i][v] \u0026amp;\u0026amp; !chk[i] ){ chk[i] = 1; t = match[i]; match[i] = v; if ( t == -1 || dfs(t) ) return 1; match[i] = t; } } return 0; }\nint main(){ while ( ~scanf(\u0026quot;%d%d\u0026rdquo;, \u0026amp;n ,\u0026amp;m) ){ memset(g, 0, sizeof(g)); while ( m\u0026ndash; ){ int a, b; scanf(\u0026quot;%d%d\u0026rdquo;, \u0026amp;a, \u0026amp;b); g[a][b] = 1; } int ans = 0; memset(match, 255, sizeof(match)); for ( int i = 1; i \u0026lt;= n; i++){ memset( chk, 0, sizeof(chk)); ans += dfs(i); } printf(\u0026quot;%d\\n\u0026rdquo;, ans); } return 0; } ","date":1384503798,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1384503798,"objectID":"87cc497e09ed8477111d79fb08995664","permalink":"/post/csdn/poj-3041-asteroids-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/","publishdate":"2013-11-15T16:23:18+08:00","relpermalink":"/post/csdn/poj-3041-asteroids-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 const int N = 555; int n, m, g[N][N], chk[N], match[N]; int dfs(int v){ int t; for ( int i = 1; i \u0026lt;= n; i++){ if ( g[i][v] \u0026amp;\u0026amp; !chk[i] ){ chk[i] = 1; t = match[i]; match[i] = v; if ( t == -1 || dfs(t) ) return","tags":["POJ","Algorithm","ACM"],"title":"POJ 3041 Asteroids 匈牙利算法 二分图最大匹配","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n g rcx fff n1.com w q ","date":1383130214,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1383130214,"objectID":"71e9342c1220ac3aa81bfc3f5346fa9e","permalink":"/post/csdn/%E5%9B%BD%E9%99%85%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%E4%B8%80%E7%AD%89%E5%A5%96%E4%BD%9C%E5%93%81%E6%AC%A3%E8%B5%8F/","publishdate":"2013-10-30T18:50:14+08:00","relpermalink":"/post/csdn/%E5%9B%BD%E9%99%85%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B%E4%B8%80%E7%AD%89%E5%A5%96%E4%BD%9C%E5%93%81%E6%AC%A3%E8%B5%8F/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 g rcx fff n1.com w q","tags":[],"title":"国际程序设计大赛一等奖作品欣赏","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1383024488,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1383024488,"objectID":"dbb50d076686b1717297e285306b01bb","permalink":"/post/csdn/ufw-%E7%9B%B8%E5%85%B3/","publishdate":"2013-10-29T13:28:08+08:00","relpermalink":"/post/csdn/ufw-%E7%9B%B8%E5%85%B3/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["ufw"],"title":"ufw 相关","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1381859200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1381859200,"objectID":"ee3879e8795b1187db6a8163203372cf","permalink":"/post/csdn/ubuntu-%E5%AE%89%E8%A3%85-hustoj/","publishdate":"2013-10-16T01:46:40+08:00","relpermalink":"/post/csdn/ubuntu-%E5%AE%89%E8%A3%85-hustoj/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["HUSTOJ","Algorithm","ACM"],"title":"ubuntu 安装 HUSTOJ","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1381842796,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1381842796,"objectID":"7754ed845a90d5e1bcf0642b332f925c","permalink":"/post/csdn/lamp-%E7%9A%84%E6%90%AD%E5%BB%BA/","publishdate":"2013-10-15T21:13:16+08:00","relpermalink":"/post/csdn/lamp-%E7%9A%84%E6%90%AD%E5%BB%BA/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["LAMP"],"title":"LAMP 的搭建","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1381771635,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1381771635,"objectID":"b5a422440cf11e7cc28cf0a482bb48b5","permalink":"/post/csdn/%E9%9D%9E%E6%8A%80%E6%9C%AF%E8%B4%B4%E8%AE%B0%E6%B9%96%E5%8D%97%E7%9C%81%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/","publishdate":"2013-10-15T01:27:15+08:00","relpermalink":"/post/csdn/%E9%9D%9E%E6%8A%80%E6%9C%AF%E8%B4%B4%E8%AE%B0%E6%B9%96%E5%8D%97%E7%9C%81%E7%AC%AC%E4%B9%9D%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":[],"title":"【非技术贴】记湖南省第九届程序设计大赛","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1380726718,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1380726718,"objectID":"0867a2061645f1387f1bcf49938c03dc","permalink":"/post/csdn/longest-ordered-subsequence-onlogn%E8%A7%A3%E6%B3%95-stl/","publishdate":"2013-10-02T23:11:58+08:00","relpermalink":"/post/csdn/longest-ordered-subsequence-onlogn%E8%A7%A3%E6%B3%95-stl/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["Longest"],"title":"Longest Ordered Subsequence   O(nlogn)解法 STL","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1380113099,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1380113099,"objectID":"00346e98dee5854155b0050c29df7c45","permalink":"/post/csdn/java-for-acm-%E5%B0%8F%E7%BB%93/","publishdate":"2013-09-25T20:44:59+08:00","relpermalink":"/post/csdn/java-for-acm-%E5%B0%8F%E7%BB%93/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["Java"],"title":"Java for ACM 小结","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1379825629,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1379825629,"objectID":"2a2c7550e642f334060946904fd256b7","permalink":"/post/csdn/%E7%82%B9%E9%9B%86%E9%85%8D%E5%AF%B9%E9%97%AE%E9%A2%98-%E9%9B%86%E5%90%88dp-%E6%8C%89%E4%BD%8Ddp/","publishdate":"2013-09-22T12:53:49+08:00","relpermalink":"/post/csdn/%E7%82%B9%E9%9B%86%E9%85%8D%E5%AF%B9%E9%97%AE%E9%A2%98-%E9%9B%86%E5%90%88dp-%E6%8C%89%E4%BD%8Ddp/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":[],"title":"点集配对问题   集合DP 按位DP","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n #define lson l , m , rt \u0026lt;\u0026lt; 1 #define rson m + 1 , r , rt \u0026lt;\u0026lt; 1 | 1 const int maxn = 222222; int MAX[maxn\u0026lt;\u0026lt;2]; void PushUP(int rt) { MAX[rt] = max(MAX[rt\u0026lt;\u0026lt;1] , MAX[rt\u0026lt;\u0026lt;1|1]); } void build(int l,int r,int rt) { if (l == r) { scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;MAX[rt]); return ; } int m = (l + r) \u0026gt;\u0026gt; 1; build(lson); build(rson); PushUP(rt); } void update(int p,int sc,int l,int r,int rt) { if (l == r) { MAX[rt] = sc; return ; } int m = (l + r) \u0026gt;\u0026gt; 1; if (p \u0026lt;= m) update(p , sc , lson); else update(p , sc , rson); PushUP(rt); } int query(int L,int R,int l,int r,int rt) { if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) { return MAX[rt]; } int m = (l + r) \u0026gt;\u0026gt; 1; int ret = 0; if (L \u0026lt;= m) ret = max(ret , query(L , R , lson)); if (R \u0026gt; m) ret = max(ret , query(L , R , rson)); return ret; } int main() { int n , m; while (~scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;n,\u0026amp;m)) { build(1 , n , 1); while (m \u0026ndash;) { char op[2]; int a , b; scanf(\u0026quot;%s%d%d\u0026rdquo;,op,\u0026amp;a,\u0026amp;b); if (op[0] == \u0026lsquo;Q\u0026rsquo;) printf(\u0026quot;%d\\n\u0026rdquo;,query(a , b , 1 , n , 1)); else update(a , b , 1 , n , 1); } } return 0; }","date":1377963470,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1377963470,"objectID":"9ac4f8cfa12e6bbe5668d9b2d32606ca","permalink":"/post/csdn/notonlysuccess-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E9%AB%98%E4%BA%BA%E6%8E%A8%E8%8D%90/","publishdate":"2013-08-31T23:37:50+08:00","relpermalink":"/post/csdn/notonlysuccess-%E7%BA%BF%E6%AE%B5%E6%A0%91-%E9%AB%98%E4%BA%BA%E6%8E%A8%E8%8D%90/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 #define lson l , m , rt \u0026lt;\u0026lt; 1 #define rson m + 1 , r , rt \u0026lt;\u0026lt; 1 | 1 const int maxn = 222222; int MAX[maxn\u0026lt;\u0026lt;2]; void PushUP(int rt) { MAX[rt] = max(MAX[rt\u0026lt;\u0026lt;1] , MAX[rt\u0026lt;\u0026lt;1|1]); } void build(int l,int r,int rt) { if (l == r) {","tags":["notonlysuccess"],"title":"notonlysuccess 线段树 高人推荐","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1377101462,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1377101462,"objectID":"63b4f8d0caf9bff0b53154d8b4f8c8c5","permalink":"/post/csdn/rmq-with-shifts-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E5%9F%BA%E7%A1%80/","publishdate":"2013-08-22T00:11:02+08:00","relpermalink":"/post/csdn/rmq-with-shifts-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%9F%BA%E5%9F%BA%E7%A1%80/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["RMQ"],"title":"RMQ with Shifts 线段树基基础","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1372323389,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1372323389,"objectID":"6b52d30a92d7bc9467f9448fce574abf","permalink":"/post/csdn/hoj-2651-pie/","publishdate":"2013-06-27T16:56:29+08:00","relpermalink":"/post/csdn/hoj-2651-pie/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["HOJ","Algorithm","ACM"],"title":"HOJ 2651 PIE","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1372271925,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1372271925,"objectID":"b48e7473548667479c1eb4778c7d9ebd","permalink":"/post/csdn/hdoj-4152-zzys-dilemma/","publishdate":"2013-06-27T02:38:45+08:00","relpermalink":"/post/csdn/hdoj-4152-zzys-dilemma/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["HDOJ","Algorithm","ACM"],"title":"HDOJ 4152 ZZY’s Dilemma","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1372271679,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1372271679,"objectID":"4ba25b790d868dd218abf9ab7d6d86b0","permalink":"/post/csdn/zoj-3203-light-bulb/","publishdate":"2013-06-27T02:34:39+08:00","relpermalink":"/post/csdn/zoj-3203-light-bulb/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["ZOJ","Algorithm","ACM"],"title":"ZOJ 3203 Light Bulb","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1371263287,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1371263287,"objectID":"59b59365c7fc5020415e2da480251ff3","permalink":"/post/csdn/wwdc%E8%8B%B9%E6%9E%9C%E7%9A%84%E9%87%8E%E5%BF%83/","publishdate":"2013-06-15T10:28:07+08:00","relpermalink":"/post/csdn/wwdc%E8%8B%B9%E6%9E%9C%E7%9A%84%E9%87%8E%E5%BF%83/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["WWDC"],"title":"WWDC，苹果的野心","type":"post"},{"authors":null,"categories":["typecho"],"content":"很多人顽强地看完了WWDC，开始了惯有的各种吐槽。虽然我开始看的时候状态也差不多吧，尤其是看到第一个“产品”就是Finder Tabs，说实话，我个人不是很喜欢这个东西，以前在linux下就开始使用了但是感觉并不是多么的便捷。况且Finder本身可以打开一个智能窗口，这个功能很强大，很喜欢，让我目前没有看到tabs有什么重大的意义。\nApple要干嘛 最开始同大家的感觉一样，Apple发布了一堆“无聊”但却是还有点用的东西。但是看到后面就有些不明白了，Apple到底要做什么，\n1.首先，这是一个减法的时代，你Apple却开始做加法了，吃饱了撑的么？\n2.就算做加法，怎么竟加一些跟你的“核心竞争力”不沾边的东西？\n很多人的解释是Apple没落了。但是我看着看着却觉得脊梁骨发凉了：Apple这盘棋，怎一个大字了得，全然厚黑之道。（这是昨晚的一条状态。对错先不论）。”厚黑“，看起来和科技界完全不沾边的词第一个跑到了我的脑海里。\n如果去仔细看一下这几次Apple的发布会以及媒体的报道，就会发现有一类共同的句子：“某某君，你还好吗？”、“Apple又革（割字或许更好）了谁的命”、“Apple又整合（注意是整合不是集成）了某个服务了”。看到这里，大家又会说，这有什么稀奇的，在中国这种不是太多了吗。就像多年前3Q大战时大家开的玩笑，吃肉长大的狗，不会啃骨头，等肉没了的时候只能狗咬狗了。这样也可以顶一下Apple没落的理由。但是我们想一下，它咬的是谁呢？\nApple的一些恩恩怨怨 开发者 它没有像某某公司一样去把它的竞争对手Android搞掉，相反，他下手的目标是那些跟IOS一起成长起来的开发者们。\n开发者，到底是个什么角色？当年Apple设计了全新的操作系统，作为新平台，相比于其它成熟的平台，自然是百业待兴。而对Apple这样连不给人看的电路板都要画的好看的公司来说，让他去设计每一个小功能估计早都累死了。（你傻呀，哪个操作系统不是平台呢？）但是Apple的平台它是一个非常封闭的平台，Apple的控制管理很强。当然我们称之为良性生态圈。所以大家都很乐意为OS开发，同样也造就了一批magic。在其它的平台上，也会由于个人开发者的强大而做出很炫的产品，但是在OS系列上可以产生一大批杰出的作品，这与Apple的引导是分不开的。这样以来，Apple可以专注于系统层面，开发者可以把这个系统打扮的非常精美。看！多和谐！\n开放平台 大概就是这个时候，开放平台崛起（当然 facebook 也功不可没吧）。做论坛的搞开放平台，做微博的搞开放平台，做音乐的搞开放平台，做桌面的当然更要做开放平台了，做游戏的，恩，你懂得。 开放平台如日中天，极客一词也广为传播。极客们带着自己的梦想，激情，同乔帮主一道改变世界，一起做kings and the queens（多和谐！）。可当Apple的系统层面搞得差不多时（或者说只是开始加强对应用的控制力度），再回过头看看那些 the magic we made，傻眼了。这不是老子辛辛苦苦做的吗？怎么直接被你Apple拿走了？抗议！抗议？哪凉快哪呆着去。\n这个时候，那些自以为开放平台做的好的才发现，两个开放平台，根本不是一个性质。你总觉得，开放平台，这是大家一起在一块田上耕作，收成嘛，当然自己拿自己的。但其实，这只是Apple生态圈的一半，另一半呢？在另一半，大家都是Apple这个大地主的佃农。乔大地主自己有点事情，于是找你们帮它耕作，等他那边忙活完了，有时间管这边了，好，你们回家洗洗睡吧。\n他行吗？其实，前面说它是良性生态圈的前面还有一句话，这是一个完全受他控制的一块地盘。如果在android下，好家伙，有几个人用的原生android？android开源，让那些禽兽们给糟蹋的四分五裂，google也管不着。但是IOS不一样，人家可以随便编个理由就让你不能上架了（这份痛大家都懂）。更别说之后怎么搞你了。\n他敢吗？事实已经很明了了，一个个失眠的产品。我们说Apple地图，虽然最开始出了点小瑕疵，但是这次的回归，感觉还不错吧。因为才发出来，没有引发什么太大的问题。但是即便有了问题，Apple可以很轻松地搞定，也没有人会在意那些。在地图上，google都被动刀子了，而且没有引发争议，其它的小家伙，Apple会怕你们吗？果粉们会真的舍不得你们吗？拿我自己说吧，如果我用的非Apple产品，当我看到如此“垃圾”随处可捡的功能，我只会吐，这破功能人家早有了。Apple不行了啊。但是如果我用的Apple产品，我会觉得，这个功能不错啊。哇！终于来了！当你用上一款Apple产品时，除非特别痛的地方，你根本不会去跟其它的比来比去的。因为这俩系统有些本质上的不同。\n大一统 （Apple要亲手拆掉自己的生态圈？）当然不是全拆，但是会缩减。Apple，到底是做什么的呢？它的核心竞争力到底在哪里呢？以前你可能会说，卖电脑的。现在，你也许会说，卖手机的。Apple做了哪些产品，你可能会说，设计了一款手机，设计了一款系统。靠IOS成长的起来的第三方公司会说，他打造了一个产业生态圈。把一个很弱智的功能，很容易实现的功能，自己就不做，非留给你们开发者去做。（前面这些话不是我说的，大概是乔布斯死后一些第三方应用公司为表感激而说的）。我的理解，既然他当年可以由于某种原因留给你去做，那么今天他就可以不需要理由把你做的给直接拿走。站在天上丢馅饼？你觉得乔帮主会这么干吗？乔布斯要做的， 就是为人们打造一款完美的产品，一套可以改变人们工作生活学习方式的服务。这套服务，不是一个硬件，不是一个操作系统，不是一堆应用，而是他们的总和。Apple决不会像MS一样，自己只做一个系统，做一套漂亮的SDK，然后你们靠你们去繁荣市场吧。\n那Apple会整合哪些产品呢？游戏，我觉得Apple不会做，至少暂时不会去涉猎太多，不过你也不能排除Apple突然有些好点子就整合几个游戏的可能。但是办公方面，应该还是挺明显的吧，我们在windows下会有三方公司定制“装机必备软件”，这些基本的工作上要用的东西，Apple都会去整合。今天在mail上加一个vip，明天或许就出来一个sparrow了也不是没可能。但不得不说，这点对用户是真的很方便的。（facebook它可能一时不会自己去搞，但一定会在自己通讯工具里慢慢渗透。youtube呢？我觉得它会考虑把视频资料整合一下发出来的，Apple TV 也需要资源的。这个有点像做地图，因为现在都有专门的数据公司了，你只需要拿过来加上自己的特色就是了。这些东西虽然很小但是加上却很棒）。这样下来，媒体，它可能不会去做，社交，说不准，这样的话，貌似它什么都敢做了。。。\n其它的一些想法 创新不足？ 回到大家很关心的问题，这些变化太无聊了，没有划时代的感觉，其实很简单，如果天天都是划时代，那还叫划时代吗？如果我们再回过头把Apple历次的发布会放到一起，除了在iPhone发布会上给你颠覆的感觉，其它的，也都是一些缝缝补补。当然大多数情况也都会有一款杀手级的应用问世。或许这一年，地图让Apple煞费了苦心。也可能大家都去设计那个不明觉厉的MAC Pro了。\n这样说来，Apple召开发布会的初衷，是告诉大家，从前所有的不满，我们都在努力的改善，以后将为大家提供更方便的服务。（请大家坚定地支持我们，但为什么这次Cook上台时没有听到那一串3ks呢）。在果粉心中，新版的系统满足了他们的一些需求，这就够了。至于android有没有什么功能，哪个第三方被跪了。Who cares？现在的这些手势啦，UI设计啦，都是这些生态圈里创造出来的。以后，Apple可以把你们全整合了，你们全喝西北风去吧。果粉用着舒服，这就够了。\n品牌形象 那么，如果Apple以这样的心态去面对用户和开发者。开发者会不会离它而去呢？至少暂时不会，因为离了他，有些想法还真的难以实现了。那以后android成长起来呢？好吧，Google这个有史以来最奇葩的公司，谁也不知道Android以后会是什么样子。至少当Apple的服务越来越完善，越来越贴心，当Apple的便捷深入人心的时候，Google想再超越就会越难。\n最后 有这样一种说法：一流公司做标准，二流公司做服务。而Apple告诉我们，二逼公司从来没有标准，最多就是招点兵马帮忙砸了别人的标准。然后来完善自己的服务。用户才不会管你标准不标准的，我们要的，是服务。\n","date":1370861100,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1370861100,"objectID":"8b105f31978957b074e1fb0a730fa23f","permalink":"/post/typecho/77-wwdc-apples-ambition/","publishdate":"2013-06-10T18:45:00+08:00","relpermalink":"/post/typecho/77-wwdc-apples-ambition/","section":"post","summary":"很多人顽强地看完了WWDC，开始了惯有的各种吐槽。虽然我开始看的时候状态也差不多吧，尤其是看到第一个“产品”就是Finder Tabs，说实话，我个人不是很喜欢这个东西，以前在linux下就开始使用了但是感觉并不是多么的便捷。况且Finder本身可以打开一个智能窗口，这个功能很强大，很喜欢，让我目前没有看到tabs有什么重大的意义。\n","tags":["互联网"],"title":"WWDC, Apple's Ambition","type":"post"},{"authors":null,"categories":["typecho"],"content":"高考前后，RP掉到渣，电脑也各种犯毛病。无意中看到了一份比较不错的黑苹果安装视频教程，反正机子也各种毛病，破罐子摔摔看，看能不能摔出什么宝贝出来。\n那时候还没有关于ProBook 4421s 的教程，很多人说这机子不能装！后来用工具测试果然显示不行.\n那时候还不知道懒人版是什么东西只觉得自己好牛逼的，下载的都是原版自己提取自己配置到最后得知内核不兼容。\n那时候还有些怀疑软件真的把硬件瘫痪掉，于是后来。。你懂得。\n最开始就跟教程一步一步来，提取镜像，把两个小盘参数改成AF，写入磁盘，写跪了无数次，后来发现参数不用改，不用格式化，只要有个盘符能看到就行。光把镜像写入磁盘可能就折腾了有三天，直到半年后这个问题有时候还会犯。\n镜像写好之后，下来又是一个非常头疼的问题，引导。最开始用Chameleon，替换wowpc。但是跪了，一直说是找不到某某mbr，据说是变色龙版本的问题，换，其实坛子的变色龙就两个版本，换来换去最后不知道换到哪个时给进去了。这个时候距离接触黑苹果已经一周了。连安装界面都没有进入。\n不要想多了只是进去变色龙了，选择install后看到一个大大的苹果logo，内心无比激动。 ———————————————————————————— 写到这里时，小引一口水，洒了一键盘，拔电源，抠电池，于是乎上面写的东西全丢了。。 ————————————————————————————- 正当我看到那个logo激动时，重启了。如上所说,在换了各种版本后，最后还是悲催地收场了。 一个暑假的十天时间，就这样充实地过去了。\n刚进入大学，都会有那么一段时间去忙活各种蛋疼的事情。一直到了11月份，又开始折腾了，这次折腾的力度加大了，其实也没什么力度，就是一天重启的次数多了，windows搞崩的频率快了。好在当时已经混进实验室，win和linux故障都可以找军哥搞定。没有什么“后顾”之忧。又折腾了一星期，那一星期大部分的时间就是拿一本书坐在电脑前面，电脑重启再重启，如果突然崩了重启不了了就放下书开始修复。。\n直到看到了一份虚拟机安装黑苹果的教程，看起来很简单，有得一试。在一个精简版的gnome下开virtualbox各种捣腾，把第一次跑起来了黑苹果，因为这个精简版的gnome进入桌面后，内存一共只被占了300M，因此在使用上并没有太多的影响。后来感觉在我的虚拟机下，比久经某人糟蹋的几乎同等配置的macbook pro跑的还流畅。虚拟机下一切还好，声音网络都不用操心，但是，显卡不行。只有1024*768的一个分辨率，装tools也搞不起。反正就在虚拟机里瞎玩玩吧。\n这个时候距离接触黑苹果已经过去快半年了，除了在虚拟机里自娱自乐、好丢人。不说了。。说点好的，差不多这个时候，开始学习在linux下生存，除非迫不得已不去开windows。时间又这样过去了几个月。。\n那天逛远景时，突然发现就在去年我在一次一次重启时，有几个跟我同机子的大牛也再研究了。靠着几个老师写的文章，在我放弃的时候搞出来了“完美运行”！更加令我佩服的是，我看这哥们搞黑苹果的发贴记录，足足搞了一年半！付出才有回报啊。相比之下自己花的时间累计不足一个月，能搞出来才有问题呢.\n这位大牛搞出来之后把他用的资源都发出来了，方法略有差别，用的懒人版的Lion，我发现根本不需要MD直接用DiskGenius把磁盘参数改成07就可以在win下访问最后再改回AF即可。于是很顺利地第一次脱离虚拟机进入了黑苹果，那会激动不吃饭，也睡不着。但实际上，在黑苹果中，装系统只是第一步，驱动才是大问题。而且这个时候没有声音、没有网、没有显卡驱动、甚至连笔记本键盘都不能用。\n虽然这次很顺利地装好了系统（大概花了一整天吧）。但是驱动又卡了我一个星期，装驱动提示安装完毕但总是没有任何效果。后来发现Kext Wizard必须在mac下解压，终于能装了，结果，装一个驱动，死机，运气好的话不会死掉但一重启就启动不了了。又折腾了一星期，没有结果。最悲剧的事情是，硬盘跪了，丢了好多资料。无奈之下买了一个1T的移动硬盘，花了我500大洋，全是折腾惹的祸。可问题还在，什么都搞不好，不仅windows一直跪，还把linux引导丢了又得修复grub。。而就在这个时候帮小玉的白苹果重装了下系统，一路连一个磕绊都没有，一下午就搞定了。再看看自己折腾了半年多的黑苹果，唉。。心碎了。\n这个事情又压了几个月，直到上周，不知道哪根筋抽了又要装mac，还没下手，想到一个很烦的问题，一装mac，引导就丢，修复呢，要修复win和linux，也就是说需要一个PE，还得一个live USB。一个U盘不够啊！而且，因为在这个过程中，一天可能要装几次，就要修复好几次，而每次修复都要重修烧U盘！有些怕了。\n看着别人都用上mac于心不忍啊。说真的，作为一个用户来讲，MAC+IOS的体验，是win+Android根本没法比的。从用户的角度讲，以前那些嫌苹果这个那个的完全站不住脚。再敬乔帮主。可最近事务繁忙怎么办，咬咬牙，这周末两天，什么都不做，全心研究黑苹果。严格来说是从今天早上开始搞驱动的。开始一遍一遍的爬楼（看不懂哇）。下了一堆子完全没碰过的工具，不同版本的。下午把声卡安好了，永远的fly away、跑起来。于是又没吃饭。\n从下午到晚上，开始自己修改EDID，自己提取ROM，到晚上八点，安装显卡前，拍了一张照片，发到人人，不知道重启之后还会不会看到桌面，这些刚修改的东西以后怎么处理。\n幸运地，还没等这条照片完全发出去，电脑进入了登录界面，账户头像，那么圆，那么精致！难道装好了？进去后，看到了透明的任务栏！哈哈这么简单啊！一天而已嘛！老子搞定了！大餐走起！~\n吃饭前让它自己下载java6，苹果自己改的java6，好坑爹。回来的时候，your computer must be restart…..凡是折腾过黑苹果的都明白，再也熟悉不过的画面。装系统没跪，装驱动没跪，结果死在了java上！还是java6！泪奔了。。\n重启后，才发现，虚惊一场，只是装java想让你重启一下而已。。\n","date":1370088900,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1370088900,"objectID":"0d2587bda868f23ccdb3ece483cbade9","permalink":"/post/typecho/54-hp-4421s-%E5%95%83%E5%88%B0%E9%BB%91%E8%8B%B9%E6%9E%9C/","publishdate":"2013-06-01T20:15:00+08:00","relpermalink":"/post/typecho/54-hp-4421s-%E5%95%83%E5%88%B0%E9%BB%91%E8%8B%B9%E6%9E%9C/","section":"post","summary":"高考前后，RP掉到渣，电脑也各种犯毛病。无意中看到了一份比较不错的黑苹果安装视频教程，反正机子也各种毛病，破罐子摔摔看，看能不能摔出什么宝贝出来。\n那时候还没有关于ProBook 4421s 的教程，很多人说这机子不能装！后来用工具测试果然显示不行.\n那时候还不知道懒人版是什么东西只觉得自己好牛逼的，下载的都是原版自己提取自己配置到最后得知内核不兼容。\n","tags":["IT技术堆","Mac"],"title":"HP 4421s 啃到黑苹果","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n void build(int v,int l,int r){\t// 本段代码 同 数列操作1 st[v].l=l; st[v].r=r; if (st[v].l==st[v].r){ st[v].sum=a[l]; return ; } int mid = (l+r)/2; build(v2,l,mid); build(v2+1,mid+1,r); st[v].sum=st[v2].sum + st[v2+1].sum; }\nvoid insert(int v,int l,int r,long long c){ // 插入 st[v].sum+=c*(r-l+1);\tif (l==st[v].l \u0026amp;\u0026amp; r==st[v].r){\t// 如果正好需要这段，更新inc值，跳出 st[v].inc+=c; return ; } int mid = (st[v].l+st[v].r)/2; // 向下更新 if (r\u0026lt;=mid) insert(v*2,l,r,c); else if (l\u0026gt;mid) insert(v*2+1,l,r,c); else { insert(v*2,l,mid,c); insert(v*2+1,mid+1,r,c); } }\nlong long getsum(int v,int l,int r){\t// 求和 if (l==st[v].l \u0026amp;\u0026amp; r==st[v].r) return st[v].sum;\t// 找到，返回 int mid = (st[v].l + st[v].r)/2; if (r\u0026lt;=mid) return getsum(v2,l,r) + st[v].inc(r-l+1);\t// 如果还需要向下寻找，回溯的时候务必加上 该节点的inc值 else if (l\u0026gt;mid) return getsum(v2+1,l,r) + st[v].inc(r-l+1); else return getsum(v2,l,mid) + getsum(v2+1,mid+1,r) + st[v].inc*(r-l+1); }\nint main(){ freopen(\u0026ldquo;1082.in\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); int n; scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;n); for (int i(1);i\u0026lt;=n;i++) { scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;a[i]); } build(1,1,n); int m,t,l,r,c; for (scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;m);m;m\u0026ndash;){ scanf(\u0026quot;%d%d%d\u0026rdquo;,\u0026amp;t,\u0026amp;l,\u0026amp;r); if (t \u0026amp; 1){ scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;c); insert(1,l,r,c); }else { //printf(\u0026quot;%d\\n\u0026rdquo;,getsum(1,l,r)); cout \u0026lt;\u0026lt; getsum(1,l,r) \u0026lt;\u0026lt; endl; } } return 0; } ","date":1369798148,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369798148,"objectID":"8bd39be10320dc79db2fe2fce1ef6187","permalink":"/post/csdn/%E5%8C%BA%E9%97%B4%E6%8F%92%E5%85%A5%E6%B1%82%E5%92%8C-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E4%BA%8C/","publishdate":"2013-05-29T11:29:08+08:00","relpermalink":"/post/csdn/%E5%8C%BA%E9%97%B4%E6%8F%92%E5%85%A5%E6%B1%82%E5%92%8C-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E4%BA%8C/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 void build(int v,int l,int r){ // 本段代码 同 数列操作1 st[v].l=l; st[v].r=r; if (st[v].l==st[v].r){ st[v].sum=a[l]; return ; } int mid = (l+r)/2; build(v2,l,mid); build(v2+1,mid+1,r); st[v].sum=st[v2].sum + st[v2+1].sum; } void insert(int v,int l,int r,long long c){ // 插入 st[v].sum+=c*(r-l+1); if (l==st[v].l \u0026amp;\u0026amp; r==st[v].r){ //","tags":[],"title":"区间插入求和  —  线段树入门（二）","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n void build(int v,int l,int r){ st[v].l = l; st[v].r = r; if (l == r) {\t// 是叶子，直接赋值，跳出 st[v].v=a[l]; return ; } int mid = (l+r)/2;\t// 不是叶子，往下扩展 build(2v,l,mid); build(2v+1,mid+1,r); st[v].v=st[v2].v+st[v2+1].v;\t// 扩展出孩子后才能计算value域 }\nvoid insert(int v,int w,int p){\t// 在以v为根的树中，寻找节点w，并把节点w的值加上p 。 格外注意 某些编程语言中insert不能作为标识符 if (w\u0026gt;=st[v].l \u0026amp;\u0026amp; w\u0026lt;=st[v].r){ st[v].v += p;\t// 父子之间为统治关系，凡是经过的节点都要更新value } if (st[v].l==st[v].r) return;\t// 找到终点，跳出 int mid = (st[v].l+st[v].r)/2; if (w\u0026lt;=mid) {\t// 判断左右孩子 insert(v2,w,p);\t}else { insert(v2+1,w,p); } }\nint getsum(int v,int l,int r){\t// 返回以v为根节点的树中，区间 [l,r] 的value域 if (st[v].l==l \u0026amp;\u0026amp; st[v].r==r){ return st[v].v;\t// 找到，返回 } int mid = (st[v].l+st[v].r)/2; if (r\u0026lt;=mid) { return getsum(v2,l,r);\t// 区间 [l,r] 在v的左枝上 }else if (l\u0026gt;mid) { return getsum(v2+1,l,r);\t// 右枝 }else {\t// 兵分两路 return getsum(v2,l,mid) + getsum(v2+1,mid+1,r); } }\nint main(void){ freopen(\u0026ldquo;1080.in\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); int n; scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;n); for (int i(1);i\u0026lt;=n;i++) { scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;a[i]); } build(1,1,n); int m,t,a,b; for (scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;m);m;m\u0026ndash;){ scanf(\u0026quot;%d%d%d\u0026rdquo;,\u0026amp;t,\u0026amp;a,\u0026amp;b); if (t \u0026amp; 1) { insert(1,a,b); }else { printf(\u0026quot;%d\\n\u0026rdquo;,getsum(1,a,b)); } } return 0; } ","date":1369752130,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369752130,"objectID":"c29e553ef285c4b72944744fbbee83d1","permalink":"/post/csdn/%E6%95%B0%E5%88%97%E6%93%8D%E4%BD%9C-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/","publishdate":"2013-05-28T22:42:10+08:00","relpermalink":"/post/csdn/%E6%95%B0%E5%88%97%E6%93%8D%E4%BD%9C-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 void build(int v,int l,int r){ st[v].l = l; st[v].r = r; if (l == r) { // 是叶子，直接赋值，跳出 st[v].v=a[l]; return ; } int mid = (l+r)/2; // 不是叶子，往下扩展 build(2v,l,mid); build(2v+1,mid+1,r); st[v].v=st[v2].v+st[v2+1].v; //","tags":[],"title":"数列操作  —  线段树入门","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1369416649,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369416649,"objectID":"93e902552d2bb784ae42a253a49dc4c6","permalink":"/post/csdn/csdn%E6%A8%A1%E7%89%88%E4%BF%AE%E6%94%B9/","publishdate":"2013-05-25T01:30:49+08:00","relpermalink":"/post/csdn/csdn%E6%A8%A1%E7%89%88%E4%BF%AE%E6%94%B9/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["CSDN"],"title":"CSDN模版修改","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1369389151,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369389151,"objectID":"787e9f76e06f12816ee13810f037b5d1","permalink":"/post/csdn/5611ah-%E6%95%B0%E7%A0%81%E7%AE%A1-%E5%BC%95%E8%84%9A%E5%9B%BE/","publishdate":"2013-05-24T17:52:31+08:00","relpermalink":"/post/csdn/5611ah-%E6%95%B0%E7%A0%81%E7%AE%A1-%E5%BC%95%E8%84%9A%E5%9B%BE/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["5611AH"],"title":"5611AH 数码管 引脚图","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  if (i*j\u0026amp;lt;10000 \u0026amp;amp;\u0026amp;amp; i*(j/10)\u0026amp;lt;1000 \u0026amp;amp;\u0026amp;amp; i*(j%10)\u0026amp;lt;1000 \u0026amp;amp;\u0026amp;amp; hash(j) \u0026amp;amp;\u0026amp;amp; hash(i*(j%10)) \u0026amp;amp;\u0026amp;amp; hash(i*(j/10)) \u0026amp;amp;\u0026amp;amp; hash(i*j)) { ans++; // printf(\u0026quot;%d * %d = %d0 + %d = %d \\n\u0026quot;,i,j,i*(j/10),i*(j%10),i*j); } } } } printf(\u0026quot;%d\\n\u0026quot;,ans); return 0;  }","date":1369192026,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369192026,"objectID":"a3bfa5e8bcaaf4d1f7aaca175a073bc8","permalink":"/post/csdn/usaco-section-1.3.6-prime-cryptarithm/","publishdate":"2013-05-22T11:07:06+08:00","relpermalink":"/post/csdn/usaco-section-1.3.6-prime-cryptarithm/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 if (i*j\u0026amp;lt;10000 \u0026amp;amp;\u0026amp;amp; i*(j/10)\u0026amp;lt;1000 \u0026amp;amp;\u0026amp;amp; i*(j%10)\u0026amp;lt;1000 \u0026amp;amp;\u0026amp;amp; hash(j) \u0026amp;amp;\u0026amp;amp; hash(i*(j%10)) \u0026amp;amp;\u0026amp;amp; hash(i*(j/10)) \u0026amp;amp;\u0026amp;amp; hash(i*j)) { ans++; // printf(\u0026quot;%d * %d = %d0 + %d = %d \\n\u0026quot;,i,j,i*(j/10),i*(j%10),i*j); } } } } printf(\u0026quot;%d\\n\u0026quot;,ans); return 0; }","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.3.6 Prime Cryptarithm","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1369191787,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369191787,"objectID":"ea4aada20dbd2b454bee60e1afd86cde","permalink":"/post/csdn/usaco-section-1.3.5-calf-flac/","publishdate":"2013-05-22T11:03:07+08:00","relpermalink":"/post/csdn/usaco-section-1.3.5-calf-flac/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.3.5 Calf Flac","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1369191249,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369191249,"objectID":"d3e41bb6094005b59e9861e40e9bc79a","permalink":"/post/csdn/usaco-section-1.3.3-barn-repair/","publishdate":"2013-05-22T10:54:09+08:00","relpermalink":"/post/csdn/usaco-section-1.3.3-barn-repair/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.3.3 Barn Repair","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n using namespace std;\nstruct milk { int w,p; };\nmilk a[maxn+1];\nint m,n;\nbool cmp(milk a ,milk b){ return a.p \u0026lt; b.p; }\nint main(){ freopen(\u0026ldquo;milk.in\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); freopen(\u0026ldquo;milk.out\u0026rdquo;,\u0026ldquo;w\u0026rdquo;,stdout); scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;m,\u0026amp;n); for (int i=1;i\u0026lt;=n;i++){ scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;a[i].p,\u0026amp;(a[i].w)); } sort(a+1,a+n+1,cmp); int s=m,sp=0,k; for (int i=1;s;i++){ if ((k=a[i].w)\u0026gt;s) k=s; s-=k; sp+=k*a[i].p; } printf(\u0026quot;%d\\n\u0026rdquo;,sp); return 0; } ","date":1369190674,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369190674,"objectID":"723db91ed01c4d3b4dca7f098993843a","permalink":"/post/csdn/usaco-section-1.3.2-mixing-milk/","publishdate":"2013-05-22T10:44:34+08:00","relpermalink":"/post/csdn/usaco-section-1.3.2-mixing-milk/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 using namespace std; struct milk { int w,p; }; milk a[maxn+1]; int m,n; bool cmp(milk a ,milk b){ return a.p \u0026lt; b.p; } int main(){ freopen(\u0026ldquo;milk.in\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,stdin); freopen(\u0026ldquo;milk.out\u0026rdquo;,\u0026ldquo;w\u0026rdquo;,stdout); scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;m,\u0026amp;n); for (int i=1;i\u0026lt;=n;i++){ scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;a[i].p,\u0026amp;(a[i].w)); } sort(a+1,a+n+1,cmp); int s=m,sp=0,k; for (int i=1;s;i++){ if ((k=a[i].w)\u0026gt;s) k=s; s-=k; sp+=k*a[i].p; } printf(\u0026quot;%d\\n\u0026rdquo;,sp); return 0; }","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.3.2 Mixing Milk","type":"post"},{"authors":null,"categories":["typecho"],"content":"这个电视最开始看，总觉得似曾相识。一拍大腿，发现全是新三国的演员。。。\n简单地说就是康熙、张飞、鲁肃、吕布、许攸、荀彧、刘备及其儿子各种叛变后重新划分天下。对于剧情不想评论太多，感觉自己想看的很多东西没有演出来。\n说一说人物 刘邦 刘邦：最开始还有刘季的痞气，到后面，已经看不出跟康熙有什么区别了。跟历代草根帝王一样，很大程度上这辈子就做一件事：用人。在前期（注意只是前期）称霸还是称王都会犹豫一下。到后面打哪个城要看看别人的意见。但是对于具体做事就不是很关心了。正如韩信所言：大王带将，韩信带兵。怎么带兵是将的事，我是统帅，我才不管你怎么折腾呢。它的学问在于，一个人，有没有用，能不能用。什么时候能用，什么时候就得处理掉。听上去，心狠手辣，仿佛众人皆棋子。不得不说，对于厚黑之道，刘邦团队表现的不亚于三国。不知如果把刘邦放在三国会是什么局面？\n  “我要命！我要什么脸啊！”\n  “他非要！”“你给了？”“他非要！”“你就给了？”“我和他说我来了。”“没给成？哈哈，没给成！没给成！没给成！”\n  “我是一家之主，我就是天，对错你都忍着。”\n  项羽 项羽：项羽一看，便是传统上我们所讲的大丈夫。一开始看到秦始皇依仗便有“男人当如是”的豪言。不愿与酒徒为伍，不愿与没有骨气的为伍。对人挺挑剔的，（反观刘邦，任人唯贤，有才无德？没事，能做事就行，大不了做完了再把你废了就是了）。让人受不了的是残暴无道，屠城杀降，这个没什么可说。令我想不透的是都说“江山梦、儿女情”，可项羽对天下却没什么兴趣，叔父整天教诲亡秦复楚这家伙真信了，千里迢迢跑到咸阳把秦灭了结果又千里迢迢地跑回来家做西楚霸王。与之对应的，项羽对虞姬的感情，没了她项羽就不活了一样。\n  “男人当如是。”\n  “国可不在，但尊严不可失，我楚人，绝不忍辱偷生！”\n  “一群躲在自己坑洞中 惶惶不可终日的窝囊废有什么时机可言。”\n  “如果可以，我想一辈子都听你弹琴……”\n  或许，人各有志，可怜范增老前辈日益唠叨 “ 一个人心有多大，天下就有多大。”\n垓下风凛冽，\r楚歌声凄切，多少离别，\r看夕阳西斜，\r踏破马蹄铁，\r恰似一钩晓月。\r张良 张良：不知道为什么，或许是自己历史知识的局限吧。剧中对张良的表现，好像自己的算盘很重，始终都在惦记着复韩。尤其是很多时候看刘邦的眼神，对刘邦的保留。给你的感觉对刘邦很不忠诚一样。或许有点像《诸葛亮死前6年与死后46年的世界》里讲的一样，英雄辈出的年代里，不同的英雄为了各自不同的梦想完成了共同的伟大的事业。\n韩信 韩信：自己是比较喜欢韩信的，但是在剧中，对韩信的表现极少。几场著名的战役都轻描淡写。我觉得作为楚汉传奇这段过程，同时又是中国谋战派代表人物，韩信怎么也该算一个重要角色吧。但是还是让人觉得作为汉朝顶梁柱，最后糟一群宫女乱棒打死甚为惋惜，感慨万千。狡兔死走狗烹。绝对是韩信结局的真实写照。演员上，段奕宏去演，总感觉有些别扭。但演的很不错的，除了在齐的个别镜头，其他的镜头让你觉得这跟章邯一样脑子只有打仗。\n英布 英布：同作为三大名将，英布的表现比韩信的还少，彭越就更不用说了。给人的感觉不如新水浒的豹子头。或许这部戏的重心想放在人物性格的刻画上吧。但既然耗费巨资，就该在画面镜头上下点功夫吧。同样结局凄凉。\n章邯 章邯：看到他，只有两个字：“军人”。最开始效忠秦朝，不涉政治。后来体恤士兵无奈归楚，既然为楚卖命，便一心谋战直至战死。无愧于“著名将领”。\n写在最后 整部片子让人感慨的除了战场的骁勇，更多的是战后众功臣的凄惨命运，张良引退、萧何、韩信、卢绾糟毒手。（留下来的只有曹参？）。让人想起春秋战国，每个生前不可一世的名臣良将，结局无一不令人悲叹。\n看完之后还是对这个局面更加了解了一些，更加明白后来汉武帝后来的晁错后来的主父偃。更加理解一个乱世的终结的多么的不容易。\n大江东去浪淘尽\r多少悲愁\r天下英雄时势造就\r风云人生为梦想奔走\r笑看成败\r曲终人散\r暮然回首\r你不在左右\r繁华过后才是寂寞的开头\r天下英雄\r大风吹 云飞扬\r谁知\r我心所向\r","date":1369045680,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1369045680,"objectID":"ed2ae4cca943ef751be6aee5af6ca645","permalink":"/post/typecho/68-%E7%94%B5%E5%BD%B1%E6%A5%9A%E6%B1%89%E4%BC%A0%E5%A5%87/","publishdate":"2013-05-20T18:28:00+08:00","relpermalink":"/post/typecho/68-%E7%94%B5%E5%BD%B1%E6%A5%9A%E6%B1%89%E4%BC%A0%E5%A5%87/","section":"post","summary":"这个电视最开始看，总觉得似曾相识。一拍大腿，发现全是新三国的演员。。。\n简单地说就是康熙、张飞、鲁肃、吕布、许攸、荀彧、刘备及其儿子各种叛变后重新划分天下。对于剧情不想评论太多，感觉自己想看的很多东西没有演出来。\n","tags":["随想","影视"],"title":"电影《楚汉传奇》","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1368969222,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1368969222,"objectID":"11531fe00776d577c36f54986de0d3b0","permalink":"/post/csdn/linux-%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/","publishdate":"2013-05-19T21:13:42+08:00","relpermalink":"/post/csdn/linux-%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["Linux"],"title":"Linux 系统问题整理","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1368859352,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1368859352,"objectID":"c65c42e7e72903de08757ebe7c4b582c","permalink":"/post/csdn/%E7%82%B9%E7%BA%BF%E8%AE%A1%E7%AE%97/","publishdate":"2013-05-18T14:42:32+08:00","relpermalink":"/post/csdn/%E7%82%B9%E7%BA%BF%E8%AE%A1%E7%AE%97/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":[],"title":"点线计算","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1368506998,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1368506998,"objectID":"9c3f8f6f1b85e98e113d9a17f0db8202","permalink":"/post/csdn/json-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","publishdate":"2013-05-14T12:49:58+08:00","relpermalink":"/post/csdn/json-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["JSON"],"title":"JSON 入门笔记","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1368424755,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1368424755,"objectID":"84cf25f4405d9776ad882da806020392","permalink":"/post/csdn/ajax-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","publishdate":"2013-05-13T13:59:15+08:00","relpermalink":"/post/csdn/ajax-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["AJAX"],"title":"AJAX 入门笔记","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ####Linux Deepin 特有源#### deb http://packages.linuxdeepin.com/deepin raring main universe non-free deb-src http://packages.linuxdeepin.com/deepin raring main universe non-free\ndeb http://packages.linuxdeepin.com/deepin raring-updates main universe non-free deb-src http://packages.linuxdeepin.com/deepin raring-updates main universe non-free ","date":1367483495,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1367483495,"objectID":"6cc9b6b5fcbdbbbe78e17190df2dcaee","permalink":"/post/csdn/linux-%E5%B0%8F%E7%99%BD%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%95%B4%E7%90%86/","publishdate":"2013-05-02T16:31:35+08:00","relpermalink":"/post/csdn/linux-%E5%B0%8F%E7%99%BD%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%95%B4%E7%90%86/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 ####Linux Deepin 特有源#### deb http://packages.linuxdeepin.com/deepin raring main universe non-free deb-src http://packages.linuxdeepin.com/deepin raring main universe non-free deb http://packages.linuxdeepin.com/deepin raring-updates main universe non-free deb-src http://packages.linuxdeepin.com/deepin raring-updates main universe non-free","tags":["Linux"],"title":"Linux 小白软件包整理","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n  } }  } void calcit(){ for (int i(0);i!=A.size();i++){ if (isNum(A[i][0])) { ans.push_back(gen(A[i])); }else{ double a1=ans[ans.size()-2]; double a2=ans[ans.size()-1]; printf(\u0026quot;%.2f%c%.2f=\u0026rdquo;,a1,A[i][0],a2); switch (A[i][0]){ case \u0026lsquo;+\u0026rsquo;: a1+=a2; break; case \u0026lsquo;-': a1-=a2; break; case \u0026lsquo;': a1=a2; break; case \u0026lsquo;/': if (!a2){ Quit(1); } a1/=a2; break; } printf(\u0026quot;%.2f\\n\u0026rdquo;,a1); ans.pop_back(); ans[ans.size()-1]=a1; } } printf(\u0026quot;%.3f\\n\u0026rdquo;,ans[0]); } int main(){ init(); ready(); changetype(); calcit(); return 0; } ","date":1367303658,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1367303658,"objectID":"778a7a5a19384c24e67372356e99d699","permalink":"/post/csdn/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/","publishdate":"2013-04-30T14:34:18+08:00","relpermalink":"/post/csdn/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 } } } void calcit(){ for (int i(0);i!=A.size();i++){ if (isNum(A[i][0])) { ans.push_back(gen(A[i])); }else{ double a1=ans[ans.size()-2]; double a2=ans[ans.size()-1]; printf(\u0026quot;%.2f%c%.2f=\u0026rdquo;,a1,A[i][0],a2); switch (A[i][0]){ case \u0026lsquo;+\u0026rsquo;: a1+=a2; break; case \u0026lsquo;-': a1-=a2; break; case \u0026lsquo;': a1=a2; break; case \u0026lsquo;/': if (!a2){ Quit(1); } a1/=a2; break; } printf(\u0026quot;%.2f\\n\u0026rdquo;,a1); ans.pop_back(); ans[ans.size()-1]=a1; } } printf(\u0026quot;%.3f\\n\u0026rdquo;,ans[0]); } int main(){","tags":[],"title":"表达式计算","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n \u0026quot;variants\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;Run\u0026quot;, \u0026quot;shell_cmd\u0026quot;: \u0026quot;g++ \\\u0026quot;${file}\\\u0026quot; -o \\\u0026quot;${file_path}/${file_base_name}\\\u0026quot; \u0026amp;amp;\u0026amp;amp; MyCallRun \\\u0026quot;${file_path}/${file_base_name}.exe\\\u0026quot;\u0026quot; // 其实就是这里加了个MyCallRun } ]  } gcc -shared -o libsublime-imfix.so sublime_imfix.c pkg-config --libs --cflags gtk+-2.0 -fPIC LD_PRELOAD=./libsublime-imfix.so sublime_text */ #include \u0026lt;gtk/gtk.h\u0026gt; #include \u0026lt;gdk/gdkx.h\u0026gt; typedef GdkSegment GdkRegionBox;\nstruct _GdkRegion { long size; long numRects; GdkRegionBox *rects; GdkRegionBox extents; };\nGtkIMContext *local_context;\nvoid gdk_region_get_clipbox (const GdkRegion *region, GdkRectangle *rectangle) { g_return_if_fail (region != NULL); g_return_if_fail (rectangle != NULL);\nrectangle-\u0026gt;x = region-\u0026gt;extents.x1; rectangle-\u0026gt;y = region-\u0026gt;extents.y1; rectangle-\u0026gt;width = region-\u0026gt;extents.x2 - region-\u0026gt;extents.x1; rectangle-\u0026gt;height = region-\u0026gt;extents.y2 - region-\u0026gt;extents.y1; GdkRectangle rect; rect.x = rectangle-\u0026gt;x; rect.y = rectangle-\u0026gt;y; rect.width = 0; rect.height = rectangle-\u0026gt;height; //The caret width is 2; //Maybe sometimes we will make a mistake, but for most of the time, it should be the caret. if(rectangle-\u0026gt;width == 2 \u0026amp;\u0026amp; GTK_IS_IM_CONTEXT(local_context)) { gtk_im_context_set_cursor_location(local_context, rectangle); } }\n//this is needed, for example, if you input something in file dialog and return back the edit area //context will lost, so here we set it again.\nstatic GdkFilterReturn event_filter (GdkXEvent *xevent, GdkEvent *event, gpointer im_context) { XEvent *xev = (XEvent *)xevent; if(xev-\u0026gt;type == KeyRelease \u0026amp;\u0026amp; GTK_IS_IM_CONTEXT(im_context)) { GdkWindow * win = g_object_get_data(G_OBJECT(im_context),\u0026ldquo;window\u0026rdquo;); if(GDK_IS_WINDOW(win)) gtk_im_context_set_client_window(im_context, win); } return GDK_FILTER_CONTINUE; }\nvoid gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window) { GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context));大 klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-\u0026gt;set_client_window) klass-\u0026gt;set_client_window (context, window);\nif(!GDK_IS_WINDOW (window)) return; g_object_set_data(G_OBJECT(context),\u0026ldquo;window\u0026rdquo;,window); int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 \u0026amp;\u0026amp; height !=0) { gtk_im_context_focus_in(context); local_context = context; } gdk_window_add_filter (window, event_filter, context); }步骤3：编译之\n","date":1366018960,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1366018960,"objectID":"42d95688853ba0303beae662dea043d7","permalink":"/post/csdn/sublime-text-3-%E5%8F%B2%E4%B8%8A%E6%9C%80%E6%80%A7%E6%84%9F%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/","publishdate":"2013-04-15T17:42:40+08:00","relpermalink":"/post/csdn/sublime-text-3-%E5%8F%B2%E4%B8%8A%E6%9C%80%E6%80%A7%E6%84%9F%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 \u0026quot;variants\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;Run\u0026quot;, \u0026quot;shell_cmd\u0026quot;: \u0026quot;g++ \\\u0026quot;${file}\\\u0026quot; -o \\\u0026quot;${file_path}/${file_base_name}\\\u0026quot; \u0026amp;amp;\u0026amp;amp; MyCallRun \\\u0026quot;${file_path}/${file_base_name}.exe\\\u0026quot;\u0026quot; // 其实就是这里加了个MyCallRun } ] } gcc -shared -o libsublime-imfix.so sublime_imfix.c pkg-config --libs --cflags gtk+-2.0 -fPIC LD_PRELOAD=./libsublime-imfix.so sublime_text */ #include \u0026lt;gtk/gtk.h\u0026gt;","tags":["Sublime"],"title":"Sublime Text 3 史上最性感的编辑器","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1364014982,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1364014982,"objectID":"4bb5ab52b2eb58cd8691ed6df449890a","permalink":"/post/csdn/poj-1088-%E6%BB%91%E9%9B%AA/","publishdate":"2013-03-23T13:03:02+08:00","relpermalink":"/post/csdn/poj-1088-%E6%BB%91%E9%9B%AA/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["POJ","Algorithm","ACM"],"title":"POJ 1088 滑雪","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1362996941,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1362996941,"objectID":"5c909cf7d41d0a756324fb807e759ba6","permalink":"/post/csdn/usaco-section-1.2.5-palindromic-squares/","publishdate":"2013-03-11T18:15:41+08:00","relpermalink":"/post/csdn/usaco-section-1.2.5-palindromic-squares/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.2.5 Palindromic Squares","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1362989087,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1362989087,"objectID":"458634bae348378718c3d59760ace021","permalink":"/post/csdn/usaco-section-1.2.3-transformations/","publishdate":"2013-03-11T16:04:47+08:00","relpermalink":"/post/csdn/usaco-section-1.2.3-transformations/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.2.3 Transformations","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1362460817,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1362460817,"objectID":"a348e3debf76fdd1feab6ce91fbe3a91","permalink":"/post/csdn/usaco-section-1.2.4-name-that-number/","publishdate":"2013-03-05T13:20:17+08:00","relpermalink":"/post/csdn/usaco-section-1.2.4-name-that-number/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.2.4 Name That Number","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n OUTPUT FORMAT A single line with two integers that represent the longest continuous time of milking and the longest idle time. SAMPLE OUTPUT (file milk2.out) 900 300","date":1362407001,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1362407001,"objectID":"096acb3e2b2b0f1b32c31d98f137e055","permalink":"/post/csdn/usaco-section-1.2.2-milking-cows/","publishdate":"2013-03-04T22:23:21+08:00","relpermalink":"/post/csdn/usaco-section-1.2.2-milking-cows/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 OUTPUT FORMAT A single line with two integers that represent the longest continuous time of milking and the longest idle time. SAMPLE OUTPUT (file milk2.out) 900 300","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.2.2 Milking Cows","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1362405498,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1362405498,"objectID":"0b917104ce3374d29a513c26dd345222","permalink":"/post/csdn/usaco-section-1.1.7-broken-necklace/","publishdate":"2013-03-04T21:58:18+08:00","relpermalink":"/post/csdn/usaco-section-1.1.7-broken-necklace/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["USACO","Algorithm","ACM"],"title":"USACO Section 1.1.7 Broken Necklace","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n 感谢你使用Gor编写博客 本文位于 posts/first-blog.md , 你可以任意删掉,修改这个文件  文件开头是当前文章的元数据\n date为自动生成, 当然,你可以修改,这是你的自由 permalink 可以是固定地址,也可以由gor为你自动生成 categories 就是分类, 可以多个 tags 同理,多个标签也是很常见的  请确保文件使用UTF8 without BOM编码\n你可以通过执行下面的语句来新建一篇博客: gor post 文章标题 编译你的博客,并预览之 gor compile #编译 gor http 然后打开你的浏览器,访问 http://127.0.0.1:8080 来预览\n你将使用Markdown来编写博客 Markdown 语法中文版 能让你快速入门其语法\n相信MarkdownPad或liteide会是你的编写博客的好帮手\n如果你打算部署到github的pages上  申请github帐户 新建一个库 username.github.com 即你的用户名命名的地址 将compiled目录,作为根路径,提交上去github.com上 稍等几分钟, 你即可通过 http://username.github.com 访问到  附上git教程 GitBook中文版 一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)\ngit clone git://github.com/wendal/wendal.net.git git add -A git commit -m \u0026quot;...\u0026quot; git pull git push 用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 gor的官网 提交issue 祝你使用愉快 ","date":1360296000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1360296000,"objectID":"5bb46bf92c767ce1d98a9e96fa60006f","permalink":"/post/dashayu/1360296000-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","publishdate":"2013-02-08T12:00:00+08:00","relpermalink":"/post/dashayu/1360296000-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 感谢你使用Gor编写博客 本文位于 posts/first-blog.md , 你可以任意删掉,修改这个文件 文件开头是当前文","tags":null,"title":"你的第一篇博客","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1360229082,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1360229082,"objectID":"297e0d52e9887486bc97cb6fd97dab56","permalink":"/post/csdn/%E5%81%87%E5%A6%82%E5%A5%B3%E4%BA%BA%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/","publishdate":"2013-02-07T17:24:42+08:00","relpermalink":"/post/csdn/%E5%81%87%E5%A6%82%E5%A5%B3%E4%BA%BA%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":[],"title":"假如女人是一种编程语言","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n #include \u0026lt;cstring\u0026gt;\nconst int MAXN=201,INF=(1\u0026lt;\u0026lt;31)-1;\nint c[MAXN][MAXN]; //残留网络\nint d[MAXN],vd[MAXN]; //d[]:距离标号, vd[]:标号为i的结点个数\nint n,m,flow;\nvoid init()\n{\nscanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;m,\u0026amp;n);\nfor(int i=1;i\u0026lt;=m;i++)\n{\nint j,k,wt;\nscanf(\u0026quot;%d%d%d\u0026rdquo;,\u0026amp;j,\u0026amp;k,\u0026amp;wt);\nc[j][k]+=wt;\n}\n}\nint Min(int a,int b) {return a\u0026lt;b?a:b;}\nint aug(int i,int augco) //i:顶点, augco:从i为起点的最大增广容量\n{\nint j, augc = augco, mind = n-1, delta;\nif(i==n) //到达汇点\nreturn augco;\nfor(j = 1;j \u0026lt;= n; j++) //枚举i的邻接点\nif(c[i][j]\u0026gt;0) //如果有边到j\n{\nif(d[i]==d[j]+1) //(i,j)为可进入弧\n{\ndelta = min(augc,c[i][j]); //求出经(i,j)的可增广最大值 delta = aug(j,delta); //递归增广，返回沿(i,j)的实际增广量 c[i][j] -= delta; //更新残留网络 c[j][i] += delta; augc -= delta; //augc记录剩下的需要增广的量 if(d[1]\u0026amp;gt;=n) //结束，向上一层返回经过i的实际增广量 return augco-augc; if(augc == 0) break; //已经到达可增广上界，提前跳出  }\nif (mind\u0026lt;d[j]) mind = d[j]; //更新最小的邻接点标号\n}\nif(augco==augc) //如果从i点无法增广\n{\nvd[d[i]]\u0026ndash;; //标号为d[i]的结点数-1\nif(vd[d[i]] ==0 ) //GAP优化\n d[1] = n;  d[i] = mind + 1; //更新标号\nvd[d[i]]++; //新标号的结点数+1\n}  return augco-augc; //向上一层返回经过i的实际增广量\n}\nvoid sap()\n{\nmemset(d,0,sizeof(d));\nmemset(vd,0,sizeof(vd));\nvd[0] = n;\nwhile(d[1] \u0026lt; n)\nflow+=aug(1,INF);\n}\nint main()\n{\ninit();\nsap();\nprintf(\u0026quot;%d\\n\u0026rdquo;,flow);\nreturn 0;\n} ","date":1360047643,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1360047643,"objectID":"1ddb1596eb89ca7713f4f9cf370ac58f","permalink":"/post/csdn/sap%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97-~%E8%BD%AC%E7%9A%84%E5%90%A7/","publishdate":"2013-02-05T15:00:43+08:00","relpermalink":"/post/csdn/sap%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97-~%E8%BD%AC%E7%9A%84%E5%90%A7/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 #include \u0026lt;cstring\u0026gt; const int MAXN=201,INF=(1\u0026lt;\u0026lt;31)-1; int c[MAXN][MAXN]; //残留网络 int d[MAXN],vd[MAXN]; //d[]:距离标号, vd[]:标号为i的结点个数 int n,m,flow; void init() { scanf(\u0026quot;%d%d\u0026rdquo;,\u0026amp;m,\u0026amp;n); for(int i=1;i\u0026lt;=m;i++) { int","tags":["SAP"],"title":"SAP算法心得 ~转的吧","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n int main(){int i,n[]={(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;\n1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))), (((1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(\n1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))+ (1\n\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\n\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))- ((1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1\n)))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(\n1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1\n)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))\n-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1)\n\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;\n1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;\n1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))), (((1\u0026lt;\u0026lt;1\n)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))- ((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))+(1\u0026lt;\u0026lt;1)), (((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (\n1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1)\n\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))-((1\u0026lt;\u0026lt;1) \u0026lt;\u0026lt;(1\u0026lt;\u0026lt; (1\u0026gt;\u0026gt;1)))),\n(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1))- ((1\n\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;\n1)))), (((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1) \u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+(1\u0026lt;\u0026lt;(1\n\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;(\n1\u0026gt;\u0026gt;1))) + (1\u0026lt;\u0026lt; (1\u0026gt;\u0026gt;1)))}; for(i=(1\u0026gt;\u0026gt;1);i\n\u0026lt;(((1\u0026lt;\u0026lt;1) \u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1\n))) + (1\u0026lt;\u0026lt;1)); i++) printf(\u0026quot;%c\u0026rdquo;,n[i]);\ngetchar();\n} #define () putchar(_);\nint main(void)\n{int i = 0;_(\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++i)_(++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++i)_(++++++++++++++\ni)(\u0026ndash;++i)(++++++i)_(\u0026mdash;\u0026mdash;\n 此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-i)_(\u0026mdash;\u0026mdash;\u0026ndash;\n 此页面通过工具从 csdn 导出，格式可能有问题。\n \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-i)_(++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++++\n++++++++++++++++++++++++++i)\n(\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-i)(++++++\ni)(\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;i)(\u0026mdash;\u0026mdash;\u0026ndash;\n 此页面通过工具从 csdn 导出，格式可能有问题。\n \u0026mdash;\u0026mdash;\u0026ndash;i)_(\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\n 此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n \u0026mdash;\u0026mdash;i)_(\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n 此页面通过工具从 csdn 导出，格式可能有问题。\n   此页面通过工具从 csdn 导出，格式可能有问题。\n i)\ngetchar();\nreturn i;\n}mov [04h], \u0026lsquo;e\u0026rsquo;\nmov [06h], \u0026lsquo;l\u0026rsquo;\nmov [08h], \u0026lsquo;l\u0026rsquo;\nmov [0ah], \u0026lsquo;o\u0026rsquo;\nmov [0ch], \u0026lsquo;,\u0026rsquo;\nmov [0eh], \u0026lsquo;W\u0026rsquo;\nmov [10h], \u0026lsquo;o\u0026rsquo;\nmov [12h], \u0026lsquo;r\u0026rsquo;\nmov [14h], \u0026lsquo;l\u0026rsquo;\nmov [16h], \u0026lsquo;d\u0026rsquo;\nmov [18h], \u0026lsquo;!\u0026rsquo;\n; color all characters: mov cx, 12 ; number of characters. mov di, 03h ; start from byte after \u0026lsquo;h\u0026rsquo;\nc: mov [di], 11101100b ; light red(1100) on yellow(1110) add di, 2 ; skip over next ascii code in vga memory. loop c\n; wait for any key press: mov ah, 0 int 16h\nret","date":1359768131,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1359768131,"objectID":"ff8d8667cec1566f9767746620a9cf1d","permalink":"/post/csdn/%E9%82%A3%E4%BA%9B-helloworld/","publishdate":"2013-02-02T09:22:11+08:00","relpermalink":"/post/csdn/%E9%82%A3%E4%BA%9B-helloworld/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 int main(){int i,n[]={(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt; 1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))), (((1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;( 1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))+ (1 \u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1 \u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))- ((1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1 )))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;( 1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1 )\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))) -((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))),((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1) \u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt; 1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt; 1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))-(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1))), (((1\u0026lt;\u0026lt;1 )\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))- ((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))+(1\u0026lt;\u0026lt;1)), (((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; ( 1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1))-((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1) \u0026lt;\u0026lt;(1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt;1)))-((1\u0026lt;\u0026lt;1) \u0026lt;\u0026lt;(1\u0026lt;\u0026lt; (1\u0026gt;\u0026gt;1)))), (((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;1))- ((1 \u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;(1\u0026gt;\u0026gt; 1)))), (((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1) \u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+(1\u0026lt;\u0026lt;(1 \u0026gt;\u0026gt;1))),(((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;(1\u0026lt;\u0026lt;1))+((1\u0026lt;\u0026lt;1)\u0026lt;\u0026lt; (1\u0026lt;\u0026lt;(","tags":[],"title":"那些 Helloworld","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1359722114,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1359722114,"objectID":"ed425f434286a535a6f64f3e6d31e246","permalink":"/post/csdn/jquery-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","publishdate":"2013-02-01T20:35:14+08:00","relpermalink":"/post/csdn/jquery-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["jQuery"],"title":"jQuery 入门笔记","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1359614513,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1359614513,"objectID":"85bc68537f200b9b82821ab51b8856f0","permalink":"/post/csdn/poj-%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E4%B8%8E%E8%AE%A1%E5%88%92/","publishdate":"2013-01-31T14:41:53+08:00","relpermalink":"/post/csdn/poj-%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB%E4%B8%8E%E8%AE%A1%E5%88%92/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["POJ","Algorithm","ACM"],"title":"POJ 题目分类与计划","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1358401007,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1358401007,"objectID":"6603d19b55082a3dc1e7879c0fd8200a","permalink":"/post/csdn/hdoj-1318-palindromes/","publishdate":"2013-01-17T13:36:47+08:00","relpermalink":"/post/csdn/hdoj-1318-palindromes/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["HDOJ","Algorithm","ACM"],"title":"HDOJ - 1318 Palindromes","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1357731421,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1357731421,"objectID":"053b6a01673ff2d2cd9302185f8031ab","permalink":"/post/csdn/%E4%B8%80%E4%BA%9B%E9%9A%8F%E4%BE%BF-%E6%9B%B4%E6%96%B0%E4%B8%AD/","publishdate":"2013-01-09T19:37:01+08:00","relpermalink":"/post/csdn/%E4%B8%80%E4%BA%9B%E9%9A%8F%E4%BE%BF-%E6%9B%B4%E6%96%B0%E4%B8%AD/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":[],"title":"一些随便 更新中。。","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1357646024,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1357646024,"objectID":"9543dd2b994ba2c025821a9ecbddb8d0","permalink":"/post/csdn/c%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2-%E4%B9%8B-printf%E5%8E%8B%E6%A0%88%E9%A1%BA%E5%BA%8F/","publishdate":"2013-01-08T19:53:44+08:00","relpermalink":"/post/csdn/c%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2-%E4%B9%8B-printf%E5%8E%8B%E6%A0%88%E9%A1%BA%E5%BA%8F/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["C"],"title":"C语言初探 之 printf压栈顺序","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1357277822,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1357277822,"objectID":"17812dbbba3e7a2bc01f48137adc48b7","permalink":"/post/csdn/c%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2-%E4%B9%8B-p/","publishdate":"2013-01-04T13:37:02+08:00","relpermalink":"/post/csdn/c%E8%AF%AD%E8%A8%80%E5%88%9D%E6%8E%A2-%E4%B9%8B-p/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["C"],"title":"C语言初探 之 %p","type":"post"},{"authors":null,"categories":["typecho"],"content":"不是所有的记忆都美好，不是所有的人都值得记忆，岁月的河流太漫长，大部分的人与事都会被无情地冲走，但是，与青春有关的一切，总会沉淀到河底，成为不可磨灭的美好回忆。令我们念念不忘的，也许并不是那些事和人，而是我们逝去的梦想和激情。\n","date":1356920280,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1356920280,"objectID":"d954fe8e9e410c2897cc1ca9e05976cd","permalink":"/post/typecho/%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E7%9A%84%E8%AE%B0%E5%BF%86%E9%83%BD%E7%BE%8E%E5%A5%BD/","publishdate":"2012-12-31T10:18:00+08:00","relpermalink":"/post/typecho/%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E7%9A%84%E8%AE%B0%E5%BF%86%E9%83%BD%E7%BE%8E%E5%A5%BD/","section":"post","summary":"不是所有的记忆都美好，不是所有的人都值得记忆，岁月的河流太漫长，大部分的人与事都会被无情地冲走，但是，与青春有关的一切，总会沉淀到河底，成为","tags":["鸡汤","我的微博","tweet"],"title":"不是所有的记忆都美好","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1353979596,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1353979596,"objectID":"d484dee048e9892ee2f088dcdfc13296","permalink":"/post/csdn/%E6%95%B0%E5%AD%97%E6%A0%B9%E4%BB%8B%E7%BB%8D/","publishdate":"2012-11-27T09:26:36+08:00","relpermalink":"/post/csdn/%E6%95%B0%E5%AD%97%E6%A0%B9%E4%BB%8B%E7%BB%8D/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":[],"title":"数字根介绍","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n ","date":1353589287,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1353589287,"objectID":"46c31a2a3f158d7a1e5f48f6e28d67cd","permalink":"/post/csdn/hdoj-2045-rpg%E9%9A%BE%E9%A2%98/","publishdate":"2012-11-22T21:01:27+08:00","relpermalink":"/post/csdn/hdoj-2045-rpg%E9%9A%BE%E9%A2%98/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。","tags":["HDOJ","Algorithm","ACM"],"title":"HDOJ - 2045 RPG难题","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n scanf(\u0026quot;%d\\n\u0026quot;,\u0026amp;amp;n); while (n--){ getline(cin,ss); if (yes(ss)) printf(\u0026quot;YES\\n\u0026quot;); else printf(\u0026quot;NO\\n\u0026quot;); } return 0;  } 我的博客 ","date":1353583062,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1353583062,"objectID":"cd57f72cc66ca463fc1a489116699f41","permalink":"/post/csdn/hdoj-2043-%E5%AF%86%E7%A0%81/","publishdate":"2012-11-22T19:17:42+08:00","relpermalink":"/post/csdn/hdoj-2043-%E5%AF%86%E7%A0%81/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 scanf(\u0026quot;%d\\n\u0026quot;,\u0026amp;amp;n); while (n--){ getline(cin,ss); if (yes(ss)) printf(\u0026quot;YES\\n\u0026quot;); else printf(\u0026quot;NO\\n\u0026quot;); } return 0; } 我的博客","tags":["HDOJ","Algorithm","ACM"],"title":"HDOJ – 2043 密码","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n inline int MAX(int a,int b) { if (a\u0026gt;b)return a; else return b;\n}\ninline void add(int u,int v,int cost) { e++; pre[e]=last[u]; last[u]=e; other[e]=v; w[e]=cost;\n}\ninline void init() { int i,u,v,cost; memset(last,0,sizeof(last)); e=0; scanf(\u0026quot;%d\\n\u0026rdquo;,\u0026amp;n); for (i=1;i\u0026lt;n;i++) { scanf(\u0026quot;%d%d%d\\n\u0026rdquo;,\u0026amp;u,\u0026amp;v,\u0026amp;cost); add(u,v,cost); add(v,u,cost); } }\ninline void dfs(int u) { dfsq[++indexs]=u; depq[indexs]=dep; if (pos[u]==0) pos[u]=indexs; //记录首次出现的位置 vis[u]=true; for (int p=last[u];p;p=pre[p]) if (vis[other[p]]==false) { dep++; dfs(other[p]); dep\u0026ndash;; dfsq[++indexs]=u;\ndepq[indexs]=dep; } }\ninline void st() { //f[i][j]表示深搜序列i到j中最小的深度值 //g[i][j]表示深度值最小的节点编号 int i,j; for (i=1;i\u0026lt;=indexs;i++) { f[i][0]=depq[i]; g[i][0]=dfsq[i]; } for (j=1;j\u0026lt;=int(log(indexs)/log(2));j++) for (i=1;i\u0026lt;=indexs-(1\u0026lt;\u0026lt;j)+1;i++) if (f[i][j-1]\u0026gt;f[i+(1\u0026lt;\u0026lt;(j-1))][j-1]) { f[i][j]=f[i+(1\u0026lt;\u0026lt;(j-1))][j-1]; g[i][j]=g[i+(1\u0026lt;\u0026lt;(j-1))][j-1]; } else { f[i][j]=f[i][j-1]; g[i][j]=g[i][j-1]; } }\ninline void getlca() { indexs=0; dep=1; memset(vis,0,sizeof(vis)); memset(pos,0,sizeof(pos)); dfs(1); st(); }\ninline int rmq(int x0,int y0) { int l,r,t,k; l=pos[x0]; r=pos[y0]; if (l\u0026gt;r) {t=l;l=r;r=t;} k=int(log(r-l+1)/log(2)); if (f[l][k]\u0026lt;f[r-(1\u0026lt;\u0026lt;k)+1][k]) return g[l][k]; else return g[r-(1\u0026lt;\u0026lt;k)+1][k]; }\ninline void build(int l,int r,int \u0026amp;t) { if (t==0) t=++node; int mid=(l+r)/2; left[t]=l; right[t]=r; if (l==r) { data[t]=w[fatherp[a[l]]]; return; } build(l,mid,leftnode[t]); build(mid+1,r,rightnode[t]); data[t]=MAX(data[leftnode[t]],data[rightnode[t]]); }\ninline int find(int l,int r,int t) { if ((l==left[t])\u0026amp;\u0026amp;(r==right[t])) return data[t]; int mid=(left[t]+right[t])/2; if (r\u0026lt;=mid) return find(l,r,leftnode[t]); if (l\u0026gt;=mid+1) return find(l,r,rightnode[t]); return MAX(find(l,mid,leftnode[t]),find(mid+1,r,rightnode[t])); }\ninline void change(int x,int v,int t) { if (left[t]==right[t]) { data[t]=v; return ; } int mid=(left[t]+right[t])/2; if (x\u0026lt;=mid) change(x,v,leftnode[t]); if (x\u0026gt;=mid+1) change(x,v,rightnode[t]); data[t]=MAX(data[leftnode[t]],data[rightnode[t]]); }\ninline void bfs() //求重链 { int i,j,l,r,q,p; memset(vis,0,sizeof(vis)); memset(maxs,0,sizeof(maxs)); memset(link,0,sizeof(link)); memset(next,0,sizeof(next)); node=0; id=0; memset(root,0,sizeof(root)); memset(leftnode,0,sizeof(leftnode)); memset(rightnode,0,sizeof(rightnode));\nmemset(dis,0,sizeof(dis)); memset(order,0,sizeof(order)); memset(pid,0,sizeof(pid)); memset(ed,0,sizeof(ed)); memset(father,0,sizeof(father)); memset(left,0,sizeof(left)); memset(right,0,sizeof(right)); memset(data,0,sizeof(data)); l=0; r=1; que[r]=1; vis[1]=true; dis[1]=1; //维护深度 while (l\u0026amp;lt;r) { q=que[++l]; for (p=last[q];p;p=pre[p]) if (vis[other[p]]==false) { vis[other[p]]=true; que[++r]=other[p]; father[other[p]]=q; //求得他的父亲节点编号 fatherp[other[p]]=p; //当前节点到父亲的边 dis[other[p]]=dis[q]+1; link[(p+1)/2]=other[p]; } } for (i=1;i\u0026amp;lt;=n;i++) s[i]=1; for (i=n;i;i--) s[father[que[i]]]+=s[que[i]]; for (i=1;i\u0026amp;lt;=n;i++) { q=que[i]; for (p=last[q];p;p=pre[p]) if (dis[q]\u0026amp;lt;dis[other[p]]) if (s[other[p]]\u0026amp;gt;maxs[q]) { maxs[q]=s[other[p]]; next[q]=other[p]; } } memset(vis,0,sizeof(vis)); for (i=1;i\u0026amp;lt;=n;i++) { q=que[i]; if (vis[q]==true) continue; id++; tot=0; ed[id]=q; do { a[++tot]=q; vis[q]=true; pid[q]=id; order[q]=tot; q=next[q]; } while (q!=0); build(1,tot,root[id]); } /*if (debug==2) for (i=1;i\u0026amp;lt;=n;i++) if (dis[i]\u0026amp;lt;dis[ed[pid[i]]]) printf(\u0026quot;?\u0026quot;);*/  }\ninline int ask(int x,int y) //从x节点一直到祖先y { int ans=-oo; //if (dt==1) printf(\u0026quot;%d %d\\n\u0026rdquo;,x,y); while (x!=y) { //if (dt==1) printf(\u0026ldquo;x : %d %d %d %d\\n\u0026rdquo;,x,y,dis[x],dis[y]); if (dis[ed[pid[x]]]\u0026lt;=dis[y]) //如果在一条链上 { ans=MAX(ans,find(order[y]+1,order[x],root[pid[x]])); break; } if (dis[ed[pid[x]]]\u0026gt;dis[y]) //如果不在一条链上 { ans=MAX(ans,find(1,order[x],root[pid[x]])); // if (dt==1) printf(\u0026ldquo;wo cao: %d %d\\n\u0026rdquo;,dis[x],dis[father[ed[pid[x]]]]); x=father[ed[pid[x]]]; continue; } } return ans; }\ninline void work() { char s[30]; int x,y;\nwhile (1) { scanf(\u0026quot;%s\u0026quot;,s); if (s[0]=='D') break; if (s[0]=='C') { scanf(\u0026quot;%d%d\\n\u0026quot;,\u0026amp;amp;x,\u0026amp;amp;y); change(order[link[x]],y,root[pid[link[x]]]); } if (s[0]=='Q') { scanf(\u0026quot;%d%d\\n\u0026quot;,\u0026amp;amp;x,\u0026amp;amp;y); lca=rmq(x,y); printf(\u0026quot;%d\\n\u0026quot;,MAX(ask(x,lca),ask(y,lca))); } }  }\nint main() { scanf(\u0026quot;%d\\n\u0026rdquo;,\u0026amp;test); while (test\u0026ndash;) { debug++; init(); getlca(); bfs(); work(); } //system(\u0026ldquo;pause\u0026rdquo;); return 0; }\n","date":1353388493,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1353388493,"objectID":"9bc091c0ad81ee7ee2a0ccedf59b43f7","permalink":"/post/csdn/qtree_testing/","publishdate":"2012-11-20T13:14:53+08:00","relpermalink":"/post/csdn/qtree_testing/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 inline int MAX(int a,int b) { if (a\u0026gt;b)return a; else return b; } inline void add(int u,int v,int cost) { e++; pre[e]=last[u]; last[u]=e; other[e]=v; w[e]=cost; } inline void init() { int i,u,v,cost; memset(last,0,sizeof(last)); e=0; scanf(\u0026quot;%d\\n\u0026rdquo;,\u0026amp;n); for (i=1;i\u0026lt;n;i++) { scanf(\u0026quot;%d%d%d\\n\u0026rdquo;,\u0026amp;u,\u0026amp;v,\u0026amp;cost); add(u,v,cost); add(v,u,cost); } } inline void dfs(int u) { dfsq[++indexs]=u; depq[indexs]=dep;","tags":["Qtree_testing"],"title":"Qtree_testing","type":"post"},{"authors":null,"categories":["typecho"],"content":"我是否也要像其他人一样写下：不知不觉来大学已经两个月了，咦！竟然恰好是两个月！满心是莫名的欢喜。\n两个月做了什么呢？\n学习依然同高中一样一塌糊涂。数学课仍然是听不进去，虽然在课下也能自己去搞，但是效果并不是很好。仍然是那么喜欢听历史课，如果有哲学课，我估计会更用心~或许，注定我不能去干技术了。\n课外活动据说是大学生活最重要的部分了。实际上所谓的课外生活，并没有想象中的那么精彩。很多同学们都进了社团或者部门，但是你却很少能听到哪个同学表示对哪个组织非常痴迷。\n我参加了院辩论队和学校ACM，辩论的话感觉力不从心，能说的人太多了，自己不过一坨屎。ACM的话，我在考虑是否要把四年的时间花在研究算法上呢。自己的数学能力事情是清楚的。\n网络技术，或许要学一点PHP和JSP，在互联网物联网时代，我不知道一个不懂网络的程序员的下场。\n","date":1352457000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1352457000,"objectID":"0acfa1a1a22b0a62e24d4bdcaf775319","permalink":"/post/typecho/47-%E5%BC%80%E5%AD%A660%E5%A4%A9%E5%B0%8F%E8%AE%B0/","publishdate":"2012-11-09T18:30:00+08:00","relpermalink":"/post/typecho/47-%E5%BC%80%E5%AD%A660%E5%A4%A9%E5%B0%8F%E8%AE%B0/","section":"post","summary":"我是否也要像其他人一样写下：不知不觉来大学已经两个月了，咦！竟然恰好是两个月！满心是莫名的欢喜。\n","tags":["记事"],"title":"开学60天小记","type":"post"},{"authors":null,"categories":["typecho"],"content":"又是一次Wordpress，希望这次可以好好的走下去，不要再只是闹着玩玩。\n大学了，或许会成为一个新的起点，希望在这里能够记下重生后的点点滴滴。当然，不可能每件事情都在这里留下，还有我的轻博客和微博以及人人，各种工具一起用，效果或许会更好点，信息更全面一点吧。至于各个博客地址，个人资料里会有更新。\n先来说一些废话吧，其实也不算废话，就是搭建博客的背景吧。\n简而言之，就是感觉混不不是很差劲，搭个博客自我安慰一下而已。具体一点的话，具体的其实就没了。其实还是很虚无的，不会因为搭个博客就会怎么怎么样的。有的还是有的，没有的还是不会蹦达出来。\n进大学这么久了，感觉还好的就是进入辩论队，而且成为ACM准队员了。辩论队么，或许只是一个玩玩的心态，不过玩了一次后，竟然玩出感情了，那份友谊，好像就是那么一瞬间给建立起来的。一起付出、一起流汗后的感情真不是大家在一起笑一笑就能出来的。以后大家在一起相处时间越来越长，希望大家的感情地久天长吧。\n关于ACM，我只能说准队员吧，因为一切未知。前天学长们做了一些介绍，果然被大家的激情感染了（或许是会想到了高中时一起在机房奋战（不光是OI，过来人都懂得），一起在车上聊天和三国杀，一起在宾馆里嬉戏。一起比赛之后那似笑非笑的表情和成绩下来后一张张哭丧的小脸）。而且学校实力不算差，除了激情，这应该算第二个激动人心的事情了，大家在努力，大家在进步，这远远比把你放在一个所谓的强队里让你去苦逼更加愉快。既然还是有底子的，还是要好好努力，给自己加油。或许是为了那份感动，或许是为了看些个美女，或许是为了那挺起看很诱人的奖金，或许是为了那个80道题就能拿到的百度包。不论动机如何，我都会努力。\n其他的杂事。。暂且就不说了吧。。因为那些并不是搭博的主要因素，以后整理整理再做专题慢慢介绍吧。好久不写，突然发现写的好虚，好空。唉。郁闷。先就这吧\n","date":1351420080,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1351420080,"objectID":"ee402e83a623ec0653637b4e6d96647c","permalink":"/post/typecho/45-hello-world/","publishdate":"2012-10-28T18:28:00+08:00","relpermalink":"/post/typecho/45-hello-world/","section":"post","summary":"又是一次Wordpress，希望这次可以好好的走下去，不要再只是闹着玩玩。\n大学了，或许会成为一个新的起点，希望在这里能够记下重生后的点点滴滴。当然，不可能每件事情都在这里留下，还有我的轻博客和微博以及人人，各种工具一起用，效果或许会更好点，信息更全面一点吧。至于各个博客地址，个人资料里会有更新。\n","tags":["记事"],"title":"Hello World","type":"post"},{"authors":null,"categories":["usc","csdn"],"content":" 此页面通过工具从 csdn 导出，格式可能有问题。\n intscore[6]; // i排第几intrank[6]; // 第i名是谁voidinvKT(intn, intk, intret[]); intguess(inti);\nintmain(){\n\u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; i=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;i\u0026amp;lt;=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;120\u0026lt;/span\u0026gt;;i++){ invKT(n, i, score+\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;); \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;j\u0026amp;lt;=n;j++) rank[score[j]] = j; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;if\u0026lt;/span\u0026gt; (guess(rank[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;]) \u0026amp;amp;\u0026amp;amp; guess(rank[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt;]) \u0026amp;amp;\u0026amp;amp; guess(rank[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;])==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; guess(rank[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;4\u0026lt;/span\u0026gt;])==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; guess(rank[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;])==\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; score[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]!=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;2\u0026lt;/span\u0026gt; \u0026amp;amp;\u0026amp;amp; score[\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;]!=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;3\u0026lt;/span\u0026gt;) { \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt; ( \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; j=\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;;j\u0026amp;lt;=n;j++){ \u0026lt;span class=\u0026quot;hljs-built_in\u0026quot;\u0026gt;printf\u0026lt;/span\u0026gt;(\u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;\u0026quot;%c：第%d名\\n\u0026quot;\u0026lt;/span\u0026gt;, \u0026lt;span class=\u0026quot;hljs-string\u0026quot;\u0026gt;'A'\u0026lt;/span\u0026gt;+j-\u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;1\u0026lt;/span\u0026gt;, score[j]); } } } \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;return\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;0\u0026lt;/span\u0026gt;;  }\nintguess(inti){ return(i==1)(score[5]==1) || (i==2)(score[2]==2) || (i==3)(score[1]==5) || (i==4)(score[3]!=1) || (i==5)*(score[4]==1); }\nintfac[]={1,1,2,6,24,120,720,5040,40320,362880}; voidinvKT(intn, intk, intret[]){ k\u0026ndash;; intvst[8]={0}, j; for( inti=0; i\u0026lt;n; i++){ intt = k/fac[n-i-1]; for(j=1; j\u0026lt;=n; j++){ if(!vst[j]){ if(t==0) break; t\u0026ndash;; } } ret[i] = j; vst[j] = 1; k %= fac[n-i-1]; } }","date":1350097751,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1350097751,"objectID":"210ab1a5037973aafe310021c5e024b0","permalink":"/post/csdn/%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8E%BB%E5%88%A4%E6%96%AD%E6%AF%8F%E4%B8%AA%E4%BA%BA%E8%AF%B4%E8%AF%9D%E7%9A%84%E7%9C%9F%E5%81%87-%E5%86%99%E7%BB%99%E6%96%B0%E6%89%8B%E7%9A%84%E6%9E%9A%E4%B8%BE%E4%BB%8B%E7%BB%8D/","publishdate":"2012-10-13T11:09:11+08:00","relpermalink":"/post/csdn/%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8E%BB%E5%88%A4%E6%96%AD%E6%AF%8F%E4%B8%AA%E4%BA%BA%E8%AF%B4%E8%AF%9D%E7%9A%84%E7%9C%9F%E5%81%87-%E5%86%99%E7%BB%99%E6%96%B0%E6%89%8B%E7%9A%84%E6%9E%9A%E4%B8%BE%E4%BB%8B%E7%BB%8D/","section":"post","summary":"此页面通过工具从 csdn 导出，格式可能有问题。 intscore[6]; // i排第几intrank[6]; // 第i名是谁voidinvKT(intn, intk, intret[]); intguess(inti); intmain(){ \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;int\u0026lt;/span\u0026gt; n = \u0026lt;span class=\u0026quot;hljs-number\u0026quot;\u0026gt;5\u0026lt;/span\u0026gt;; \u0026lt;span class=\u0026quot;hljs-keyword\u0026quot;\u0026gt;for\u0026lt;/span\u0026gt;","tags":[],"title":"用程序去判断每个人说话的真假 - 写给新手的枚举介绍","type":"post"},{"authors":null,"categories":["dashayu.tk"],"content":" 本文通过工具从以前的 html 转成 markdown，格式可能有问题。\n  window.onload = function(){ return; h1 = document.querySelectorAll(\u0026quot;h1\u0026quot;); h2 = document.querySelectorAll(\u0026quot;h2\u0026quot;); h3 = document.querySelectorAll(\u0026quot;h3\u0026quot;); h4 = document.querySelectorAll(\u0026quot;h4\u0026quot;); var txt = \u0026quot;\u0026lt;h2\u0026gt; Directory \u0026quot;; txt += \u0026quot;\u0026lt;pre\u0026gt;\u0026quot; for ( t1=0; t1\u0026lt;h1.length; t1++ ){ txt += \u0026quot;\u0026lt;h3\u0026gt;\u0026quot; + (tt[t1+1]) + \u0026quot;.\u0026quot; + h1[t1].innerHTML + \u0026quot;\u0026quot;; for ( t2=0; t2\u0026lt;h2.length; t2++ ) if (h2[t2].offsetTop \u0026gt; h1[t1].offsetTop \u0026amp;\u0026amp; ( t1==h1.length-1 || h2[t2].offsetTop \u0026lt; h1[t1+1].offsetTop )) { txt += \u0026quot;\u0026lt;h4\u0026gt; \u0026quot; + (t2+1) + \u0026quot;. \u0026quot; + h2[t2].innerHTML + \u0026quot;\u0026quot;; for (t3=0; t3\u0026lt;h3.length; t3++ ) if (h3[t3].offsetTop \u0026gt; h2[t2].offsetTop \u0026amp;\u0026amp; ( t2==h2.length-1 || h3[t3].offsetTop \u0026lt; h2[t2+1].offsetTop )) { txt += \u0026quot;\u0026lt;h5\u0026gt; \u0026quot; + (t3+1) + \u0026quot;) \u0026quot; + h3[t3].innerHTML + \u0026quot;\u0026quot;; for ( t4=0; t4\u0026lt;h4.length; t4++ ) if (h4[t4].offsetTop \u0026gt; h3[t3].offsetTop \u0026amp;\u0026amp; ( t3==h3.length-1 || h4[t4].offsetTop \u0026lt; h3[t3+1].offsetTop )) { txt += \u0026quot; | \u0026quot; + h4[t4].innerHTML + \u0026quot;\\n\u0026quot;; } } } } txt += \u0026quot;\u0026quot;; document.getElementById(\u0026quot;Directory\u0026quot;).innerHTML = txt; }  [](#acm语法基础)ACM语法基础 [](#c/cpp不常用的知识点)C/CPP不常用的知识点 字符串拆分 char ss[] = \u0026quot;(1,2,3,4)\u0026quot;; char *p = strtok(ss, \u0026quot;(,)\u0026quot;); for (int i(1); i\u0026lt;=n; i++) { sscanf(p, \u0026quot;%d\u0026quot;, \u0026amp;k); p = strtok(NULL, \u0026quot;,)\u0026quot;); } gets 、fgets 、getline  gets 会过滤行首空格（不含\\n） fgets 完全读入，把\\n吃进字符串末位，与scanf混用时容易出错 getline 自动跳转下一行，不会过滤行首空格  [](#java快速读写)Java快速读写 例题 @ hdoj 5047 Sawtooth 读入一个大数，按照特定公式计算结果。\nimport java.math.*; import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws Exception { BufferedReader cin = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter cout = new BufferedWriter(new OutputStreamWriter(System.out)); BigInteger n, ans, a1, a2, a7, a8; a1 = BigInteger.valueOf(1); a2 = BigInteger.valueOf(2); a7 = BigInteger.valueOf(7); a8 = BigInteger.valueOf(8); String ss = cin.readLine(); int T = Integer.parseInt(ss); for(int i=1; i\u0026lt;=T; i++){ ss = cin.readLine(); n = new BigInteger( ss ); cout.write( \u0026quot;Case #\u0026quot;+i+\u0026quot;: \u0026quot; ); ans = n.multiply(n).multiply(a8); ans = ans.subtract(a7.multiply(n)); ans = ans.add(a1); cout.write( ans.toString() ); cout.newLine(); cout.flush(); } } } [](#模拟易错点)模拟易错点 [](#a)a b @ POJ 1017 Packets | 装完大包装小包 /* 6种物品，体积分别为1*1 2*2 ... 6*6 。每种数量有20000 包裹体积为6*6，问装满所有的物品至少需要多少个包裹。 solution： 从大到小装，有缝隙了依次选小的。 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int n=6,t; int a[8]; int push(int t,int i, int num){ // 把num个a[i]放进容量为t的箱子里，返回箱子容量 if ( num \u0026gt; a[i]) num = a[i]; t -= i*i * num; a[i] -= num; return t; } int main(){ for(;;){ int ts = 0; for ( int i(1);i\u0026lt;=n;i++){ cin \u0026gt;\u0026gt; a[i]; ts+=a[i]; } if (!ts) break; int s =a[6]+a[5]+a[4]; // a5 if (a[5]*11 \u0026gt;= a[1]) a[1] = 0; else a[1] -= a[5]*11; // a4 for ( int i(1);i\u0026lt;=a[4];i++){ t = push(20,2,5); if (t) t = push(t,1,t); } // a3 s += a[3] / 4; // 整装3 a[3] %= 4; if (a[3]){ // 剩下的空间分情况装2 t = 36 - a[3]*9; if ( a[3] == 1 ) t = push(t,2,5); if ( a[3] == 2 ) t = push(t,2,3); if ( a[3] == 3 ) t = push(t,2,1); if (t) t = push(t,1,t); // 剩下的空间都装1 s++; } // a2 s += a[2] / 9; a[2] %= 9; if (a[2]){ t = 36 - a[2] * 4; t = push(t,1,t); s++; } // a1 s += a[1] / 36; a[1] %= 36; if (a[1]) s++; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } return 0; } @ USACO 1.4.3 The Clocks /* 根据九个表和九个操作的关系，得出下列关系表： 先列一下钟表与矩阵的关系图： Ci = C[i] / 3; clocks operates 1 1 2 4 ( C1 + p1 + p2 + p4 ) % 4 == 0 2 1 2 3 5 ( C2 + p1 + p2 + p3 + p5 ) % 4 == 0 3 2 3 6 ... 4 1 4 5 7 ... 5 1 3 5 7 9 ... 6 3 5 6 9 7 4 7 8 8 5 7 8 9 9 6 8 9 把上面的关系式反过来，就能在已知 c[i] 通过枚举部分 pi 求出其它 pi 我枚举的是123三个操作，然后剩下6个操作就可以就确定了。 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int c[11]; int cal(int a, int b, int c){ int t = - a - b - c; while ( t \u0026lt; 0 ) t += 4; return t; } int cal(int a, int b, int c, int d){ int t = - a - b - c - d; while ( t \u0026lt; 0 ) t += 4; return t; } int main(){ freopen(\u0026quot;clocks.in\u0026quot;,\u0026quot;r\u0026quot;,stdin); freopen(\u0026quot;clocks.out\u0026quot;,\u0026quot;w\u0026quot;,stdout); for (int i(1);i\u0026lt;=9;i++) { cin \u0026gt;\u0026gt; c[i]; c[i] /= 3; } int p[11]; bool found = false; for ( p[1] = 0; p[1] \u0026lt; 4; p[1]++ ){ for ( p[2] = 0; p[2] \u0026lt; 4; p[2]++ ){ for ( p[3] = 0; p[3] \u0026lt; 4; p[3]++ ){ p[4] = cal(c[1], p[1], p[2]); p[5] = cal(c[2], p[1], p[2], p[3]); p[6] = cal(c[3], p[2], p[3]); p[7] = cal(c[4], p[1], p[4], p[5]); p[8] = cal(c[7], p[4], p[7]); p[9] = cal(c[9], p[6], p[8]); if (((c[5] + p[1] + p[3] + p[5] + p[7] + p[9]) % 4 == 0) \u0026amp;\u0026amp; ((c[8] + p[5] + p[7] + p[8] + p[9] ) % 4 == 0) \u0026amp;\u0026amp; ((c[6] + p[3] + p[5] + p[6] + p[9] ) % 4 == 0 )){ found = 1; break; } if ( found ) break; } if ( found ) break; } if ( found ) break; } int i = 1; while ( p[i] == 0 ) i++; printf(\u0026quot;%d\u0026quot;,i); p[i--]--; while ( ++i \u0026lt;= 9 ) while ( p[i]-- ) printf(\u0026quot; %d\u0026quot;,i); printf(\u0026quot;\\n\u0026quot;); return 0; } [](#搜索)搜索 [](#多状态标记)多状态标记 @ HDU 5024 Wang Xifeng’s Little Plot 广州区域赛 /* 题意：找到一个最长的L型 思路：把L拆成两个直线，枚举所有的情况，记忆化搜索 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int maxn = 110; int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}; int dy[8] = {1, -1, 0, 0, 1, -1, 1, -1}; int n, f[maxn][maxn][8]; char g[maxn][maxn]; int dfs(int x, int y, int dir) { if (f[x][y][dir] != -1) return f[x][y][dir]; if (g[x+dx[dir]][y+dy[dir]] == '.') return f[x][y][dir] = 1 + dfs(x+dx[dir], y+dy[dir], dir); else return f[x][y][dir] = 1; } int main() { while (scanf(\u0026quot;%d\u0026quot;, \u0026amp;n) != EOF \u0026amp;\u0026amp; n) { memset(f, -1, sizeof(f)); memset(g, 0, sizeof(g)); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026quot;%s\u0026quot;, g[i]+1); int ans = -1; for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) if (g[i][j] == '.') { ans = max(ans, dfs(i, j, 0) + dfs(i, j, 2) - 1); ans = max(ans, dfs(i, j, 1) + dfs(i, j, 2) - 1); ans = max(ans, dfs(i, j, 1) + dfs(i, j, 3) - 1); ans = max(ans, dfs(i, j, 0) + dfs(i, j, 3) - 1); ans = max(ans, dfs(i, j, 4) + dfs(i, j, 5) - 1); ans = max(ans, dfs(i, j, 4) + dfs(i, j, 6) - 1); ans = max(ans, dfs(i, j, 7) + dfs(i, j, 5) - 1); ans = max(ans, dfs(i, j, 7) + dfs(i, j, 6) - 1); } printf(\u0026quot;%d\\n\u0026quot;, ans); } return 0; } @ HDU 5025 Saving Tang Monk 题意：给一个地图，孙悟空(K)救唐僧(T)，地图中’S’表示蛇，第一次到这要杀死蛇（蛇最多5条），多花费一分钟，’1’~’m’表示m个钥匙(m\u0026lt;=9)，孙悟空要依次拿到这m个钥匙，然后才能去救唐僧，集齐m个钥匙之前可以经过唐僧，集齐x个钥匙以前可以经过x+1,x+2..个钥匙，问最少多少步救到唐僧。\n/* 本题主要是每一条蛇状态的记录，使用状态压缩，将每一条蛇的状态用二进制位记录下来，1代表活，0代表死。 使用vis四维数组记录每一点走过的状态，x,y分别表示位置，k 钥匙，s 表示蛇的状态，b 表示步数。 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;map\u0026gt; const int inf=0xfffffff; typedef long long ll; using namespace std; char m[105][105]; int vis[105][105][15][40]; int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0}; int sx, sy, sn, N, M; struct node { int x, y, k, s, b; }; queue\u0026lt;node\u0026gt; q; int ans; void bfs() { node now; q.push((node){sx, sy, 0, 0, 0}); while(!q.empty()){ now = q.front(); q.pop(); int x = now.x, y = now.y, k = now.k, s = now.s, b = now.b; if(k == M \u0026amp;\u0026amp; m[x][y] == 'T'){ ans = min(ans, b); } if(vis[x][y][k][s] != 0) continue; vis[x][y][k][s] = 1; for(int i = 0; i \u0026lt; 4; i ++){ int nx = x + dx[i], ny = y + dy[i]; int snn = m[nx][ny] - 'A'; if(snn \u0026gt;= 0 \u0026amp;\u0026amp; snn \u0026lt; sn){ if((1\u0026lt;\u0026lt;snn) \u0026amp; s) q.push((node) {nx, ny, k, s, b + 1}); else q.push((node) {nx, ny, k, (1\u0026lt;\u0026lt;snn) | s, b + 2}); } else{ if(m[nx][ny] == k + '1'){ q.push((node) {nx, ny, k + 1, s, b + 1}); } else if(nx \u0026gt; 0 \u0026amp;\u0026amp; nx \u0026lt;= N \u0026amp;\u0026amp; ny \u0026gt; 0 \u0026amp;\u0026amp; ny \u0026lt;= N \u0026amp;\u0026amp; m[nx][ny] != '#') q.push((node) {nx, ny, k, s, b + 1}); } } } } int main() { //freopen(\u0026quot;in\u0026quot;, \u0026quot;r\u0026quot;, stdin); while(~scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;N, \u0026amp;M)){ if(N == 0 \u0026amp;\u0026amp; M == 0) break; memset(m, 0, sizeof(m)); memset(vis, 0, sizeof(vis)); sn = 0; for(int i = 1; i \u0026lt;= N; i ++){ scanf(\u0026quot;%s\u0026quot;, m[i] + 1); for(int j = 1; j \u0026lt;= N; j ++){ if(m[i][j] == 'K'){ sx = i; sy = j; } if(m[i][j] == 'S'){ m[i][j] = 'A' + sn; sn ++; } } } ans = inf; bfs(); if(ans == inf) printf(\u0026quot;impossible\\n\u0026quot;); else printf(\u0026quot;%d\\n\u0026quot;, ans); } return 0; } /* 解法：BFS，每个节点维护四个值： x,y ： 当前坐标 key ：已经集齐了key个钥匙 step：已经走了多少步 S ： 蛇的访问状态 (2^5的数表示，某位为1表示已经杀过了) 然后把唐僧看做钥匙m+1，再加点优化： 为了避免超时，用一个全局的dis[x][y][key][S] 表示到(x,y),已经集齐到key个钥匙，蛇的访问状态为S时的最小步数，如果BFS扩展的时候，当前状态的步数\u0026gt;=dis[当前状态]，那么就不再扩展下去了。 BFS中的逻辑就很简单了，看代码吧。 最后，枚举蛇的状态S，取dis[x][y][m+1][S]的最小值即为最小步数。 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;map\u0026gt; #define INF 0x3f3f3f3f using namespace std; #define N 1000007 int dis[104][104][12][33],Stot,M; struct node { int x,y,key,step,S; }; int dx[4] = {0,0,1,-1}; int dy[4] = {1,-1,0,0}; map\u0026lt;pair\u0026lt;int,int\u0026gt;,int\u0026gt; snake; char ss[105][105]; int n,m; bool OK(int nx,int ny) { if(nx \u0026lt; n \u0026amp;\u0026amp; nx \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; n \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ss[nx][ny] != '#') return true; return false; } void bfs(node s) { queue\u0026lt;node\u0026gt; que; que.push(s); while(!que.empty()) { node now = que.front(); que.pop(); int nx = now.x, ny = now.y; int key = now.key, step = now.step; int S = now.S; node tmp; for(int k=0;k\u0026lt;4;k++) { int kx = nx + dx[k]; int ky = ny + dy[k]; if(!OK(kx,ky)) continue; tmp.x = kx,tmp.y = ky; if(ss[kx][ky] == 'S') //蛇 { int ind = snake[make_pair(kx,ky)]; //是第几条蛇 tmp.key = key; if(S \u0026amp; (1\u0026lt;\u0026lt;(ind-1))) //如果已经杀死 { tmp.S = S; tmp.step = step+1; } else //否则要杀 { tmp.S = S|(1\u0026lt;\u0026lt;(ind-1)); tmp.step = step+2; } if(tmp.step \u0026lt; dis[kx][ky][tmp.key][tmp.S]) { dis[kx][ky][tmp.key][tmp.S] = tmp.step; que.push(tmp); } } else if(ss[kx][ky] \u0026gt;= '1' \u0026amp;\u0026amp; ss[kx][ky] \u0026lt;= '9') //钥匙点 { int num = ss[kx][ky] - '0'; tmp.step = step+1; tmp.S = S; if(num == key+1) //正好是要拿的那个 tmp.key = key+1; else tmp.key = key; if(tmp.step \u0026lt; dis[kx][ky][tmp.key][tmp.S]) { dis[kx][ky][tmp.key][tmp.S] = tmp.step; que.push(tmp); } } else if(ss[kx][ky] == '$') //唐僧这个点 { tmp.key = key; tmp.S = S; tmp.step = step+1; if(M == key+1) //已经集齐了所有钥匙，不再扩展，更新dis即可 dis[kx][ky][M][S] = min(dis[kx][ky][M][S],step+1); else //没有集齐，继续走 que.push(tmp); } else if(ss[kx][ky] == '.') { tmp.key = key; tmp.S = S; tmp.step = step+1; if(tmp.step \u0026lt; dis[kx][ky][tmp.key][tmp.S]) { dis[kx][ky][tmp.key][tmp.S] = tmp.step; que.push(tmp); } } } } } int main() { int Sx,Ex,Sy,Ey; int i,j; while(scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m)!=EOF \u0026amp;\u0026amp; n+m) { if(n == 1) { puts(\u0026quot;impossible\u0026quot;); continue; } snake.clear(); Stot = 0; M = m+1; for(i=0;i\u0026lt;n;i++) { scanf(\u0026quot;%s\u0026quot;,ss[i]); for(j=0;j\u0026lt;n;j++) { if(ss[i][j] == 'K') Sx = i,Sy = j, ss[i][j] = '.'; else if(ss[i][j] == 'T') Ex = i,Ey = j, ss[i][j] = '$'; else if(ss[i][j] == 'S') snake[make_pair(i,j)] = ++Stot; } } node tmp; tmp.x = Sx,tmp.y = Sy,tmp.key = 0,tmp.step = 0,tmp.S = 0; memset(dis,INF,sizeof(dis)); dis[Sx][Sy][0][0] = 0; bfs(tmp); int mini = INF; for(i=0;i\u0026lt;(1\u0026lt;\u0026lt;Stot);i++) mini = min(mini,dis[Ex][Ey][M][i]); if(mini == INF) puts(\u0026quot;impossible\u0026quot;); else printf(\u0026quot;%d\\n\u0026quot;,mini); } return 0; } [](#图论)图论 [](#欧拉回路-哈密顿回路)欧拉回路 哈密顿回路 判断存在 判断欧拉通路：\n  一个有向图存在欧拉回路必定也存在欧拉通路…因为通路的定义包括了回路 不考虑为欧拉回路的情况..一个有向图是欧拉通路就必须有一个点出度-入度=1,一个点入度-出度=1..这两点就是欧拉通路的起点和终点..并且该图连通 我自己加一条，其实是对2的理解：入读-出度\u0026gt;1 时直接return false ，排除 a-\u0026gt;b a-\u0026gt;c 这种情况   判断欧拉回路：\n 无向图是欧拉图的充要条件是所有点的度为偶数并且所有点联通\n有向图是欧拉图的充要条件是所有点的入度=出度..并且联通…\n 判断连通:\n  dfs遍历，这里有一份参考代码不过我一直怀疑其正确性。因为你无法确定有向图的起点，比如 a-\u0026gt;b-\u0026gt;c 如果你从b点开始搜的话就会悲催，但是你不知道b点上面还有没有点。 并查集，并查集的方便之处不用废话。但是在图论中两点之间有多条边时需要注意一些细节的处理。   关于判断入读出度:\n 一种办法是分别记录 in[] out[] 我用的办法是一个数组：sz[x]++ 表示拉出一条边，sz[x]–表示走来一条边，sz[x]==1 sz[x]==-1 就是上面的两种情况\n @ UVa 10129 Play on Words /* 题意就是给你一堆单词，按首位顺序排列起来，问你有没有解。 第一眼看上去是个哈密顿通路，单词当做节点，首尾关系作边，听上去妥妥的不过N有100000 复杂度太恐怖。 其实是从刘汝佳的小白书第二版（其实该叫小紫红书了）上欧拉回路那节看到的，所以得考虑考虑转换 把单词当边，首尾字符当做点 题目就转变为 欧拉通路 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define N 101010 using namespace std; int sz[333]; int fa[333]; bool ok[333]; // 数据中使用到的单词 int n, T; int getfa(int v) { if ( fa[v] == v ) return v; return fa[v] = getfa(fa[v]); } void init() { memset(ok, 0, sizeof(ok)); memset(sz, 0, sizeof(sz)); cin \u0026gt;\u0026gt; n; string a; for ( int i('a'); i \u0026lt;= 'z'; i++) fa[i] = i; for ( int i(1); i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a; int x = a[0], y = a[a.size() - 1]; fa[getfa(x)] = getfa(y); ok[x] = ok[y] = true; sz[x]++; sz[y]--; } } bool check() { int tf = 0 , i; for ( i = 'a'; i \u0026lt;= 'z'; i++) { if (ok[i]) { if ( !tf ) tf = getfa(i); else if ( getfa(i) != tf ) return false; // 不连通 } } int c1 = 0, c2 = 0; for ( int i('a'); i \u0026lt;= 'z'; i++) { if (!ok[i]) continue; if ( sz[i] == 0 ) continue; else if ( sz[i] == 1 ) c1++; else if ( sz[i] == -1) c2++; else return false; // 其它乱七八糟的情况 比如 ab ab out[a]=2 in[b]=2 } if ( (c1 == 1 \u0026amp;\u0026amp; c2 == 1) || (c1 == 0 \u0026amp;\u0026amp; c2 == 0) ) // 单向路径 or 回路 return true; else return false; } int main() { freopen(\u0026quot;in.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin); for ( cin \u0026gt;\u0026gt; T; T--; ) { init(); if (check()) cout \u0026lt;\u0026lt; \u0026quot;Ordering is possible.\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026quot;The door cannot be opened.\u0026quot; \u0026lt;\u0026lt; endl; } } [](#二分图最大匹配)二分图最大匹配 @ POJ 3041 Asteroids 匈牙利算法 /* 看起来像个 DP 神马的。竟然是二分图匹配。。 看着啊，行与行之间相互独立，一个行可以就炸掉很多列。（列的道理一样），如果替换一些字。 点与点之间相互独立，一个点就可以炸掉很多边。 so，可以把行列看成一个点，把一个炸弹看成一条边，然后题目就转换城了最小点击覆盖（即最大匹配）。 这个题的思路就是上面说的，每一个炸弹（x，y）看做一条边，两个端点就是它的行列x 和 y。任意炸掉x y期中一个点都可以把可以把这条边炸掉。跟题目一样了。 就这么神奇。。 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; const int N = 555; int n, m, g[N][N], chk[N], match[N]; int dfs(int v){ int t; for ( int i = 1; i \u0026lt;= n; i++){ if ( g[i][v] \u0026amp;\u0026amp; !chk[i] ){ chk[i] = 1; t = match[i]; match[i] = v; if ( t == -1 || dfs(t) ) return 1; match[i] = t; } } return 0; } int main(){ while ( ~scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n ,\u0026amp;m) ){ memset(g, 0, sizeof(g)); while ( m-- ){ int a, b; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b); g[a][b] = 1; } int ans = 0; memset(match, 255, sizeof(match)); for ( int i = 1; i \u0026lt;= n; i++){ memset( chk, 0, sizeof(chk)); ans += dfs(i); } printf(\u0026quot;%d\\n\u0026quot;, ans); } return 0; } ","date":1349668800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1349668800,"objectID":"c7788e5c30981a4bc38973c105b5915a","permalink":"/post/dashayu/1349668800-acmtips/","publishdate":"2012-10-08T12:00:00+08:00","relpermalink":"/post/dashayu/1349668800-acmtips/","section":"post","summary":"本文通过工具从以前的 html 转成 markdown，格式可能有问题。 window.onload = function(){ return; h1 = document.querySelectorAll(\u0026quot;h1\u0026quot;); h2 = document.querySelectorAll(\u0026quot;h2\u0026quot;); h3 = document.querySelectorAll(\u0026quot;h3\u0026quot;); h4 = document.querySelectorAll(\u0026quot;h4\u0026quot;); var txt = \u0026quot;\u0026lt;h2\u0026gt; Directory \u0026quot;; txt += \u0026quot;\u0026lt;pre\u0026gt;\u0026quot; for ( t1=0; t1\u0026lt;h1.length; t1++ ){ txt += \u0026quot;\u0026lt;h3\u0026gt;\u0026quot; + (tt[t1+1]) + \u0026quot;.\u0026quot; + h1[t1].innerHTML","tags":null,"title":"acmtips","type":"post"},{"authors":null,"categories":["typecho"],"content":"每个人心中都有一个理想的博客，这些并不是那些通用博客服务商能提供的，于是我选择自己动手搭建，用心逐雕。\n本文通篇按时间逆序记录\n转移 Typecho   [Todo] 图片全屏查看\n  [ToDo] 列表块跳转页面\n  [ToDo] 文章列表显示第一张图片\n  [2015-9-11] 迁移到阿里云，学生优惠，且虚拟主机太难管理\n  [2015-1-26] 迁移到阿里虚拟主机，送两年。速度快\n  [2014-11-27] 第一次正式购买服务器 BudgetVM\n  [2014-6-5] 使用多说评论框\n  [2014-6-4] 区别微博和文章\n  [2014-6-3] 文章页面添加目录功能\n  Aliyun抽奖到￥350，于是乎迁到此并换到 Typecho。同时开始重新设计前端\n  正式使用   [201305] 完成自己的第一套主题\n  [201210] 大一开学，换到欧洲的 hostyd，延迟从360ms降低到320ms\n  高考结束后，用美国的 000webhost + .tk + wordpress 搭建\n  第一次   2012元旦，在560教室拿zblog搭好第一个博客，国内某免费空间和域名\n ","date":1275539220,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1275539220,"objectID":"f64ca7e858de992f4ceb3873be56d67c","permalink":"/post/typecho/85-%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E6%97%A5%E5%BF%97/","publishdate":"2010-06-03T12:27:00+08:00","relpermalink":"/post/typecho/85-%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E6%97%A5%E5%BF%97/","section":"post","summary":"每个人心中都有一个理想的博客，这些并不是那些通用博客服务商能提供的，于是我选择自己动手搭建，用心逐雕。\n","tags":["记事","IT技术堆"],"title":"博客建设日志","type":"post"}]